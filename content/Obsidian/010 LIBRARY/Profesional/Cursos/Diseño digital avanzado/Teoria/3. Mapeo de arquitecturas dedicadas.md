**Clase:** [Mapeo de arquitecturas dedicadas](https://www.youtube.com/watch?v=tWA-X7M0zYM&t=4106s)
## Introduccion
  - El tema principal de la clase será cómo representar arquitecturas dedicadas, incluyendo conceptos de redes de procesamiento, diagramas en bloque y flujo de datos, así como medidas de rendimiento y una introducción a FPGA.
  - Tambien abordaremos metodologías de representación, como redes de procesamiento y diagramas de flujo de datos.
  - Como la discusión sobre la utilidad y aplicación de estos conceptos en el diseño de sistemas.

*DSP:* Procesamiento Digital de Señales
### Indice
1. Sistemas Discretos de Tiempo Real
2. Sistema de Hardware Digital Síncrono
3. Redes de Procesamiento tipo Kahn
4. Métodos para Representar Sistemas DSP
5. Medidas de Rendimiento
6. Arquitecturas Dedicadas
7. Introducción a FPGA

## Sistemas discretros de tiempo real
### Frecuencia de muestreo y de procesamiento
Un sistema de tiempo real discreto esta limitado por *frecuencia de muestreo(fs) y de procesamiento(fc)*.
- *Frecuencia de muestreo(fs)*: Frecuencia con la cual podemos tomar datos y convertirlos(ADC)
- *Frecuencia procesamiento(fc):* Frecuencia con la cual se trabaja adentro del sistema
Estos parametros nos indican si es posible o no implementar cierto sistemas que necesitamos, o como necesitamos modificar nuestro sistema para poder implementar tal sistema.
- Si ambas frecuencias son iguales estamos hablando de un sistema serial
- Se necesita *aplicar estructuras paralelas* en sistemas donde la *frecuencia de muestreo es mucho mayor* a la frecuencia de procesamiento
- Si *nuestra frecuencia de procesamiento es mucho mayor* a la de muestreo, podemos *reutilziar recursos*

#### Paralelismo
- El paralelismo suele incluir retardos de muestras y latencias
-  Considerando el tamaño del bloque y su impacto en el almacenamiento.
- Esto se debe que para coordinacion de paralelismo, esta coordinacion suele generar un aumento en el camino de datos
	- Para evitar que este camino critico nos afecte, se generan mas registros los cuales modifican el ancho de banda y otros parametros
- Por lo tanto se debe limitar el paralelismo de tal manera que no modifique nuestro algoritmo
### Bloques y procesamiento
El tamaño del bloque tambien es importante en muchas aplicaciones, ya que provoca un retraso inherente:
- Un bloque *grande* aumenta los requerimientos de retardos y memoria.
- Un bloque mas *pequeño* aumenta la sobrecarga de procesamiento


### Sistemas de procesamiento:
- *Tasa Única (Single-Rate):* El número de muestras por segundo a la entrada y salida del sistema es el mismo, y el número de muestras por segundo no cambia cuando las muestras se mueven de un bloque a otro para su procesamiento.
- *Multi-Tasa (Multi-Rate):* Los datos se procesan a diferentes velocidades en bloques diferentes, en donde para cada bloque se especifica el número de muestras por segundo y dependiendo de si el sistema es un transmisor o un receptor, el número de muestras por segundo puede aumentar o disminuir respectivamente para el procesamiento posterior.


  
### Sistemas sincrono
- Síncrono significa que todos los cambios en la lógica son controlados por un reloj de circuito.
	- La lógica digital síncrona suele estar diseñada en el nivel de transferencia de registros (Register Transfer Level - RTL).
![[Pasted image 20240205170938.png]]
- Al pasar por un bloque combinatorio estas señales experimentan diferentes retrasos en sus respectivos caminos, en donde el camino más largo o lento define el camino crítico (critical path).
	- El camino crítico limita la frecuencia de reloj más rápida posible de un diseño.




## Metodos para representar sistemas DSP
![[Pasted image 20240205122032.png]]
### Redes de procesamiento y nodos en sistemas CAN
#### Que es KPN?
- Las redes de procesamiento tipo Khan (Khan Process Network - KPN) proporcionan un método formal para estudiar como se comporta un sistema que considera sus entradas y salidas interconectadas a FIFOs y su posterior mapeo en el diseño digital.
	- El *KPN es un conjunto de procesos autónomos que se ejecutan simultáneamente* y que *se comunican entre sí de una manera punto a punto sobre FIFOs*, donde la *sincronización en la red se logra mediante una operación de lectura de bloqueo y todas las escrituras a las FIFO son no bloqueantes*.
- Un proceso espera en un modo de lectura de bloqueo para las FIFOs en cada uno de sus enlaces entrantes para obtener un número predefinido de muestras.
- Todos los nodos de la red se ejecutan después de que sus FIFOs de entrada asociadas hayan adquirido suficientes datos, donde dicha ejecución de un nodo se llama disparo (firing), y las muestras se llaman tokens.
- Estas redes ofrecen flexibilidad para diseñar sistemas con distintas operaciones y estructuras de comunicación entre procesos.
![[Pasted image 20240205120141.png]]
#### Limitaciones del modelo
- *La lectura de datos requiere estricta adhesión a FIFO, que obliga a las lecturas a seguir un orden secuencial desde el primer valor escrito en el buffer hasta el último*. 
	- Varios algoritmos de procesamiento de señal no siguen esta secuenciación estricta
		- Un ejemplo es un algoritmo FFT de decimación en el tiempo que lee datos en orden de direccionamiento bit-reverse.
- *Asume que una vez que se lee un valor de la FIFO, se elimina*. 
	- En muchos algoritmos de procesamiento de señales, los datos se utilizan varias veces. 
		- Por ejemplo, un algoritmo de convolución simple requiere múltiples iteraciones del algoritmo para leer los mismos datos una y otra vez.
- *Supone que todos los valores serán leídos*
	- En muchos algoritmos puede haber algunos valores que no requieren ninguna lectura y los datos se leen escasamente.

#### Modificacion para eliminar las limitaciones
![[Pasted image 20240205171821.png]]
  - Se introduce una estructura de red que combina FIFO y memoria para superar limitaciones y permitir un procesamiento más flexible.
- La memoria en el nodo del procesador, mantiene una copia de sus dados fifo de entrada.

  

 
### Descripciones ejecutables basadas en lenguaje
Los métodos basados en el lenguaje se utilizan para el desarrollo de software, y se utilizan lenguajes de alto nivel para codificar algoritmos.
- Los idiomas son interpretativos o ejecutables (Ejemplo Matlab, Python,etc).
- Para algoritmos computacionalmente intensivos, el diseñador prefiere escribir el código en C/C++ que son compilados entonces el ejecutable funciona mucho más rápidamente que su simulación equivalente de MATLAB.


### Especificación dirigida por gráficos o diagrama de flujo
Los métodos gráficos son especialmente convenientes para el mapeo de HW y la comprensión del funcionamiento y el flujo del algoritmo.
- Una representación gráfica es el método de elección para desarrollar hardware optimizado, generación de código y síntesis.
- Estos métodos también hacen hincapié en el diseño de arquitectura basada en componentes.
- Los componentes pueden estar parametrizados para ser reutilizados en una serie de instancias de diseño.
- Cada componente puede describirse adicionalmente en diferentes niveles de abstracción.

- *Algunas herramientas* que usan esta metodología son Simulink de Mathworks, Advanced Design Systems (ADS) de Agilent, Signal Processing Worksystem (SPW) de Cadence, Cocentric System Studio de Synopsys, LabVIEW de National Instruments y DSP Station de Mentor Graphics.
![[Pasted image 20240205121224.png]]


### Diagrama en Bloque
Un diagrama de bloques es un método gráfico muy simple que consiste en bloques funcionales conectados con bordes dirigidos.
- Un borde conectado representa el flujo de datos del bloque de origen al bloque de destino.
![[Pasted image 20240205121240.png]]
- Aqui podemos empezar a analizar la cantidad de bits que usaremos


### Gráfico de Flujo de Señal (SFG)
Es una versión simplificada de un diagrama de bloques.
- El funcionamiento de la multiplicación con una constante y los retrasos están representados por aristas, mientras 
- Lo nodos representan operaciones de suma, resta y de entrada y salida (I/O).
- SFGs se utilizan principalmente en la descripción de los algoritmos DSP.
![[Pasted image 20240205121348.png]]
  Sirve para:
  - Comprender cómo se mueve la señal dentro de un sistema.
  - Identificar el flujo de datos y su procesamiento dentro de nodos.
  - Análisis de cuántas muestras se procesan, cuántas se toman y cuánto tiempo lleva.

### Gráfico de flujo de datos (DFG)
Se describe un algoritmo de procesamiento de señales mediante un grafo dirigido $G = (V,E)$ 
- Un nodo $v \in V$ representa una unidad computacional o, en un diseño jerárquico. 
- Un borde dirigido $e \in E$ desde un nodo fuente a un nodo destino representa un buffer FIFO o simplemente precedencia de ejecución. 
	- También se utiliza para representar los retrasos algorítmicos introducidos en los datos mientras se mueve desde el nodo de origen al nodo de destino.
- Es de especial interés para los diseñadores de hardware, ya que captura la propiedad impulsada por datos de un algoritmo DSP. Además, expone la concurrencia oculta entre diferentes partes del algoritmo. 
	- Un DFG puede utilizarse para representar algoritmos DSP síncronos, asíncronos y de tasa múltiple.
	- Motiva al diseñador a pensar en términos de componentes, mejorando la reutilización de hardware.
	- También ayuda en la optimización, testing y verificación a nivel de módulos.
![[Pasted image 20240205121524.png]]



#### Síncrono DFG
Hay sistemas de procesamiento multimedia que consiste en procesos o tareas en las que *cada tarea opera sobre un número predefinido de muestras y luego produce un número fijo de valores de salida*.
- Estas tareas se ejecutan periódicamente en un orden definido.
- Aquí se conocen a priori el número de tokens consumidos por un nodo en cada uno de sus bordes y como resultado de su disparo el número de tokens que produce en sus bordes de salida.
![[Pasted image 20240205121648.png]]
- El analisis no es tanto el retador, si no mas bien para analizar paralelismo, esto puede llegar a confundir
	- El retardo dentro de este diagrama no es otro cosa que el tiempo que tengo que esperar para obtener un dato valido a la entrada de un bloque
##### Filtro IIR como un sincrono DFG
![[Pasted image 20240205180807.png]]




#### Disparo Auto-temporizado (Self-timed Firing)
- En un disparo auto-temporizado, un nodo se activa tan pronto como se obtiene el número necesario de tokens en sus bordes entrantes.
- Para implementar SDFG en hardware dedicado, se puede usar la ejecución auto-temporizada de nodos o un vector de repetición se puede calcular primero usando un conjunto equilibrado de ecuaciones.
- Este vector calcula disparos múltiples de cada nodo para hacer el SDFG consistente.
- Una implementación SDFG auto-temporizada generalmente da como resultado una fase transitoria, y después de eso la secuencia de disparo se repite en una fase periódica.
![[Pasted image 20240205122446.png]]
- Este diagrama no contempla los retardos del camino
- Muestra los retardos internos de los bloques y como demorarian en base a los recursos necesitados por cada bloque y dados por cada bloque
- Tampoco muestrea el almacenamiento de las muestras necesarias a la entrada de cada muetra




#### Simple y multi Tasa (Single-rate and Multy-rate) SDFGs
- En un SDFG de tasa única, la tasa de consumo $r_c$ es la misma que la tasa de producción $r_p$.
- En un SDFG multi tasa, estas tasas no son iguales y uno es un múltiplo racional del otro. Se pueden realizar interpolación y decimación en distintas etapas del sistema, lo que permite un mayor paralelismo y flexibilidad en el procesamiento de datos.
	- Un sistema es de tasa múltiple de decimación cuando $rc > rp.$
	- Un sistema es de interpolación cuando $rp < rc$ .
.![[Pasted image 20240205123128.png]]

![[Pasted image 20240205123531.png]]
- Nos identifica como va cambiando la tasa
- Tambien nos permite identificar cual sera el paralelimo en cada una de las etapas
  - El proceso implica procesamiento secuencial de muestras de entrada.
  - Se muestra cómo se generan y procesan las muestras secuenciales para llevar al sistema a un estado estable.

##### Paralelizacion
  - La arquitectura en paralelo implica retardos en los sistemas debido a la necesidad de sincronización entre bloques.
  - Los retardos surgen para garantizar la correcta propagación de datos entre bloques adyacentes. Se utiliza para sincronizar las muestras de salida con las muestras de entrada en sistemas paralelos.
	  - Permite que cada nodo del sistema utilice la muestra anterior del nodo adyacente para su procesamiento, manteniendo la coherencia de los datos en paralelo.
  - La paralelización permite optimizar el procesamiento al utilizar múltiples bloques simultáneamente con la misma referencia de reloj.



#### Cyclo-static DFG
En un DFG ciclo-estático, el número de tokens consumidos por cada nodo, aunque varía de iteración a iteración, exhibe periodicidad y repite el patrón después de un número fijo de iteraciones.
Adecuado para modelar varias aplicaciones de procesamiento de señal, ya que proporciona flexibilidad de diferentes tasas de producción y consumo de cada nodo siempre que el patrón se repita después de un número finito de iteraciones.
Esta representación también funciona bien para diseños en los que una secuencia periódica de funciones está asignada en el mismo bloque HW.
![[Pasted image 20240205124517.png]]

#### Gráficos de control de flujo(CDFG)
- Es adecuado para procesar un algoritmo de control.
- Estos algoritmos se encuentran generalmente en la implementación de protocolos de comunicación o diseños de controladores para rutas de datos.
- Combina funcionalidad controlada por datos y control específica de un algoritmo.
- Cada nodo del DFG representa una operación matemática, y cada borde representa la precedencia o una dependencia de datos entre las operaciones.
- Un CDFG puede cambiar el número de tokens producidos y consumidos por los nodos en diferentes ajustes de entrada.
- Un DFG con tasas variables de producción y consumo se denomina gráfico de flujo de datos dinámico (DDFG).

![[Pasted image 20240205124612.png]]

#### Transformaciones en un gráfico de flujo de datos
- Las transformaciones matemáticas convierten un DFG en un DFG más apropiado para la implementación de hardware.
- Estas transformaciones cambian la implementación del algoritmo de tal manera que el algoritmo transformado satisface mejor las metas específicas del diseño.
- De un conjunto de objetivos de diseño, el diseñador puede querer minimizar el retardo de la ruta crítica o el número de registros.
- Retiming, plegado, despliegue y look-ahead son algunas de las transformaciones utilizadas comúnmente.

![[Pasted image 20240205124633.png]]

  - El periodo de iteración está asociado con la frecuencia de procesamiento y el tiempo necesario para completar todas las operaciones para obtener un dato procesado.
  - La latencia indica el tiempo de retardo entre la entrada y la salida del sistema, siendo crucial para determinar la velocidad de respuesta del mismo.


### Máquina de estado finita (FSM)
Se utiliza para proporcionar señales de control a un camino de datos de procesamiento de señales para ejecutar un cálculo con una selección de operandos de un conjunto de operandos.
Un FSM genérico asume que un sistema está en uno de un número finito de estados.
Un FSM tiene un estado actual y, basado en un evento interno o externo, calcula el siguiente estado.
De esta manera, una vez que el FSM transita de un estado a otro, el datapath mantiene la implementación de diferentes porciones del algoritmo.
Además de implementar un planificador, el FSM también funciona bien para implementar protocolos donde se sigue un conjunto de procedimientos y sincronización entre varios componentes del sistema, como con el arbitraje de buses compartidos.







### [[Redes de Petri]]
Las redes de petri tambien se pueden considerar una manera de mapear arquitecturas dedicadas, tambien sirven tanto para sistemas autotemporizados como para otros tipos de sistemas



## **Selección de Modelos para el Diseño y Análisis de Arquitecturas Dedicadas**

En el diseño de arquitecturas digitales avanzadas, es crucial elegir el modelo adecuado para representar y analizar sistemas dependiendo de los requerimientos específicos del proyecto. A continuación, se presentan recomendaciones sobre cuándo utilizar cada uno de los modelos más comunes en el diseño de hardware digital:

### **1. Redes de Procesamiento Kahn (KPN)**
Las redes de procesamiento tipo Kahn son útiles para modelar sistemas que dependen de un flujo de datos secuencial a través de buffers FIFO. Estos modelos son ideales cuando se busca representar procesos que se comunican mediante canales punto a punto, especialmente en sistemas donde las entradas y salidas de datos requieren sincronización.

**Cuándo usar KPN**:
- Sistemas de procesamiento de señales donde los procesos deben ejecutarse de manera secuencial y dependiente de los datos previos.
- Implementaciones en las que la comunicación entre procesos ocurre a través de buffers, como en sistemas de comunicación digital o procesamiento en tiempo real.

### **2. Diagramas de Flujo de Datos (DFG)**
Los DFG son una representación visual sencilla y eficaz para describir el flujo de datos entre diferentes bloques de procesamiento. Son particularmente adecuados cuando se busca optimizar la eficiencia del sistema, especialmente en términos de paralelismo y latencia. Este modelo es fundamental en sistemas como DSP, donde el procesamiento de señales es intensivo y se necesita optimizar el rendimiento.

**Cuándo usar DFG**:
- Diseño de sistemas que requieren una alta optimización de rendimiento, como en procesamiento de imágenes, señales, o video.
- Proyectos en los que la latencia y el throughput son parámetros críticos para el éxito del diseño.
- Sistemas de procesamiento en paralelo donde se necesita maximizar la utilización de recursos de hardware como FPGA.

### **3. Redes de Petri**
Las redes de Petri son más generales y se usan para modelar sistemas donde la sincronización y la concurrencia son fundamentales. A diferencia de KPN y DFG, las Redes de Petri permiten representar situaciones complejas como la gestión de recursos compartidos, control de procesos paralelos, y análisis de bloqueos. Aunque son más complejas, ofrecen una flexibilidad excepcional en sistemas embebidos o controladores donde múltiples procesos interactúan y requieren coordinación precisa.

**Cuándo usar Redes de Petri**:
- Sistemas de control con múltiples procesos paralelos que compiten por recursos compartidos.
- Modelado de sistemas embebidos que requieren coordinación entre varios módulos, como controladores de buses o sistemas de enrutamiento de datos.
- Situaciones donde es necesario analizar bloqueos, concurrencia, y secuencias de eventos que ocurren de manera asíncrona.


## Medidas de rendimiento #Estudiar
[[Costo, performance y consumo de energia]]


### Período de iteración
*Iteracion:* Para un sistema de procesamiento de señal de tasa única, una iteración del algoritmo adquiere una muestra de un convertidor A=D y realiza un conjunto de operaciones para producir una muestra de salida correspondiente.
*Periodo de iteracion:* El tiempo que tarda el sistema en calcular todas las operaciones en una iteración de un algoritmo
- Se mide en unidades de tiempo o en número de ciclos.
- Para un sistema digital genérico, la relación entre la frecuencia de muestreo fs y la frecuencia de reloj de circuito fc es importante.
	- Cuando éstos son iguales, el período de iteración es determinado por el camino crítico.
- En los diseños donde $fc > fs$, el periodo de iteración se mide en términos del número de ciclos de reloj requeridos para calcular una muestra de salida.
- El periodo de iteracion entonces, esta asociado con la frecuencia de procesamiento


### Período de muestreo y Throughput
- El periodo de muestreo Ts se define como el tiempo promedio entre dos muestras de datos sucesivas.
- El periodo especifica el número de muestras por segundo de cualquier señal. El requisito de frecuencia o de frecuencia de muestreo (fs = 1=Ts) es específico de una aplicación y, posteriormente, obliga al diseñador a producir hardware que puede procesar los datos que se introducen en el sistema a esta tasa.
- A menudo, esta restricción requiere que el diseñador minimice los retrasos en la ruta crítica.
- Pueden reducirse utilizando unidades de cálculo más optimizadas o añadiendo retrasos en la lógica
- Los retrasos de pipelining añaden latencia en el diseño.
- En los diseños donde $fs < fc$ , el diseñador digital explora vías de intercambio de recursos para la reutilización óptima de bloques computacionales.



### Latencia
- La latencia se define como el retardo de tiempo para que el algoritmo produzca una salida $y[n]$ en respuesta a una entrada $x[n]$.
- En muchas aplicaciones los datos se adquieren en un buffer y después se introducen para su procesamiento, introduciendo latencia.
- Además de los retrasos algorítmicos, los registros de pipelining son la fuente principal de latencia en una sistema.
- Generalmente hay una relación inversa entre el camino crítico y la latencia.
- Con el fin de reducir la ruta crítica, se añaden registros de pipeline que dan lugar a un aumento de la latencia del diseño.

- La latencia afecta el comportamiento del sistema y está relacionada con la respuesta del filtro.

### Potencia
[[Diseño para bajo consumo de energia]]
- La disipación de potencia estática se debe a la corriente de fuga en la lógica digital.
- La disipación de potencia dinámica se debe a toda la actividad de conmutación, la cual constituye la mayor parte de la disipación de potencia en un diseño.
	- La disipación de potencia dinámica es específica del diseño, mientras que la disipación de potencia estática depende de la tecnología.
- En un FPGA, la disipación de potencia estática se debe a la corriente de fuga a través de diodos de polarización inversa.
- En el mismo FPGA, el uso de la energía dinámica depende de la frecuencia de reloj, la tensión de alimentación, la actividad de conmutación y la utilización de recursos.
- En el nivel de transferencia de registro (RTL), el diseñador puede determinar las partes del diseño que no están realizando cálculos útiles y se pueden apagar para ahorrar energía.
- Se utiliza la técnica gated clock para detener selectivamente el reloj en áreas que no están realizando cálculos en el ciclo actual.


  
## Arquitecturas dedicadas #Estudiar 
En sistemas como FPGAs, se utilizan componentes predefinidos para realizar operaciones específicas.
En un ASIC lo que vamos a hacer es seleccionar ciertas celdas estandar ya dadas en librerias, definidas por fabricantes. La selección de componentes está influenciada por el tiempo de propagación, área y necesidades del sistema.


### El espacio de diseño
- Para diseñar una lógica óptima para un problema dado, el diseñador explora el espacio de diseño donde hay varias opciones disponibles para mapear algoritmos en tiempo real en hardware.
- La frecuencia de reloj máxima alcanzable del circuito fc y la tasa de muestreo requerida de la entrada de datos al sistema fs juegan un papel crucial en la determinación y selección de la mejor opción.
- Los dispositivos digitales como FPGAs y ASICs pueden ejecutar la lógica a velocidades de reloj en el rango de 30 MHz a 800 MHz aproximadamente.
- En mucho diseño la arquitectura esta definida pero es posible mejorar el área aplicando otras técnicas en las operaciones de adición.
	- Lo mismo se aplica a los multiplicadores y shifters. Después de un mapeo uno a uno del DFG a la arquitectura, el diseño se evalúa para satisfacer la tasa de datos de entrada del sistema.
- En ocasiones, en las arquitecturas óptimas para las operaciones básicas, el diseño sintetizado no cumple los requisitos de tiempo.
- El diseñador necesita emplear transformaciones matemáticas apropiadas o puede agregar registros de pipeline para obtener una mejor sincronización.


### [[Paralelismo]]



### Ejemplo de diseño
#### Diagramando nuestro sistema
- Partiendo de un gráfico de flujo de datos que representa un algoritmo de procesamiento de señales se debe elegir los bloque básicos que menos recursos utilicen en el diseño.
- Luego podemos pasar a un diagrama en bloque para analizar ciertas mejoras en el sistema.
![[Pasted image 20240205191331.png]]
![[Pasted image 20240205191343.png]]
#### Selección de Bloques Diseño Básicos
- Se busca diseñar una arquitectura óptima con un área mínima y la mejor sincronización mientras mapea el DFG a una arquitectura totalmente dedicada.
- Comunmente no se elige el tipo de arquitectura dedicada que se usara, se usa la que viene por defecto, esta suele ser una lenta pero que ocupa poca area.
- En caso de no cumplir con los requerimientos, se analiza las diferentes arquitecturas dedicas en la libreria y se fuerza al sistema a utilizar una dada.
![[Pasted image 20240205191500.png]]
![[Pasted image 20240205191511.png]]
- Se debe seleccionar los coponentes en base a nuestro camino critico, haciendo un equilibrio entre area y tiempo




### DFG a Hardware
- Un gráfico de flujo de datos proporciona una representación visual completa a los algoritmos de procesamiento de señales.
- Cada nodo se caracteriza por las tasas de producción y consumo en cada puerto.
- En muchos casos, existen varias opciones para un componente representado como un nodo en el DFG en la biblioteca de diseño.
- Estos componentes intercambian el área con el tiempo de ejecución o el número de ciclos necesarios para procesar los datos de entrada.


### Mapeo de hardware de un sistema Multi-Rate
- Cada etapa se considera con sus índices de producción y consumo de muestras.
- Para una ventaja que requiere una producción de tasa múltiple para un consumo de tasa única, es posible una implementación paralela o secuencial.
- Una implementación paralela invoca cada nodo de destino varias veces, mientras que un ajuste secuencial almacena los datos en registros y lo introduce secuencialmente en un único nodo de destino.


#### Sistema con tasa de consumo menor a tasa de produccion
- Tenemos varias manera de implementar el mismo sistema, esto tambien depende de la relacion entre los relojes.

##### Serie
![[Pasted image 20240205192903.png]]
- Se ve la necesidad de almacenamiento en base a la diferencia entre lo producido y lo requerido.
	- Esto tambien se ve en la velocidad del clk
	- Para hacerlo serial necesitamos variar los clk

##### Paralelo
![[Pasted image 20240205192912.png]]
- En este caso no necesitamos modificar los clk como pasa en el serie
- Esta estructura tiene mayor area que la serial pero es mucho mas rapida


#### Sistema con menor tasa de produccion que de consumo
![[Pasted image 20240205192925.png]]
- Tenemos la necesidad de un control del sistema


## [[2. FPGA]]

## Referencias
### Notas relacionadas
- **Nota:**[[5. Gestion del Clk]]
	- **Relacion-Reflexion:** Podemos ver como los sistemas DFG sirven para representar sistemas autotemporizados al igual que las redes Khan
