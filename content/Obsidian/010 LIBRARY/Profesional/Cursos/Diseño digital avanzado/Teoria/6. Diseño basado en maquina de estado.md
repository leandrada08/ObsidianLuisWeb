
## Contenido
1. Contenidos Temáticos
2. Diseño con Máquinas de Estado
3. Ejemplos de Arq. Mult. en Tiempo
4. Secuenciamiento y Control
5. Rep. Algorítmica de máquinas de estado
6. Optimización de FSM
7. Diseño para Verificación
8. Métodos para Reducción de Potencia


## Introducción
- En las aplicaciones que son mapeadas en arquitecturas dedicadas paralelas, no es necesario utilizar el Hardware en cada ciclo de clock.
- Estos diseños utilizan los recursos de Hardware mínimos requeridos y luego comparten estos recursos en múltiples procesamientos del algoritmo en diferentes ciclos de clock.

- *Un diseño digital síncrono que comparte bloques de Hardware para procesamiento en diferentes ciclos de clock, requiere un controlador. Este controlador implementa un scheduler o planificador que dirige el uso de los recursos multiplexando en el tiempo.*
- Existen diferentes opciones para el controlador, entre ellos se encuentran las máquinas de estado de Moore y de Mealy que se tratan en este curso.
	- En la máquina *Mealy*, *la salida y el siguiente estado son funciones de la entrada y del estado actual*.
		- En diseños que usan la máquina *Mealy*, la salida puede cambiar con el cambio de entrada y puede *no permanecer estable durante un ciclo completo*.
	- En la máquina *Moore*, *el estado actual y la entrada solo computan el siguiente estado y la salida solo depende del estado actual*.
		- Las máquinas *Moore* proporcionan una entrada de *control estable* a la ruta de datos para un *ciclo de reloj completo*.

- En el diseño digital de procesamiento de señal, estas señales de salida se utilizan para seleccionar lógica en un datapath. Estas señales entonces son críticas respecto del tiempo y deberían ser estables durante el ciclo completo. Las señales de salida estables pueden obtenerse registrando la salida de una máquina de Mealy.
- Existen diferentes métodos para la codificación de los estados, estos métodos afectan al tamaño de los registros de estados. Una máquina de estado one-hot utiliza un flip-flop por cada estado. Esta opción es atractiva, ya que resulta en un análisis de tiempo simple y agregar o eliminar estados nuevos es trivial. Esta máquina tiene especial interés en FPGA ya que disponen de gran cantidad de flip-flops.
- Si el objetivo es conservar el número de flip-flops del registro de estados, se puede utilizar una máquina codificada-binaria.

## Ejemplos de uso

### Arquitectura de Bit-Serial
- Las aplicaciones que requieren mapeo en el tiempo con recursos de hardware compartidos, son representadas por simples gráficos de flujo de datos (DFGs) la lógica respectiva de planificación de estados.
- *La arquitectura Bit-Serial trabaja a una tasa bit-a-bit*. Esto resulta particularmente de interés cuando el dato es la entrada a un sistema en una tasa bit-a-bit en una interfaz serie. La interfaz brinda al diseñado la motivación para la arquitectura bit-serial.
- El procesamiento de bit-a-bit de datos recibidos de manera serial, *minimiza el área y muchas veces también reduce la complejidad del diseño* ya que en este caso no es necesario mantener el ordenamiento de bits en formato de palabras para su procesamiento.

- Una extensión de la arquitectura bit-serial es la *digit-serial* donde la arquitectura *divide un operando de N-bits en P* = N/M- dígitos-bit que alimentan al sistema de forma serial, y el datapath completo es de ancho P, donde *P es un entero.*
- La elección de P depende del requerimiento de la tasa de muestreo (throughput) de arquitectura y puede ser de ancho 1 a N bits.
- Es pertinente destacar que, como consecuencia en la densidad de los dispositivos, el área no suele ser un requerimiento muy importante, por lo que el diseñador no debería involucrarse en las complicaciones que implica el diseño bit-serial. Solo los diseños que de forma natural encajan en un procesamiento bit-serial deberían ser mapeados a estas arquitecturas.
![[Pasted image 20240304210128.png]]
- Ahora asumimos que en el ejemplo anterior, la frecuencia de muestreo es ocho veces más lenta que la frecuencia del circuito. Esta relación implica que el hardware se puede diseñar para compartir recursos 8 veces.
- Cuando se mapea el DFG para fc = 8fs el diseño se optimiza y se transforma en una arquitectura bit-serial en la cual las operaciones son efectuadas en una tasa bit-a-bit, utilizando de forma efectiva 8 clocks para cada muestra de entrada.
- En la siguiente filmina se muestra la implementación de Hardware del algoritmo, en la cual se utiliza un diseño bit-serial P = 1. El diseño consiste en un FA y un FS (Full Subtractor) reemplazando el sumador y substracción del diseño FDA.
- Asociadas a los FA y FS para adición de 1 bit encontramos dos Flip-Flops que se conectan al carry y borrow anteriores nuevamente al FA y al FS para las operaciones con las siguientes muestras.
- Cada 8 clocks se vacían los flip-flops cuando el nuevo dato de 8 bits es ingresado al circuito. La suma del FA se pasa al FS a través del pipeline.
- El datapath de un bit no requiere el empaquetado de bits intermedios para ninguna operación.
![[Pasted image 20240304210313.png]]

### Arquitectura secuencial
- En muchos diseños el algoritmo es tan regular que el hardware puede ser diseñado de manera secuencial para efectuar cada iteración en hardware compartido.
- El hardware ejecuta el algoritmo como si se tratara de un programa de software, secuencialmente implementando una iteración del algoritmo en un ciclo de clock. Esta arquitectura resulta en una optimización de hardware y normalmente requiere una lógica de control simple.
- Esos algoritmos que pueden ser mapeados a arquitecturas secuenciales pueden transformarse a sistemas paralelos.
- Las arquitecturas sistólicas pueden ser diseñadas para mapeo optimizado de Hardware.
- El próximo ejemplo considera el diseño de un multiplicador secuencial. El mismo multiplica dos números signados de N-bits a y b en N ciclos de clock. En el primer N -1 ciclo el multiplicador genera el producto parcial i (PP i) para un bit axb(i) y suma su versión desplazada a una suma.
- Para la multiplicación de signo por signo, el bit más significativo del multiplicador b tiene peso negativo. Entonces el valor desplazado N -1 del PP final para axb(N -1) se resta de la suma. Luego de N ciclos de clock la suma almacena el producto final de la operación.
![[Pasted image 20240304210911.png]]

### Ejemplo con filtro
En este ejemplo se explica la implementación de un filtro FIR de 5 coeficientes que implementa la siguiente
ecuación en diferencias:
Para la implementación secuencial, asumimos que fc es cinco veces más rápida que la frecuencia de muestreo
fs. Esto implica que luego de muestrear un valor de entrada a fs, el diseño corriendo a fc tiene 5 ciclos de clock
para procesar una muestra de salida.
Una implementación FDA requeriría 5 multiplicadores y 4 sumadores. Utilizando esta arquitectura, el diseño
operando a fc procesa la salida en un ciclo y luego esperaría durante cuatro ciclos la siguiente muestra de
entrada. Esto es un claro desperdicio de recursos, por lo que se prefiere una arquitectura multiplexada en el
tiempo.
![[Pasted image 20240304211715.png]]


### Arquitectura generica
![[Pasted image 20240304211837.png]]

## Secuenciamiento y Control
### Arquitecturas multiplexadas en el tiempo
- En general, las arquitecturas multiplexadas en el tiempo *consisten en datapath y unidad de control*. El *datapath es la etapa del procesamiento computacional* y consiste en registros, multiplexores, de-multiplexores, ALUs, multiplicadores, shifters, circuitos combinacionales y buses. Estos recursos de Hardware son compartidos a lo largo de los diferentes procesos del algoritmo.
- *El controlador genera las señales de control para la selección de estos operandos* en una secuencia predefinida.
- La secuencia está determinada por el diagrama de flujo de datos o flujo del algoritmo.
- Algunas de las operaciones en la secuencia pueden depender de resultados de procesos anteriores, con lo cual las señales de estado son realimentadas a la unidad de control.
- La secuencia de las operaciones puede depender también de señales de entrada de otros módulos de un sistema.
**Diagrama basico de arquitecturas multiplexadas en el tiempo**
![[Pasted image 20240304212208.png]]

### Maquina de estado finito
- Un diseño digital síncrono normalmente ejecuta una secuencia de operaciones en datos almacenados en registros y memorias de su datapath bajo la dirección de una máquina de estados finita (FSM).
- La FSM es un circuito digital con un registro de N-estados para almacenar el valor actual de la secuencia de operaciones. Un registro de estados de N-bit puede tener $2^N$ posibles valores, con lo cual en número de estados posibles en la secuencia es finito.
- La FSM puede describirse utilizando una diagrama de burbujas (estado) o un cuadro de máquina de estado algorítmica (ASM).
- La implementación de hardware de una FSM tiene dos componentes, una nube combinacional y una lógica secuencial. La nube combinacional procesa la salida y el siguiente estado basado en el estado actual y la entrada, mientras que la parte secuencial tiene el registro de estado con posibilidad de reset.
**Diagrama basico de una FSM**
![[Pasted image 20240304212621.png]]

### Codificacion de estados
- Existen varias formas de codificar los estados en un FSM. La codificación define una secuencia única de números para representar cada estado. Por ejemplo en una máquina “one-hot” con N estados existen N bits para representar estos estados. Un 1 aislado en una ubicación de bit única representa un estado particular de la máquina.
- Esto requiere un registro de estados de N bits.
- Si bien la máquina de estados one-hot resulta en la implementación de lógica simple para las transiciones de estado, requiere N flip-flops. La alternativa de asignación binaria requiere log2(N). Esto requiere menor cantidad de flip-flops pero la lógica que decodifica los estados y genera los estados siguientes es más compleja en este tipo de codificación.
- La máquina de estados con codificación one-hot es más útil en el caso de las FPGA que tienen una gran cantidad de flip-flops. La técnica también evita fan-out importante que se puede derivar de la codificación binaria de registros de estados, que no se sintetiza bien en FPGAs.
- Una variante llamada ’casi one-hot’ es similar aunque con la excepción de que el estado inicial es codificado como todos en cero. Esto ayuda a resetear el registro de estados. En otra variante se utilizan dos bits en lugar de uno.
- Para los diseños de baja potencia, el objetivo es reducir la distancia hamming entre transiciones de estado. Esto requiere que el diseñador conozca de manera estadística el patrón más probable de transición de estado. El patrón se codifica utilizando código gray. Estos cuatro tipos de codificación se muestran en la tabla.
- En el ejemplo anterior de FSM, si los estados se codificaran con one-hot, se necesitaría un registro de estados de tamaño 4 donde cada flip-flop del registro tendría asignado un estado de la FSM.
![[Pasted image 20240304213500.png]]

#### Ejemplo one-hot
Como consecuencia de la codificación one-hot, solo un bit del registro de estados puede ser 1. El diseñador debe gestionar los estados ilegales verificando si más de un bit en el registro de estados es 1. En diseños críticos se utiliza lógica independiente para verificar cuando la FSM se encuentra en un estado ilegal y entonces la lleva al estado de reset.

![[Pasted image 20240304213546.png]]

### Mealy FSM
- En una implementación de máquina de Mealy, la salida de la FSM es una función tanto del estado actual como de la entrada. Esto se prefiere en aplicaciones donde todas las entradas a una FSM son salidas registradas desde otros bloques y la generación del siguiente estado no es muy compleja. Resulta en una lógica combinacional simple con caminos críticos cortos.
- En los casos en los que la entrada a la FSM es asíncrona (es decir, que puede cambiar dentro de un ciclo de clock), las salidas de la máquina de estados también será asíncrona. Esto no es deseable especialmente en diseños en los cuales la salida de la FSM son señales de control para el datapath.
- Las unidades de procesamiento del datapath también son circuitos combinacionales, de manera que una señal de control asíncrona implica que el control puede no ser estable durante el ciclo de clock completo. Esto no es deseable ya que el datapath espera que todas las señales de control sean válidas por un ciclo completo de clock.
- En los diseños en los cuales la estabilidad de la señal de salida no es un requerimiento, se prefiere la máquina de Mealy ya que resulta en menor cantidad de estados. 
![[Pasted image 20240304214048.png]]


### Moore FSM
- En una implementación de una máquina de Moore, las salidas son únicamente función del estado actual. Debido a que el estado actual está registrado, las señales de salidas se encuentran estables durante un ciclo completo de clock. En contraste con la máquina de Mealy, la salida estará retrasada por un ciclo de clock.
- La elección entre la implementación de una FSM de Moore o Mealy es del diseñador y es independiente del problema de diseño. En muchos casos es una decisión directa la de elegir entre las dos opciones. En instancias en las que alguna de las entradas puede tener un glitch y las salidas deben ser estables por un ciclo completo de clock, el diseñador debería siempre utilizar una máquina de Moore.
- En la siguiente filmina se muestra un ejemplo de una máquina de Moore. La lógica combinacional logic-1 de la FSM computa el siguiente estado basada en las entradas y el estado actual y la etapa combinacional logic-2 de la FSM procesa la salida basándose en el estado actual.

![[Pasted image 20240304214420.png]]

### Guia para la codificaicon de FSM
#### Separar entre datapath y controlador
- El diseño completo de hardware normalmente consiste de datapath y controlador. El controlador se implementa como una máquina de estado. Desde el punto de vista de la síntesis, las partes de datapath y control tienen distintos objetos de diseño.
- El datapath se sintetiza para lograr objetivos de cierre de timing mientras que el controlador se sintetiza para ocupar la menor cantidad de área. El diseñador debería mantener la parte de la lógica de la FSM y el datapath en distintos módulos y luego sintetizarlos por separado para poder establecer los objetivos del diseño.

#### Codificacion de FSM en bloques de procedimiento
- La lógica en un módulo de FSM se codifica utilizando uno o dos *bloques always*. Se prefieren dos bloques always, uno en el cual se implemente *la lógica secuencial* que asigna el siguiente estado al registro de estado y otro en el cual se implemente *la lógica combinacional* que procesa el estado siguiente. *Si la salida es de fácil procesamiento* se puede computar de manera separada como *asignación continua.*

#### Codificacion de estados
- Cada estado en una FSM tiene un código asignado. Desde la perspectiva de la legibilidad, el diseñador debería utilizar etiquetas *utilizando parámetros o directivas define* para brindar información sobre los estados posibles.
	- Los parametros tienen el beneficio que hace reutilizable el bloque
- Se prefiere el uso de parámetros ya que el alcance del parámetro está limitado al módulo en el cual se define mientras que define es de alcance global.
- El uso de parámetros permite al diseñador utilizar los mismos nombres de estado con diferente codificación en otros módulos.
- El diseñador deberá elegir la mejor opción de *codificación entre one-hot, casi one-hot, gray o binario*. También deberá permitir a la herramienta de síntesis codificar los estados seleccionando las directivas apropiadas .Algunas herramientas permiten elegir el método de codificación especificando en la declaración de parameter.
- El datapath se sintetiza para lograr objetivos de cierre de timing mientras que el controlador se sintetiza para ocupar la menor cantidad de área. El diseñador debería mantener la parte de la lógica de la FSM y el datapath en distintos módulos y luego sintetizarlos por separado para poder establecer los objetivos del diseño.

##### Directivas de Sintesis
- Hay que evitar de usar default, ya que este se utilizara para simulacion
- De manera similar la sentencia Synopsis parallel_case se utiliza cuando todos los casos en un case, casex o casez son mutuamente excluyentes y el diseñador desea que sean evaluados de manera paralela o el orden en el cual serán evaluados no es importante. La directiva también indica que todos los casos deben ser evaluados individualmente y de manera paralela:
###### Full_case
- En muchos casos en donde *se utilizan algunos estados de todos los posibles en el registro de estados*, el diseñador puede indicar a la herramienta de síntesis que ignore los estados utilizados mientras se optimiza la lógica. 

- Por ejemplo, para Synopsis se utiliza la directiva:
``` Verilog
case(state) //Synopsys full_case
```
- Agregar esa directiva a la instrucción case indica a la síntesis que debe tratar todos los casos que no están definidos de manera explícita como ’don’t care’ para optimización. El diseñador sabe que los casos no definidos no van a suceder nunca. Considere el siguiente ejemplo:
``` Verilog
always @(*) begin
	case(cntr)
		2'b00: out=in1;
		2'b01: out=in2;
		2'b10: out=in3;
	end case
```
- El usuario controla a la herramienta de síntesis indicando que la señal cntr nunca va a tomar el valor no utilizado 2’b11. La herramienta optimiza la lógica considerando este caso como ‘don’t care’.

###### Parallel_case
- la sentencia Synopsis parallel_case se utiliza cuando todos los casos en un case, casex o casez son mutuamente excluyentes y el diseñador desea que sean evaluados de manera paralela o el orden en el cual serán evaluados no es importante. La directiva también indica que todos los casos deben ser evaluados individualmente y de manera paralela:

``` Verilog
always @( * ) begin
	 //Code for set t ing the output to defaul t comes here
	casez ( int r_req ) / / Synopsys paral lel_case
		3’b??1:
			begin // Check bi t 0 while ignoring rest
				//Code for inter rupt 0 comes here
			 end
		3’b?1?:
			begin // Check bi t 1 while ignoring rest
				//Code for inter rupt 1 comes here
			 end
		3’b1??:
			begin // Check bi t 2 while ignoring rest
				// Code for inter rupt 2 comes here
			 end
	endcase // casez ( int r_req )
end
```


## Representacion Algoritmica de los estados
- *Los diagramas de burbuja* (diagramas de estado) *no son lo suficientemente flexibles para describir el comportamiento* complejo de estas máquinas de estado.
- Para estos casos *se utiliza una notación de máquina de estado algorítmica (ASM).* Es un tipo de gráfico del tipo de *diagrama de flujo que describe el comportamiento ciclo a ciclo* de un algoritmo. Cada paso de transición entre un estado y otro o al mismo estado lleva un ciclo de clock.
- El ASM esta compuesto por *3 bloques básicos*: *Rectángulos, diamantes y óvalos*. Se utilizan flechas para interconectar estos bloques. Cada *rectángulo representa un estado* y la salida de un estado se escribe dentro de un rectángulo. *La salida de un estado siempre es una salida incondicional, que se valida cuando la transición de la máquina de estado se representa por el respectivo rectángulo.*
![[Pasted image 20240305095618.png]]

## Optimizacion de FSM
- Existen varias formas de implementar una FSM. El diseñador, basado en una serie de objetivos de diseño puede seleccionar entra las opciones y luego la herramienta de síntesis realiza una optimización sobre la implementación de la FSM.
- La herramienta, basada en criterios de optimización, transforma la FSM a una versión con la misma funcionalidad pero topológicamente distinta. Generalmente se optimiza para baja potencia y área reducida. La disipación dinámica de potencia en la lógica digital depende de la actividad de switching. Las herramientas, mientras generan una minimización de los estados para reducir el área, también apuntan a minimizar la actividad de switching total.
- De la variedad de algoritmos de optimización disponibles, uno es encontrar el estado crítico que está conectado a muchos estados. En esta situación la transición a este estado crítico puede causar grandes distancias hamming, generando gran actividad de switching. El algoritmo, luego de identificar este estado crítico lo separa en dos para reducir la distancia hamming y luego analiza la FSM para evaluar si esta separación produce un gran incremento de área.

![[Pasted image 20240305100637.png]]


## Diseño para verificacion
- Desde el punto de vista de la verificación, se recomienda *agregar a una FSM la posibilidad de reset y la capacidad de reportar el estado*. Para proveer a una FSM con capacidad de reset, debería existir una entrada que provoque que la FSM *realice una transición desde cualquier estado a un estado definido inicial*.
- Una máquina de estado con capacidad de reportar el estado también aumenta la posibilidad de verificación de un diseño. Una FSM con esta característica siempre retorna el estado actual para una entrada de consulta definida.
- A la metodología general para verificación de diseños digitales, se le puede sumar un documento de especificación sobre la máquina de estado que defina el comportamiento de la FSM para todas las secuencias posibles de entradas. Esto requiere al desarrollador generar una serie de secuencias de operación que puedan verificar todas las transiciones de una FSM.
- Para una verificación inicial a nivel módulo white-box, el estímulo debería llevar un registro de todas las transiciones correspondientes a estados internos de la FSM y las entradas y salidas previas a la aparición de una falla.
- Esto ayuda al diseñador a encontrar de manera más fácil un bug.
- Para una secuencia de entradas, utilizando las especificaciones de diseño, el diseñador debe encontrar la correspondiente secuencia de salidas para escribir los casos de prueba.
- Varias *medidas de Coverage* (cobertura de código) se utilizan para evaluar la eficiencia de las pruebas. Se puede disponer de herramientas de coverage que el diseñador puede incorporar al flujo de RTL. Estas herramientas ayudan a identificar áreas no verificadas de una implementación de FSM. El diseñador entonces puede generar nuevos casos para verificar esas áreas.

### Tipos de Coverage
#### Coverage de Código
- Es la métrica más simple que valida que todas las líneas del código se ejecutan al menos una vez. Es común de verificar a través de simuladores. Si bien una cobertura de código de 100% es una buena medida inicial, no es un indicador suficiente de la calidad de la verificación.
#### Coverage de Toggle
- Esta medida verifica si cada bit de todos los registros produjo una transición de 0 a 1 y de 1 a 0 al menos una vez. Cubrir esta es bastante difícil ya que el contenido de los registros suele ser el resultado de funciones complejas. Suelen utilizarse pruebas random para verificar esta métrica.
#### Coverage de Estados
- Esta etapa de cobertura lleva el registro de la frecuencia de las transiciones a los diferentes estados. El objetivo es asegurarse que las verificaciones provoquen las transiciones de la FSM por todos los estados al menos una vez. 
- En muchas FSM se puede llegar a un mismo estado desde diferentes estados, por lo tanto este tipo de coverage no garantiza la verificación completa de la FSM
#### Coverage de Transición o de Arco
- Esta métrica requiere que la FSM utilice todas las transiciones del diseño al menos una vez.
#### Coverage de Path
- Esta es la medición de cobertura más intensiva para evaluar un diseño. Comenzando desde el estado inicial, atravesando todos los path del diseño lleva a una verificación muy completa. En muchos diseños con un número grande de estados, la generación exhaustiva de vectores de prueba para atravesar todos los posibles paths puede no ser posible, por lo que se requieren técnicas para generar caminos no triviales para verificar.
- Una de las técnicas es ’reducción del espacio de estado’. Esto reduce la FSM a una FSM más pequeña a través de unir distintos nodos en uno. Entonces se verifica el coverage de path para esa FSM reducida.

## Metodos para reduccion de potencia
Tenemos 2 tipos de potencia cuando analizamos sistemas digitales, la estatica no se puede cambiar porque viene dada por la tecnologia, pero la potencia de switching si, esta tambien llamada [potencia dinamica](CMOS.md#Potencia]]) 
### Potencia de Switching
- La distribución de la red de clock y el switching de clock son las dos fuentes de mayor consumo de potencia. La potencia de switching está dada por la siguiente expresión:
$P_{avg}= \eta \alpha_{avg}\frac{f}{2} C_{avg}V^2_{dd}$    
- En la expresión $\eta$ es *número total de nodos en el circuito*, $\alpha_{avg}$ es la *actividad promedio* de switching en un nodo, f es la *frecuencia de clock*, C la *carga capacitiva* y Vdd es el *voltaje de la fuente*. Es de suponer, que eliminando el clock en la red de distribución y reduciendo la actividad de switching promedio se puede reducir la disipación de potencia promedio.
	- Lo que si podemos modificar en base a diseño es la actividad promedio y esto lo hacemos en base a diseño clock gating
- En un diseño con máquinas de estado complejas, la máquina de estado es la parte que mayor potencia utiliza.
- Este consumo se puede reducir implementando técnicas de clock gating.


### Clock Gating
- Los diseños basados en FSM en general esperan a un evento externo para cambiar de estado. En estos diseños, cuando ese evento no sucede, se verifica constantemente la entrada se realizan transiciones sobre un mismo estado en cada ciclo de clock. Esto disipa potencia de manera innecesaria.
- Analizando las especificaciones de la FSM, el diseñador puede apagar la FSM cuando se encuentra en un lazo continuo de transición en el mismo estado. Esto requiere detener el clock al aplicar una compuerta con la salida de una lógica de detección de lazo sobre un mismo estado (self-loop detection logic).

![[Pasted image 20240305102956.png]]


- En la figura anterior, el registro L en el diseño se utiliza para bloqueo de glitches en la señal de salida debida a la lógica de gating fG. La función fG implementa la lógica para determinar si la máquina se encuentra en un lazo recursivo sobre su mismo estado. Esta lógica puede ser diseñada para actuar en un caso con mayor probabilidad de quedar en un self-loop. Esto requiere un conocimiento de la estadística de transiciones de la FSM implementada.
- En el caso de las FPGA se han desarrollado técnicas de clock gating muy efectivas. Las FPGA tienen redes de clocks dedicadas para llevar el clock a todos los bloques con skew y jitter bajos. Por ejemplo en Xilinx Virtex 5 se tienen bloques embebidos como RAM, DSP48 y IOs, pero para configurar los bloques básicos existen los CLSBs (Configurable Logic Blocks).
- Cada CLB consiste de dos partes, cada parte contiene cuatro LUTs de 6 entradas y cuatro filp-flops. La FPGA tiene 32 buffers de clock globales (BUFGCEs) para soportar esta cantidad de clocks generados internamente o externamente. La FPGA se divide en múltiples regiones de clocks.

![[Pasted image 20240305103007.png]]
- Para reducir potencia si no tenemos registros a la entrada y se dificulta aplicar clock gating ya que lo esta entrada lo mismo modificara el data-path. Para este caso podemos aplicar compuerta AND para cada entrdad de dato, de esta manera evitamos las transiciones en el data-path

### Descomposicion de FSM
- Esta técnica propone particionar la FSM en múltiples sub-FSMs de manera que la máquina de estados permanezca apagada en la mayoría de las sub-FSM por un período de tiempo considerable.
- En el mejor caso esto lleva a que solo es necesario clocking de una de las sub-FSM para un ciclo de clock determinado. Deshabilitar los árboles de clocks para el resto de las sub-FSM por medio de clock gating puede reducir significativamente el consumo.
- El ejemplo ilustra el agrupamiento de una FSM en sub-FSM utilizando un método gráfico de particionamiento.
- La técnica utiliza la probabilidad de transiciones de estados para unir un grupo de nodos que se encuentran relacionados entre sí hacia un sub-FSM individual. Considere una FSM dividida en M particiones de sub-FSM cada una con estados S0,S1,…,SM-1. Para codificar de manera sencilla, el numero de bits asignados para cada registro de estado de cada sub-FSM es:
$$max[log_2S_0,log_2S_1,...,log_2S{M-1}]$$
- En algunos casos las FSM son jerárquicas en su algoritmo, lo cual permite particionar de manera óptima la FSM para reducir potencia. En este caso el algoritmo se particiona en niveles, entonces al efectuarse transiciones desde un nivel más alto a uno más bajo, el resto de las sub-FSM no serán utilizadas en esa trama o buffer de datos.
![[Pasted image 20240305103927.png]]