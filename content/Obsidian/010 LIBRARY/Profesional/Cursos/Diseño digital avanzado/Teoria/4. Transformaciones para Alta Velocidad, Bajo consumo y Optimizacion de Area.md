
## Contenido
- [[Pipelining]] and [[5. Retiming]].
	- Conceptos.
- Métodos: de corte o por el teorema de la transferencia de retardos.
- Aplicación a sistemas con y sin realimentación.
- Retiming en herramientas de síntesis.
- Minimización del numero de registros y camino crítico.
- Descomposición de Shannon.
- C-Slow Retiming.
- Plegado y desplegado (Unfolding y Folding) de arquitecturas.
- Consideraciones sobre la velocidad de muestreo.
- Técnicas para maximizar uso de arboles de compresión, uso efectivo de recursos de FPGAs.
- Técnicas de plegado aplicadas a estructuras regulares: filtros y FFTs.

## Tipos de sistemas
### Introduccion
- Los sistemas de procesamiento de señal pueden clasificarse como Feedforward o Feedback.
- En los sistemas Feedforward los datos fluyen desde la entrada a la salida sin presencia de lazos de realimentación. (ejemplos: filtros FIR, FFT)
	- Las optimizaciones de camino crítico pueden lograrse agregando etapas de pipelining en el diseño de hardware.
	- Un camino crítico que atraviesa una nube combinatoria en un sistema feedforward puede ser roto por la adición de registros pipeline.
- Sistemas de tipo recursivo o realimentados (feedback).
	- La ecuación en diferencia relaciona muestras anteriores de la salida con valores actuales de las muestras de entradas y salidas. (Ejemplos: Filtros IIR, sistemas recuperación de sincronismo y frecuencia en receptores de comunicación).
	- Debido a que se requieren muestras anteriores de la salida en el procesamiento, agregar registros para mejorar el timing no es una opción implementable de forma directa en el diseño.
- En un sistema de tipo feedforward, un camino critico a través de una etapa combinacional puede ser "cortado", agregando registros de pipeline. Si se agregan L registros de pipeline la función de transferencia del sistema se multiplica por $z^L$.
- En los sistemas realimentados la incorporación de retardos modifica la función de transferencia y resulta en el cambio de orden de la ecuación en diferencias.
![[Pasted image 20240222100328.png]]

### Sistemas Feedforward
Se pasa de un gráfico G a uno con pipelines Gr , cuyas funciones de transferencia, solo difieren en un retardo puro $z^L$ siendo L el número de etapas de pipeline agregadas
Se debe tener cuidad de mantener la coherencia entre los paths y considerar la latencia extra en el sistema.
![[Pasted image 20240222104444.png]]

#### Ejemplos de analisis interesantes

##### Analisis Area-Tiempo: Pipeline
![[Pasted image 20240222110458.png]]
- A la hora de analizar si colocamos los registros por el cutset 1 o cut set 2, debemos analizar el area y tiempo utilizado
	- Si lo hacemos por el cutset 1 usaremos 5 registros y nuestro camino critico se reducira a 1Tm+2Ts
	- Si lo hacemos por el cutset 2 usaremos 2 registros y nuestro camino critico se reduciria a 4Ts
		- Considerando 2Ts=1Tm, los tiempos son iguales
	- Por lo tanto combiene aplicar el cut set 2
	- Tambien debemos hacer un analisis del tiempo de multiplicacion.
		- Ya que si son constantes pqueñas y con muchos ceros, los productos pueden demorar lo mismo que las sumas, entonces tendria mas sentido el corte horizontal

##### Analisis funcionamiento: Retiming
![[Pasted image 20240222110929.png]]
- Si realizamos todos los cutset verticales para mover los registros, deberiamos modificar el orden en que se multiplican por el coeficiente para mantener el funcionamiento del filtro.
	- Osea, primero se debe hacer el producto por h0 y no guardarse en registros, por lo tanto hay que transporner el diagrama
	- O tambien podemos invertir el orden de los coeficiente

##### Analisis de coherencia de funcionamiento: Pipeline
![[Pasted image 20240222111429.png]]
- En este caso, si aplicamos solo 1 registro en el medio, tendremos dividido en 2 el sistema pero tendriamos operaciones sin coherencia
- Para mantener la coherencia debemos poner registros en las entradas y salida

##### Skew Buffer: Analisis de coherencia de funcionamiento a nivel extremo: Pipeline
![[Pasted image 20240222111638.png]]
- Tambien se puede ver como un uso particular del teorema de transferencia de registros.
- Debemos colocar todos los registros en las entradas y luego moverlos por los bloques

##### Pipeline a muy bajo nivel para optimizar multiplicacion y suma en su estructura
![[Pasted image 20240222113647.png]]
- En este caso se aplica el pipeline a lineas intermedias del producto y suma del filtro fir para hacer mas rapido el sistema
![[Pasted image 20240222115542.png]]


### Sistemas feedback
#### Conceptos basicos
##### Periodo de muestro vs Periodo de iteraccion
- Un sistema realimentado procesa una muestra de salida basándose en muestras anteriores de la salida y muestras actuales y anteriores de la entrada.
- Para este tipo de sistemas la *iteración* se define como la *ejecución de todas las operaciones* en el algoritmo requeridas para obtener una muestra de salida.
- El *período de iteración es el tiempo requerido para la ejecución de una iteración* del algoritmo.
- En los sistemas síncronos, el sistema debe completar la ejecución de iteración actual antes de que se requiera la siguiente muestra de entrada. Esto implica un límite superior en el período de iteración para que sea menor o igual a la tasa de muestreo del dato de entrada.
**Ejemplo**
- Sea un sistema IIR implementando la siguiente ecuación en diferencias:
$$y[n]=a\cdot y[n-1]+x[n]$$
- El algoritmo necesita ejecutar una multiplicación y una suma para entregar una muestra de salida en una iteración.
- Si el tiempo de ejecución del multiplicador y el sumador son $T_m$ y $T_a$ respectivamente, el período de iteración para el ejemplo es $T_m +T_a$. Con respecto al período de muestreo del dato de entrada $T_s$, se debe satisfacer $T_m +T_a < T_s$.
![[Pasted image 20240222122416.png]]
##### Lazo y relacion del lazo
Un lazo se define como el camino directo que comienza y termina en el mismo nodo.
La relación de lazo del lazo $LB_i$ esta definida por $T_i/D_i$ , Donde Ti es el tiempo de procesamiento del lazo(componentes) y Di es el número de retardos(registros) en el lazo.
##### Lazo critico y relacion de iteracion
Un lazo crítico en un DFG se define como el lazo con mayor relación de lazo. El período de iteración del lazo crítico se denomina período de relación de iteración IPB (Iteration Period Bound). Matemáticamente se describe por: $$IBP=MAX_{all-L_i}[T_
i/D_i]$$
##### Camino crítico y retardo del camino crítico
- El camino crítico del un DFG se define como el camino con el mayor tiempo de retardo de procesamiento entre todos los caminos que no contienen registros. El tiempo de procesamiento en ese camino se denomina retardo del camino crítico de un DFG.
- El camino crítico tiene gran importancia en el diseño digital ya que el período de clock y la posibilidad de disminuirlo se encuentra vinculado al retardo en el camino crítico. Un objetivo importante en el diseño es disminuir el retardo del camino crítico. Para esto se emplean técnicas como la selección de bloques de sumadores, multiplicadores y barrel shifters de alto desempeño en el procesamiento así como técnicas de retiming y transformaciones.
- Para los diseños sin realimentación los registros pueden reducir el camino crítico. En el caso de los sistemas con realimentación, la utilización de pipelining no se puede emplear de forma tan directa, pero se puede hacer uso del retiming para reducir el retardo del camino crítico. El IPB en estos diseños es el mejor tiempo que se puede obtener utilizando retiming sin generar trasformaciones de pipelining complejas.

#### Retiming en sistemas feedback
- Se puede usar la descomposicion de shannon para hacer uso retiming
- Tambien se puede aplicar retiming haciendo un analisis con el IPB, ya que este nos da el tiempo minimo al cual se podria llegar en cada lazo nuestro camino critico

##### Ejemplo para llevar el camino critico al IPB
![[Pasted image 20240222123711.png]]
- Retming aplicado al ejemplo en (a) el camino crítico se redujo a 4 unidades de tiempo para un IPB de 3.5 unidades de tiempo. (b) Se realiza un retiming más fino para obtener un camino crítico con retardo de 3.5 unidades de tiempo equivalente al IPB.

##### Ejemplo de aplicacion del metodo de shannon
![[Pasted image 20240222124045.png]]

##### Ejemplo de aplicacion del metodo de corte
![[Pasted image 20240222124056.png]]


##  C-slow Retiming
- La técnica de C-Slow retiming remplaza cada registro en el flujo de datos con registros C.
- Estos pueden ser desplazados para reducir el camino crítico. El diseño resultante puede operar en C tramas distintas de datos.
- El uso óptimo de diseño C-slow requiere el multiplexado de C tramas de datos en la entrada y el respectivo demultiplexado de estas tramas en la salida.
- La técnica requiere C tramas de datos de entrada o emplear C -1 nulos luego de cada entrada valida al DFG.
- De esta forma el throughput efectivo no se ve afectado por la técnica C-slow, pero provee una forma efectiva para implementar el paralelismo sin agregar lógica combinacional redundante ya que solo los registros requieren ser replicados.
**Ejemplo**
![[Pasted image 20240222124614.png]]
![[Pasted image 20240222124622.png]]

### Aplicacion tecnica C-slow
- La técnica de C-slow funciona muy bien para bloques de procesamiento de algoritmos. Una cantidad C de bloques de una misma trama de datos pueden ser procesadas por una arquitectura C-slow.
- Un ejemplo es el cifrado AES (Advanced Encryption Standard) donde se encriptan bloques de 128 bits. Reemplazando cada registro en una arquitectura AES, con C registros, el diseño puede encriptar simultáneamente C bloques de datos.
- Debido a que las FPGA contienen gran cantidad de registros, la técnica C-slow puede utilizar de forma efectiva estos registros para procesar múltiples tramas de dato. En muchos diseños la frecuencia del reloj es fijada a un valor pre-definido, y la técnica C-slow resulta muy útil para lograr la frecuencia fija del reloj
- El retiming con C-slow también puede convertir arquitecturas en paralelo a arquitecturas multiplexadas en el tiempo donde se pueden mapear C particiones en una FPGA re-configurable en tiempo de ejecución. En un diseño C-slow, siendo la entrada válida en cada Cth clock, por medio del retiming se pueden mover registros para dividir el diseño en particiones donde las particiones pueden ser creadas de manera óptima para dividir equitativamente la lógica en C partes.
- Un diseño multiplexado en el tiempo requiere menor área y resulta ideal para lógica reconfigurable en tiempo de ejecución.
- Luego de aplicar la técnica se mapea el DFG a lógica multiplexada en el tiempo donde el dato es conectado al diseño en un ciclo de clock y el resultado se almacena en los registros, estos valores son entradas al diseño que reutiliza la misma lógica computacional, reduciendo área.

### Ejemplo de aplicacion
En la figura se muestra el concepto básico. El DFG de (a) tiene 2-slowed como muestra (b). Se asume que los tres nodos implementan alguna lógica combinacional que se repite dos veces en el diseño. Se efectúa retiming para ubicar los registros de forma óptima mientras se crean dos partes iguales. El resultado se muestra en (c).
![[Pasted image 20240222125252.png]]



## Arquitecturas Folding y Unfolding
El tipo de estrutuctura que usamos depende de las relaciones entre las frecuencia de muestreo y la frecuencia de procesamiento
- Frecuecia de muestro=Frecuencia de procesamiento → Serie
- Frecuecia de muestro>Frecuencia de procesamiento → Paralelo(Unfolding)
- Frecuecia de muestro<Frecuencia de procesamiento → Reurilizar (Folding)
### Introducción
- Las principales decisiones en el diseño digital se basan en la relación entre la frecuencia de muestreo y la frecuencia del circuito.
- La frecuencia de muestreo es específica de una aplicación y se deriva del criterio de muestreo de Nyquist o de la restricción de muestreo del ancho de banda.
- La frecuencia del circuito, por otro lado, depende principalmente del diseño y la tecnología utilizada para la implementación.
.El tipo de estrutuctura que usamos depende de las relaciones entre las frecuencia de muestreo y la frecuencia de procesamiento
- Frecuecia de muestro=Frecuencia de procesamiento → Serie
- Frecuecia de muestro>Frecuencia de procesamiento → Paralelo(Unfolding)
- Frecuecia de muestro<Frecuencia de procesamiento → Reurilizar (Folding)
En los diseños forward, una transformación unfolding hace posible el procesamiento paralelo, así como también el pipeling es otra opción para mejorar el timing. En diseños realimentados, la transformación unfolding no da como resultado un verdadero procesamiento paralelo ya que la velocidad del reloj del circuito necesita reducirse (no mejora el IPB).
- El único beneficio de la transformación unfolding es que el circuito se puede ejecutar a un reloj más lento ya que cada registro es más lento por el factor de despliegue.

- El intercambio de área-potencia debe estudiarse cuidadosamente si el despliegue se realiza con el objetivo de reducir la potencia.
- La transformación unfolding es muy efectiva si hay más registros en el DFG original que se puedan aplicar retiming de manera efectiva para reducir el camino crítica del diseño.
- Es importante señalar que, en muchas instancias de diseño, la opción de elección de pipeling y retiming da como resultado un área menor que un diseño unfolding.

### Teorema de muestro
- Para un diseño que procesa la señal discreta muestra por muestra, el reloj de muestreo también se utiliza como reloj de circuito para el diseño del hardware.
- La frecuencia de muestreo impone restricciones estrictas incluso si los datos muestreados se almacenan primero en un buffer.
- El diseñador diseña el HW para procesar este buffer de datos antes de que el siguiente buffer esté listo para el procesamiento.
- Si el reloj de muestreo es más rápido que un reloj de circuito, entonces el diseñador necesita explorar opciones de procesamiento paralelo o pipeling.


### Loop unrolling
- En el contexto del software, la transformación unfolding es el proceso de "desenrollar" un ciclo, de manera que varias iteraciones del ciclo se ejecutan en una iteración desenrollada.
- Por esta razón, desplegar también se llama ’desenrollar bucle’.
- Para el diseño de hardware, el despliegue corresponde a la aplicación de una transformación matemática en un gráfico de flujo de datos para replicar su funcionalidad para el cálculo de múltiples muestras de salida para muestras de entrada múltiples relevantes dadas.
- El concepto también puede utilizarse al realizar una asignación SW a HW de una aplicación escrita en un lenguaje de alto nivel.
- El despliegue de bucles brinda más flexibilidad al diseñador de HW para optimizar el mapeo.

### Transformación Unfolding
Cualquier DFG puede desplegarse mediante un factor desplegable J usando los dos pasos siguientes
-  Para desplegar el gráfico, cada nodo U del DFG original se replica J veces como $U_0, … ,U_{J-1}$ en el DFG desplegado.
- Para dos nodos conectados U y V en el DFG original con retardos w, dibuje J bordes de modo que cada borde $j(= 0, ... ,J-1)$ conecte los nodos $U_j$ a los nodos $V_{(j +w)\%J}$ con $[(j +w)/J]$ retardos, donde % y $[.]$ son el resto y la operación floor.
![[Pasted image 20240228104106.png]]

Para el diseño de hardware de las DFG forward, se pueden explorar las opciones de arquitectura efectivas utilizando la transformación desplegable.
El diseñador puede diseñar una unidad computacional que consta de dos multiplicadores CSD y dos sumadores como una unidad computacional.
Esta unidad se puede implementar como un árbol de compresión que produce una suma y un acarreo.
- La cantidad de registros en ambos sistemas se debe mantener constante
![[Pasted image 20240228104118.png]]


#### Diseños Realimentados
- Una transformación desplegada no mejora el tiempo; más bien, resulta en un aumento en la demora del camino crítico y, para diseños feedback, un aumento en IPB por el factor desplegable J.
- Este aumento se debe a que, aunque todos los nodos computacionales se replican J veces, aún el número de registros en el DFG desplegado sigue siendo el mismo.
- Para diseños realimentados, el despliegue puede ser efectivo para instancias de diseño donde hay abundantes registros algorítmicos para los nodos combinatorios en el diseño.
- En estos diseños, el desplegado seguido de retiming proporciona flexibilidad para colocar estos registros algorítmicos en el diseño desplegado mientras se optimiza el tiempo.

![[Pasted image 20240228104142.png]]


### Transformación Folding
- El plegado es una técnica matemática para encontrar una arquitectura multiplexada en el tiempo y un cronograma de mapeo de múltiples operaciones de un gráfico de flujo de datos en menos unidades computacionales de hardware.
- El factor de plegado se define como la cantidad máxima de operaciones en un DFG mapeado en una unidad computacional compartida.
- Un conjunto plegable o planificador plegable es la secuencia de operaciones de un DFG mapeado en una única unidad computacional.
- La transformación de plegado tiene dos partes. La primera parte trata de encontrar un factor de plegamiento y la segunda el cronograma para mapear diferentes operaciones del DFG en unidades computacionales en el DFG plegado.
- El factor de plegado óptimo se calcula como $N = [fc/fs]$ donde fc y fs son frecuencias de reloj de circuito y de muestreo.
- La transformación plegable por un factor de N introduce latencia en el sistema.
- El intercambio de una unidad computacional por diferentes operaciones también requiere un controlador que programe estas operaciones en intervalos de tiempo (máquina de estados finitos (FSM)).
![[Pasted image 20240228104204.png]]



