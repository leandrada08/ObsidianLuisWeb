## Concepto
- A que nos referimos con problemas de timing?
	- Cuando el periodo de reloj es menor a nuestro tiempo de propagacion por nuestro sistema combinacional
	- Como lo solucionamos?
	- Pipeline,Retiming o Paralelimos
- Desde la perspectiva HW, pipelining y procesamiento en paralelo son dos métodos que ayudan a lograr un alto throughput.
- Pipeline: Corta el camino critico con registros
	- De esta manera cortamos el tiempo
	- Pero aumentamos el area
	- En general, en un sistema con L niveles de etapas de pipelines, el número de elementos de retardo en cualquier camino de entrada a salida es L-1 veces mayor que en el sistema original.
		- Incorporar registros de pipelining reduce el camino crítico pero incrementa la latencia del sistema y la salida $y[n]$ corresponde al procesamiento de una muestra de entrada anterior.
	- Se podria ver como que el pipeline nos esta permitiendo multiplexar en el tiempo.
	- Agregar registros al camino crítico que se desea mejorar y los caminos paralelos que deban compensar estos retardos, también aumentan el área y la carga del árbol de clocks. Se deben agregar pipelines únicamente cuando sea necesario.
- Retiming: Trata de reubicar los registros ya existenten para mejorar caracteristicas del tiempo
	- Esto se puede hacer manualmente, cambiando nuestro codigo
		- La ventaja es que se puede comparar y analizar cada operacion internamente y sacar una conclusion
	- Tambien se puede hacer de manera automatica, este lo hace la herramienta
		- La ventaja es que lo pone en un lugar optimo
		- La desventaja es que no sabemos donde
	- Ventajas
		-  Reducir el camino crítico
		- Reducir el número de registros
		- Reducir potencia
		- Aumentar la testeabilidad

## Cut-Set Retiming
- Este técnica involucra el retiming de un gráfico de flujo de datos aplicando una línea de corte.
- Un corte válido se realiza en un conjunto de lazos backward y forward en un DFG cortados por una línea de forma que si estos elementos se eliminaran del gráfico, éste quedaría inconexo. Osea, quedarian 2 diagramas independientes
- El retiming implica transferir una cantidad de retardos desde los lazos con la misma dirección sobre la línea de corte del DFG a todos los lazos de direcciones opuestas sobre la misma línea.
	- Basicamente tenemos que sacar los registros en las lineas que estan entrando a la linea de corte y sacarlos por las lineas que salen, para agregar 1 registros en cada camino que sale, tengo que sacar 1 registros de cada camino que entra
- Estas transferencias de delays no alteran la función de transferencia del DFG.
![[Pasted image 20240222100756.png]]

## Transferencia de retardos
- El teorema indica que se pueden transferir N registros de cada flecha entrante en un nodo de un DFG a todas las flechas salientes del mismo nodo o viceversa, sin afectar a la función original.
	- Esto es bidireccional, tambien se puede hacer a la viceversa.
	- Se puede considerar el cut-set un caso particular de este metodo
- Caso particular del método de corte en el cual la linea se ubica para separar un nodo en el DFG.

![[Pasted image 20240222100822.png]]



## Retiming automatico
- La mayoría de las herramientas de diseño digital tienen soporte para retiming automático o semi-automático.
- La técnica retiming se aplica a nivel de síntesis.
- Esta opción no mueve registros en los sistemas feedback.
- Una forma de utilizar esta técnica es colocar todos los registros en el nodos de entrada y dejar que la herramienta lo distribuya sobre los caminos críticos.
- En un VLSI podemos considerar que movemos el registro a otra posición mientras que en una FPGA estaríamos seleccionando un registro en otra posición del hardware dedicado.
- La técnica del retiming suele utilizarse para minimizar el número de registros en el diseño.
- Para gráficos más complejos, la minimización de registros se modela como un problema de optimización. El problema se resuelve utilizando algoritmos incrementales en los cuales se mueven registros de manera recursiva a los vértices en donde se minimiza el número de registros y el gráfico satisface los requerimientos de tiempo


![[Pasted image 20240222115801.png]]


## Descomposicion de Shannon
> La descomposición de Shannon es una transformación que permite extender el alcance del retiming. Separa una función multivariable booleana en una combinación de dos funciones booleanas equivalentes:
$f(x_0,x_1, ...,x_{N-1}) = x_0f (0,x_1, ...,x_{N-1})+x_0f (1,x_1, ...,x_{N-1})$

- La técnica identifica una señal con un retardo en la llegada al bloque y duplica la lógica del bloque con $x_0$ asignando valores de 0 y 1. Luego, un multiplexor de 2:1 selecciona la salida correcta de la lógica duplicada.
- El CSA (Carry Select Adder) es un ejemplo de descomposición de Shannon. El camino del carry es la parte más lenta en el RCA. La lógica en cada bloque se duplica con un carry fijo en 0 y en 1 y el valor correcto se selecciona con un multiplexor de 2:1.
- De manera genérica, la descomposición de Shannon puede funcionar de forma jerárquica en lógica con múltiples entradas, como en un CSA (Carry Select Adder) jerárquico o el sumador condicional.
![[Pasted image 20240222115841.png]]
Diseño con una entrada más lenta $x_0$ al nodo $f_0$. La dependencia de $f_0$ con $x_0$ se remueve utilizando descomposición de Shannon que duplica la lógica en $f_0$ para los dos posibles valores de entrada de $x_0$, un multiplexor selecciona la salida correcta. Los registros en esta descomposición pueden ser trasladados de forma efectiva.


