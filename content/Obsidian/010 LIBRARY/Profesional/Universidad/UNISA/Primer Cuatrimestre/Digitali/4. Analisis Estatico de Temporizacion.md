
# 4. Análisis Estatico de Temporizaron
## Introducción

- **Introduzione**
	- Cosa è STA?
- **Tempi caratteristico**
	- Quale sono i tempi caratteristico degli sistemi?
		- Describe ognuno: $t_{setup},t_{hold},t_{q},t_{c,min},t_{c,max}$
- **Constraints di Tempo**
	- Come è il constraint di tempo per il tempo di setup?
	- Come è il constraint di tempo per il tempo di hold?
		- Come uno dipende del altro?
- **Static Timing Analysis**
	- Come si define un Timing path?
		- Quale sono i tempi dentro a un Timing path?
			- Come si definisce il net delay e il path delay?
	- Quale sono i diversi tipi di Timing path?
	- Quale sono le passi del STA?
- **STA in vivado**
	- Come fai vivado per calcolare il tempo di hold?
	- Come fai vivado per calcolare il tempo di setup?
	- Perche si dice che con questo analisis gia basta per sapere si c'è un problema?








# Italiano

## Introduzione
### Cosa é STA 
L'*analisi statica del timing (Static Timing Analysis - STA)* è una metodologia utilizzata per validare il timing o temporizzazione dei sistemi digitali sincroni. Permette di ottenere l'"involucro temporale" (time enclosure) di tali sistemi.
La STA *permette di validare che il sistema sincrono rispetti le specifiche di temporizzazione*, tenendo conto di:
- *Ritardi nei blocchi combinatori*
- *Tempo di setup e hold dei FF*
- *Frequenza dell'orologio*
- *Vincoli imposti dal progettista*
Garantendo il rispetto delle limitazioni temporali, il sistema sarà affidabile e privo di errori di sincronismo.
- Calcola tutti i ritardi di ingresso-uscita e tra percorsi interni associati a registri per rilevare violazioni di timing (setup, hold, ecc.) in determinate condizioni specifiche.
- È un processo molto più rapido e robusto rispetto alla verifica basata su simulazioni usando vettori (GLS).

### Sistemi Sincroni
Nel 99.99% dei casi, i sistemi di elaborazione digitale o misti sono sincroni. Cioè, il ritmo di operazione è dettato da un segnale periodico noto come **orologio (clock)**, che costituisce la base dei tempi del sistema.
Per mantenere il sincronismo, il segnale di clock deve essere distribuito e arrivare a tutti i blocchi (sincronismo fisico).
Uno schema tipico di un sistema sincrono sarebbe:
![[Pasted image 20231121201356.png|500]]
#### Vantaggi dei Sistemi Sincroni
Introdurre FF e latch implica maggiore complessità e consuma più risorse. **Quindi, perché utilizzare sistemi sincroni?**
I principali vantaggi sono:
- **Robustezza e affidabilità**: Si evitano problemi di temporizzazione (glitches) e segnali spurii, che dipendono da fattori difficili da prevedere come temperatura o tensione.
- **Sincronismo logico**: Gli FF permettono di distinguere chiaramente tra stati successivi nelle macchine a stati finiti.


## Tempi caratteristico: STA  
![[Pasted image 20240206183241.png]]
Prima di enunciare i vincoli di temporizzazione o Timing Constraints, è utile ricapitolare i tempi caratteristici di Latch e Flip-Flop (FF). In generale, si possono definire 4 tempi principali:
- **Tempo di setup (tsu)**: Il tempo minimo prima del quale il dato deve essere stabile per essere catturato adeguatamente sul fronte attivo del clock.
- **Tempo di hold (thold)**: Il tempo minimo durante il quale il dato deve rimanere stabile dopo il fronte attivo del clock per essere catturato adeguatamente.
- **Tempo clock-to-output (tc-q)**: Ritardo dal fronte del clock fino a quando l'uscita è valida. Bisogna aspettare un ciclo di clock completo.
- **Tempo data-to-output (td-q)**: Ritardo dall'ingresso dei dati fino all'uscita.
- **Errore di timing:** Violazioni del tempo di setup o hold.
	- Conseguenze degli errori di timing:
		- Incertezza nel tempo di propagazione dei dati
		- Perdita di dati
		- Metastabilità

### Tempi nei componenti di memoria
#### Latch
Nel caso dei latch (livello), interessano i 4 tempi. Tuttavia, a causa del loro funzionamento sensibile al livello, sono trasparenti durante un semi-periodo del clock. Pertanto, tipicamente non si usano per il sincronismo.
![[Pasted image 20231121201918.png]]

#### FFs tempi 
D'altra parte, negli FFs (fronte), essendo edge-triggered, non interessa il td-q poiché l'uscita cambia solo con il fronte attivo del clock (eccetto il ritardo tc-q).
![[Pasted image 20231121201937.png]]


## Constraints di Tempo
I timing constraints sono le restrizioni di tempo. Insieme ai ritardi della logica combinatoria, questi parametri temporali determinano certe restrizioni che devono essere rispettate:
![[Pasted image 20231121202600.png|500]]
![[Pasted image 20231121201937.png]]


### Restrizione di tempo di setup  #tarjeta-anki 
![[Pasted image 20231121202653.png|500]]
1. Una volta trascorso il $t_{c-q}$ (clock-to-output), la logica combinatoria può lavorare sull'ingresso corretto. Questo ingresso deve essere pronto durante il tempo di setup $t_{su}$ prima del fronte del clock. 
2. Pertanto, i fronti del clock rispettivi devono essere separati da un intervallo critico uguale a $t_{c-q}+t_{c-max}+t_{su}$. Ovviamente, non si può impostare esattamente uguale, perché questa stima non considera i ritardi di interconnessione (tclk1 e tclk2 sono segnali distinti).
Così, la restrizione di tempo di setup si traduce in:

$$
T ≥ t_{c-q} + t_{c,max} + t_s
$$
- **tc_max**: Ritardo massimo della logica combinatoria. Peggior caso possibile.

### Restrizione di tempo di hold 
![[Pasted image 20231121202701.png]]
1. Data una certa logica combinatoria, i dati iniziano a cambiare dopo *tc_min* e saranno validi e corretti dopo *tc_max*. Qui importa che cambino, non che siano corretti: se tc_min (tempo di contaminazione) è molto piccolo, bisogna aspettare thold per catturare il dato correttamente.
A livello di equazione:
$$ 
t_{c-q} + t_{c,min} ≥ t_h
$$
- **tc_min**: Ritardo minimo (tempo di contaminazione). Miglior caso possibile
### Conclusione
- La prima restrizione dipende dal periodo del clock, quindi può essere corretta variandolo (riducendo la frequenza).
- Inoltre, nota la presenza di tc_min e tc_max in entrambe le equazioni. È problematico che la logica sia molto veloce o molto lenta.
- Consideriamo il caso in cui la seconda restrizione è difficile da rispettare: i registri di spostamento hanno solo interconnessioni, idealmente tc_min=0 → tc-q > thold. Questo è un prerequisito su cui il progettista non interviene: dovrebbe intervenire chi ha progettato internamente l'FF per modificare tc-q.


## Static Timing Analysis
- Quando si progetta un sistema sincrono, specialmente al progettare e assemblare componenti, si dovrebbe valutare che le due restrizioni di temporizzazione siano rispettate per ogni banco di registri. 
	- Questo non è umanamente fattibile, poiché dovremmo tener conto di ogni registro e ogni combinazione possibile degli ingressi (nelle tecniche di canalizzazione, inoltre, i blocchi combinatori si frammentano ulteriormente per accelerare tutto).
- La **Static Timing Analysis** è un **metodo per determinare se un sistema rispetta i vincoli** temporali **evitando di fare la simulazione**.
	- Questa analisi tiene conto anche delle interconnessioni ed è valida finché gli ingressi rimangono costanti lungo tutto il percorso del sistema implementato. Quando il sistema soddisfa la STA, si può essere ragionevolmente sicuri di non avere problemi di alcun tipo (si dice che il sistema ha ottenuto l'"involucro temporale").
- Attraverso questo metodo di analisi, si evita di effettuare simulazioni e si ottengono i seguenti benefici:
	- Metodo di analisi molto più rapido rispetto alle simulazioni.
	- Non è richiesta la generazione di vettori di prova.
	- La correzione funzionale del sistema non viene verificata.

### Timing Path
- Prima di comprendere come Vivado implementa una STA, teniamo presente che un circuito generico si divide in diversi insiemi di "timing paths" (generalmente abbiamo REG-COMB-REG). *Con "timing path", ci riferiamo a un percorso punto a punto in un'architettura che può propagare i dati da un flip-flop/registro a un altro*.
- Ogni "timing path" è caratterizzato da:
	- **Start Point:** Può essere un pin di ingresso al sistema o un pin di un clock di ingresso a un flip-flop.
	- **End Point:** Può essere un pin di uscita o un pin di un dato di ingresso a un flip-flop.
Il circuito è diviso in insiemi di timing path, e si calcola il ritardo associato a ciascun path.
- Ogni path è verificato con i requisiti.
- *Ogni "timing path" è caratterizzato da un ritardo (path delay), che è la somma delle interconnessioni (net delay) e delle celle (cell delay) che compongono il percorso.*
![[Pasted image 20231122114148.png|500]]
##### Net Delay
- Il “Net Delay” si riferisce al tempo totale richiesto per caricare o scaricare le capacità parassite lungo un'interconnessione causata da:
	- La lunghezza dell'interconnessione
	- Il fanout
- La Net Delay e le capacità parassite sono tipicamente:
	- Back-Annotated tramite l'uso di uno strumento per l'estrazione delle capacità parassite
	- Stimate tramite tabelle fornite prima di fare il layout
##### Cell Delay
Si riferisce al ritardo di una cella. Il ritardo di una cella è determinato da:
- L'intervallo di transizione del segnale di ingresso (slew rate)
- Il carico totale visto dalla cella (fan out)


## Passi di STA 
Lo strumento divide in diverse parti l'analisi del timing.
Passi di STA:
1. Il progetto è diviso in distinti percorsi di timing (timing paths). Tipi:
	- *Ingresso a uscita (I2O):* In questo caso, c'è una connessione di ingresso a uscita senza alcun flip-flop, solo attraverso uno o più blocchi combinatori.
	- *Ingresso a registro (I2R):* Dati che fluiscono dal pin di ingresso verso un flip-flop situato a una distanza sconosciuta, dove arrivano sia il dato di ingresso che il clock, che di solito è fornito da un buffer (per esempio, BUFG in FPGA).
	- *Registro a registro (R2R):* È lo schema tipico RTL del tipo REG-COMB-REG di cui si sono già trattati i vincoli di temporizzazione.
	- *Registro a uscita (R2O):* Dati che fluiscono dall'uscita del flip-flop verso un blocco combinatorio situato a una distanza sconosciuta con un certo ritardo.
2. Si calcola il ritardo di propagazione di tutti i segnali lungo ogni percorso.
3. Si verificano violazioni nei vincoli di timing all'interno del progetto e nelle interfacce di ingresso/uscita.
![[Pasted image 20240206182705.png|500]]
#### Calcolo del tempo R2R
![[Pasted image 20240206182740.png|500]]
- Si calcola il tempo dall'ingresso fino allo start point e inoltre dallo start point fino all'end point.
	- Gli end point sono sempre associati tra l'ingresso di un registro e l'ingresso del successivo.
- La somma di questi 2 tempi non deve essere maggiore del tempo Destination Clock Path dell'immagine.
### Calcolo del tempo di setup dello strumento
![[Pasted image 20240206182312.png|800]]
### Calcolo del tempo di hold dello strumento
![[Pasted image 20240206182314.png|800]]
### Conclusione
![[Pasted image 20240206182316.png|800]]



## STA in Vivado
- *Vivado esegue l'analisi del tempo statico (STA) e fornisce rapporti in cui si ottengono "slack"* negativi in una serie di percorsi. Questi "slack" devono poi essere interpretati in un certo modo dal progettista.
![[Pasted image 20231122135824.png]]
- Per attivare questa STA, il sistema deve conoscere esplicitamente i valori dei vincoli di temporizzazione e, per farlo, è necessario informarlo sul periodo del clock che vogliamo usare.
	- In questo modo, ha un tempo per confrontare con i ritardi massimi delle linee.
	- Una volta fatto questo, il sistema crea un grafo di ritardi che verrà percorso quattro volte: due volte per calcolare e verificare il vincolo di tempo di "setup" e altre due per calcolare e verificare il vincolo di tempo di "hold".
![[Pasted image 20231122135958.png]]


### Tempo di hold VIVADO 
- Analizziamo come Vivado verifica il rispetto del vincolo di tempo relativo al tempo di "hold" (il ragionamento è simile per il vincolo di tempo di "setup").
- Una volta che arrivano gli ingressi, è necessario valutare tutti i percorsi più veloci per arrivare all'uscita. Fatto questo, si verifica se i tempi richiesti sono maggiori o minori di quanto specificato. Quando ci sono diverse frecce che convergono in un nodo, il tempo è dato dalla somma minima dei contributi: questi sono i tempi di contaminazione e, quindi, il peggior caso è quando questo tempo è minimo.
![[Pasted image 20231122140419.png]]
- Il sistema ha tempi di riferimento. Questi sono i tempi minimi con cui devono arrivare gli ingressi affinché si rispetti il vincolo sui tempi di "hold".
- I valori 200-180-200 nella figura precedente sono i tempi minimi richiesti. Retrocedendo, il sistema determina i limiti temporali in altri tempi. Questi tempi possono essere negativi.
- Poi, si propagano i tempi minimi richiesti e si confrontano con i risultati precedenti.
![[Pasted image 20231122141253.png]]
- In questo caso, lo "slack" si chiama "early" perché si calcola nel tempo di contaminazione, cioè il più veloce. Vivado utilizza una terminologia diversa.
	- Quando i risultati sono positivi, significa che va bene perché la differenza minima tra i tempi è positiva.
	- Quando si ottiene un numero negativo, significa che il segnale è troppo veloce, violando così i tempi di "hold".
		- Dato che non si può variare tc-q (il tempo di contaminazione), è necessario regolare il tempo di contaminazione, rallentando il percorso e aggiungendo ritardi.
		- Questo si può ottenere aggiungendo porte logiche non molto grandi, come OR e AND, per rallentare quel percorso.
![[Pasted image 20231122142437.png]]



### Tempo di setup VIVADO
- Con il vincolo di timing del tempo di setup, l'unica modifica principale risiede nel fatto che si sostituisce il tempo di contaminazione (min) con il ritardo critico (max), e si prende il minimo retrocedendo.
- I tempi che devono essere rispettati potrebbero essere diversi, poiché sono i tempi massimi richiesti per rispettare il primo vincolo di tempo di setup. In caso di violazione del tempo di setup, la prima regolazione deve essere aumentare il periodo del clock. È importante notare che l'offset in ingresso e uscita, se specificato, rende la STA più precisa. Si può anche specificare il jitter, ma questo verrà discusso più avanti.
![[Pasted image 20231122142632.png]]



## Osservazioni 
Nella sintesi con STA, spesso si possono trovare rapporti di errori riguardanti la "time enclosure" perché il blocco combinatorio è grande. Tuttavia, a volte, queste violazioni non hanno senso. Ad esempio, un moltiplicatore non si userebbe mai da solo; sarebbe connesso tra altri blocchi che compongono il sistema. Il sistema STA permette di definire "false paths" che verranno ignorati nella STA.
![[Pasted image 20231122142706.png]]
Inoltre, ci possono essere percorsi che richiedono più cicli di clock, e invece di T, si ha NT (come nel caso del moltiplicatore). Questi percorsi si chiamano "multi-cycle paths".
![[Pasted image 20231122142701.png]]
![[Pasted image 20240719200910.png|600]]
In molti casi, ci sono sistemi che operano a frequenze di clock diverse, e queste regioni sono chiamate "clock domains". I problemi sorgono nell'interfaccia tra questi domini di clock.



### Risolvere problemi di timing
- Oltre a eseguire ottimizzazioni nell'architettura del progetto o modificare parametri dello stesso come il parallelismo o la frequenza di operazione, si possono applicare le seguenti tecniche per migliorare il timing di un progetto:
	- *Pipelining:* aggiungere registri per dividere percorsi critici nel progetto (aumentando la latenza).
	- *Retiming:* rilocazione dei registri del progetto per ridurre percorsi critici. Questo ci aiuta a non aggiungere latenza.
	- *Cloning:* replicazione di registri per ridurre il fanout e quindi migliorare il timing.
		- Bisogna applicare restrizioni per evitare che nella sintesi lo strumento ritorni al sistema originale.

# Español
## Introducción
El *análisis estático de temporización (Static Timing Analysis - STA)* es una metodología utilizada para validar el timing o temporización de los sistemas digitales síncronos. Permite obtener la "encapsulación temporal" (time enclosure) de dichos sistemas.
El STA *permite validar que el sistema síncrono cumpla con las especificaciones de temporización*, teniendo en cuenta:
- *Retardos en los bloques combinacionales*
- *Tiempo de setup y hold de los FF*
- *Frecuencia del reloj*
- *Restricciones impuestas por el diseñador*
Garantizando el cumplimiento de las limitaciones temporales, el sistema será confiable y libre de errores de sincronismo.
- Calcula todos los retardos de entrada-salida y entre caminos internos asociados a registros para detectar violaciones de timing (setup, hold, etc.) bajo ciertas condiciones determinadas.
- Es un proceso mucho más rápido y robusto que la verificación basada en simulaciones usando vectores (GLS).
### Sistemas Síncronos
En el 99.99% de los casos, los sistemas de procesamiento digital o mixto son síncronos. Es decir, el ritmo de operación viene dictado por una señal periódica conocida como **reloj (clock)**, que constituye la base de tiempos del sistema.
Para mantener el sincronismo, la señal de reloj debe ser distribuida y llegar a todos los bloques (sincronismo físico).
Un esquema típico de un sistema síncrono sería:

![[Pasted image 20231121201356.png|500]]

#### Ventajas de los Sistemas Síncronos
Introducir FF y latches implica mayor complejidad y consume más recursos. **Entonces, ¿por qué utilizar sistemas síncronos?**
Las principales ventajas son:
- **Robustez y fiabilidad**: Se evitan problemas de temporización (glitches) y señales espurias, que dependen de factores difíciles de predecir como temperatura o voltaje.
- **Sincronismo lógico**: Los FF permiten distinguir claramente entre estados sucesivos en las máquinas de estados finitos.


## Tiempos caracteristicos
![[Pasted image 20240206183241.png]]

Antes de enunciar las restricciones de temporización o Timing Constraints, es útil recapitular los tiempos característicos de Latches y Flip-Flops (FF). En general, se pueden definir 4 tiempos principales:
- **Tiempo de setup (tsu)**: El tiempo mínimo antes del cual el dato debe estar estable para ser capturado adecuadamente en el flanco activo de clock.
- **Tiempo de hold (thold)**: El tiempo mínimo durante el cual el dato debe permanecer estable luego del flanco activo de clock para ser capturado adecuadamente.
- **Tiempo clock-to-output (tc-q)**: retardo desde el flanco de reloj hasta que la salida es válida. Hay que esperar un ciclo de reloj completo.
- **Tiempo data-to-output (td-q)**: Retardo desde entrada de datos hasta salida.
- **Error de timing:** Violaciones del tiempo de setup o hold.
	- Consecuencias de errores de timing:
		- Incertidumbre en el tiempo de propagación de los datos
		- Perdida de datos
		- Mestaestabilidad

### Tiempos en componentes de almacenamiento
#### Latch
En el caso de los latches (nivel), interesan los 4 tiempos. Sin embargo, debido a su funcionamiento sensible a nivel, son transparentes durante un semi-período de reloj. Por ello, típicamente no se usan para sincronismo.
![[Pasted image 20231121201918.png]]

#### FFs
Por otro lado, en FFs (flanco), al ser edge-triggered, no interesa el td-q ya que la salida sólo cambia con el flanco activo de reloj (exceptuando el retardo tc-q).
![[Pasted image 20231121201937.png]]


## Constraints de Tiempo

Los timing constraints son las rescciones de tiempo. Junto con los retardos de la lógica combinacional, estos parámetros temporales determinan ciertas restricciones que se deben cumplir:
![[Pasted image 20231121202600.png|500]]
![[Pasted image 20231121201937.png]]
### Restricción de tiempo de setup 
![[Pasted image 20231121202653.png|500]]
1. Una vez transcurrido el $t_{c-q}$ (clock-to-output), la lógica combinacional puede trabajar sobre la entrada correcta. Esta entrada debe estar lista durante el tiempo de setup $t_{su}$ antes del flanco de reloj. 
2. Por lo tanto, los flancos de reloj respectivos deben estar separados por un intervalo crítico igual a $t_{c-q}+t_{c-max}+t_{su}$. Obviamente, no se puede poner exactamente igual, porque esta estimación no considera retardos de interconexión (tclk1 y tclk2 son señales distintas).

Así, la restricción de tiempo de setup se traduce en:

$$
T ≥ t_{c-q} + t_{c,max} + t_s
$$
- **tc_max**: Retardo máximo de la lógica combinacional. Peor caso posible.
### Restricción de tiempo de hold
![[Pasted image 20231121202701.png]]
1. Dada cierta lógica combinacional, los datos comienzan a cambiar después de *tc_min* y estarán válidos y correctos después de *tc_max*. Aquí importa que cambien, no que sean correctos: si tc_min (tiempo de contaminación) es muy pequeño, hay que esperar thold para capturar el dato correctamente.

A nivel de ecuación:
$$ 
t_{c-q} + t_{c,min} ≥ t_h
$$

- **tc_min**: Retardo mínimo (tiempo de contaminación). Mejor caso posible
### Conclusion
- La primera restricción depende del periodo de reloj, por lo que puede corregirse variándolo (reduciendo la frecuencia).
- Además, nota la presencia de tc_min y tc_max en ambas ecuaciones. Es problemático que la lógica sea muy rápida o muy lenta.
- Consideremos el caso donde la segunda restricción es difícil de cumplir: los registros de desplazamiento sólo tienen interconexiones, idealmente tc_min=0 → tc-q > thold. Esto es un prerrequisito sobre el que el diseñador no interviene: debería intervenir quien diseñó internamente el FF para modificar tc-q.



## Static Timing Analysis
- Cuando se diseña un sistema síncrono, especialmente al diseñar y ensamblar componentes, se debería evaluar que las dos restricciones de temporización se cumplan para cada banco de registros. 
	- Esto no es humanamente factible, ya que deberíamos tener en cuenta cada registro y cada combinación posible de las entradas (en técnicas de canalización, además, los bloques combinatorios se fragmentan aún más para acelerar todo). 

- El **Static Timing Analysis** es un **metodo per determinar si un sistema respetta los constrains** temporales **evitando de hacer la simulacion**
	- Este análisis también tiene en cuenta las interconexiones y es válido siempre que las entradas permanezcan constantes a lo largo de todo el camino del sistema implementado. Cuando el sistema satisface la STA, se puede estar razonablemente seguro de no tener problemas de ningún tipo (se dice que el sistema ha logrado la "time enclosure").
- A través de este método de análisis, se evita realizar simulaciones y se obtienen los siguientes beneficios:
	- Método de análisis mucho más rápido que las simulaciones.
	- No se requiere la generación de vectores de prueba.
	- La corrección funcional del sistema no se verifica.
### Timing  Path
- Antes de comprender cómo Vivado implementa una STA, tengamos en cuenta que un circuito genérico se divide en varios conjuntos de "timing paths" (generalmente tenemos REG-COMB-REG). *Con "timing path", nos referimos a una ruta punto a punto en una arquitectura que puede propagar los datos de un flip-flop/registro a otro*.
- Cada "timing path" se caracteriza por:
	- **Start Point:** Puede ser un pin de entrada al sistema o un pin de un reloj de entrada a un flip-flop.
	- **End Point:** Puede ser un pin de salida o un pin de un dato de entrada a un flip-flop.
El circuito es dividido en conjuntos de timing path, y se calcula el retardo associado a cada path
- Cada path es verificado con los requerimientos
- *Cada "timing path" se caracteriza por una demora (path delay), que es la suma de las interconexiones (net delay) y las celdas (cell delay) que componen la ruta.*
![[Pasted image 20231122114148.png|500]]

##### Net Delay
- El “Net Delay” se refiere al tiempo total requerido para cargar o descargar las capacitancias parasitas a lo largo de una interconexion causada por:
	- La longitud de la interconexcion
	- El fanout
- La Net Delay y los capacitancias parasitas son tipicamente
	- Back-Annotated mediante el uso de una herramiento para la extraccion de capacidades pasaritas
	- Stimadas por tabla proporcionadas antes de ahcer el layout
##### Cell Delay
Se refiere al retardo de una celda. El retardo de una celda es determinado por:
- El intervalo de transcion de la señal de ingreso(slew rate)
- La carga total vista de la celda(Fan out)

## Pasos de STA
La herramienta divide en varias partes el analisis de timing
Pasos de STA:
1. El diseño se divide en distintos caminos de timing (timing paths). Tipos:
	- *Entrada a salida(I2O):* En este caso, hay una conexión de entrada a salida sin ningún flip-flop, solo a través de uno o más bloques combinatorios.
	- *Entrada a registro(I2R):* Datos que fluyen desde el pin de entrada hacia un flip-flop ubicado a una distancia desconocida, donde llegan tanto el dato de entrada como el reloj, que suele ser suministrado por un buffer (por ejemplo, BUFG en FPGA).
	- *Registro a registro(R2R):*  Es el esquema típico RTL del tipo REG-COMB-REG del que ya se han tratado las restricciones de temporización.
	- *Registro a salida(R2O):* Datos que fluyen desde la salida del flip-flop hacia un bloque combinatorio ubicado a una distancia desconocida con cierto retardo.
2. Se calcula el retardo de propagación de todas las señales a lo largo de cada camino
3. Se chequean violaciones en las constraints de timing dentro del diseño y en las interfaces de entrada/ salida.
![[Pasted image 20240206182705.png|500]]

#### Calculo del tiempo R2R
![[Pasted image 20240206182740.png|500]]
- Se calcula los tiempor desde la entrada hasta el starpoint y ademas desde el start point hasta en endpoint.
	- Los endpoint siempre son asociados entre la entrada de un registro y la entrada del siguiente
- La suma de estos 2 tiempos no debe ser mayor al tiempo Destination Clock Path de la imagen.

### Calculo del tiempo de setup de la herramienta
![[Pasted image 20240206182312.png|800]]

### Calculo del tiempo de hold de la herramienta
![[Pasted image 20240206182314.png|800]]

### Conclusion


![[Pasted image 20240206182316.png|800]]



## STA en Vivado
- *Vivado realiza el análisis de tiempo estático (STA) y proporciona informes en los que se obtienen "slack"* negativos en una serie de rutas. Estos "slack" luego deben ser interpretados de cierta manera por el diseñador.
![[Pasted image 20231122135824.png]]
- Para activar esta STA, el sistema necesita conocer explícitamente los valores de las restricciones de temporización y, para hacerlo, es necesario informarle sobre el período del reloj que queremos usar.
	- De esta manera, tiene un tiempo para comparar con los retardos máximos de las líneas.
	- Una vez hecho esto, el sistema crea un grafo de retardos que se recorrerá cuatro veces: dos veces para calcular y verificar la restricción de tiempo de "setup" y otras dos para calcular y verificar la restricción de tiempo de "hold".
![[Pasted image 20231122135958.png]]

### Tiempo de hold VIVADO
- Analicemos cómo Vivado verifica el cumplimiento de la restricción de tiempo relativa al tiempo de "hold" (el razonamiento es similar para la restricción de tiempo de "setup").

- Una vez que llegan las entradas, es necesario evaluar todas las rutas más rápidas para llegar a la salida. Hecho esto, se verifica si los tiempos requeridos son mayores o menores que lo especificado. Cuando hay varias flechas que convergen en un nodo, el tiempo está dado por la suma mínima de las contribuciones: estos son los tiempos de contaminación y, por lo tanto, el peor caso es cuando este tiempo es mínimo.
![[Pasted image 20231122140419.png]]

- El sistema tiene tiempos de referencia. Estos son los tiempos mínimos con los que deben llegar las entradas para que se cumpla la restricción en los tiempos de "hold".
- Los valores 200-180-200 en la figura anterior son los tiempos mínimos requeridos. Al retroceder, el sistema determina los límites temporales en otros tiempos. Estos tiempos pueden ser negativos.
- Luego, se propagan los tiempos mínimos requeridos y se comparan con los resultados anteriores. 
![[Pasted image 20231122141253.png]]


- En este caso, el "slack" se llama "early" porque se calcula en el tiempo de contaminación, es decir, el más rápido. Vivado utiliza una terminología diferente. 
	- Cuando los resultados son positivos, significa que está bien porque la diferencia mínima entre los tiempos es positiva. 
	- Cuando se obtiene un número negativo, significa que la señal es demasiado rápida, violando así los tiempos de "hold". 
		- Dado que no se puede variar tc-q (el tiempo de contaminación), es necesario ajustar el tiempo de contaminación, ralentizando el camino y agregando retardos.
		- Esto se puede lograr agregando puertas lógicas no muy grandes, como OR y AND, para hacer más lento ese camino.

![[Pasted image 20231122142437.png]]

### Tiempo de setup VIVADO
- Con el timing constraint de tiempo de setup, la unica modificación principal radica en que se cambia el tiempo de contaminación (min) por el retardo crítico (max), y se toma el mínimo al retroceder.
- Los tiempos que deben cumplirse podrían ser diferentes, ya que son los tiempos máximos requeridos para cumplir con el primer constraint de tiempo de setup. En caso de una violación en el tiempo de setup, el primer ajuste debe ser aumentar el período del reloj. Es importante tener en cuenta que el offset en entrada y salida, si se especifica, hace que la STA sea más precisa. También se puede especificar el jitter, pero esto se discutirá más adelante.
![[Pasted image 20231122142632.png]]


## Observaciones #Estudiar 
En la síntesis con STA, a menudo se pueden encontrar informes de errores con respecto a la "timing enclosure" porque el bloque combinatorio es grande. Sin embargo, a veces, estas violaciones no tienen sentido. Por ejemplo, un multiplicador no se usaría nunca solo; estaría conectado entre otros bloques que componen el sistema. El sistema STA permite definir "false paths" que se ignorarán en la STA.

![[Pasted image 20231122142706.png]]


Además, puede haber caminos que requieren más ciclos de reloj, y en lugar de T, se tiene NT (como en el caso del multiplicador). Estos caminos se llaman "multi-cycle paths". 
![[Pasted image 20231122142701.png]]
![[Pasted image 20240719200910.png|600]]
En varios casos, hay sistemas que operan a frecuencias de reloj diferentes, y estas regiones se denominan "clock domains". Los problemas surgen en la interfaz entre estos dominios de reloj.




### Arreglando problemas de timing
- Además de realizar optimizaciones en la arquitectura del diseño o modificar parámetros del mismo como ser el paralelismo o frecuencia de operación, se pueden aplicar las siguientes técnicas para mejorar el timing de un diseño:
	- *Pipelining:* agregar registros para dividir caminos críticos en el diseño (aumentando la latencia)
	- *Retiming:* reubicación de los registros del diseño para reducir caminos críticos. Esto nos ayuda a no agregar latencia
	- *Cloning:* replicación de registros para reducir fanout y por ende mejorar timing.
		- Hay que aplicar restricciones para evitar que en la sintesis la herramienta vuelva al sistema original



# Referencias
### Notas relacionadas
- **Nota:**[[4. Transformaciones para Alta Velocidad, Bajo consumo y Optimizacion de Area]]
	- **Relacion-Reflexion:** Aqui podemos ver tecnicas que nos sirven para aumentar la velocidad sin violar problemas de tiempo
- **Nota:**[[V.2 Sintesis, implementacion y bitstream en vivado]]
	- **Relacion-Reflexion:** En esta nota podemos ver como hacer el analisis del STA en vivado
- **Nota:**[[5. Retiming]] [[Pipelining]] [[Cloning]]
	- **Relacion-Reflexion:** Tecnicas de manejos de registros para resolver problemas de tiempo
- **Nota:**[[4.1 Contrains]]
	- **Relacion-Reflexion:** En esta nota se puede analizar mas a profundidad los constrains, como por ejemplos los constrain de tiempo que nos serviran para un analisis mas preciso de los tiempos