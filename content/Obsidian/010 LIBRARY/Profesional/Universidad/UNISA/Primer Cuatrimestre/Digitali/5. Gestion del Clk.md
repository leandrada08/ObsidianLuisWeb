
# 5. Gestion del Clk
## Introducción

- **Introduzione**
	- Com'è un clock ideale?
		- Quale sono i componenti dal clock?
	- Cos'è un segnalo sincrono?
	- Cos'è un segnalo mesocroni?
- **Clock Skew e Jitter**
	- Cos'è il clock skew?
		- Quale tipi di clock skew ci sono?
		- Effetti del clock skew?
			- Sul setup?
			- Sul Hold
	- Cos'è il clock Jitter?
		- Effetti del clock Jitter?
- **Gestione di Jitter e Skew**
	- Quale sono i diversi mettodi per gestionare il clock Jitter e il clock Skew?
- **Distribuzione del clock**
	- Quale sono le diverse distribuzione del clock?
		- Quando è opportuno ciascuno?
	- Com'è la distribuzione dal clock nella FPGA?
- **Generazione del Clock**
	- Come funziona il PLL?
		- Come funziona i singoli componenti dal PLL?
		- Come si usa il PLL per generazione?
		- Come si usa il PLL per sincronizacione?
	- Come funziona il DLL?
		- Come funziona i gingoli componente dal DLL?
		- Come si usa il DLL per generazione?
		- Come si usa il DLL per sincronizacione?
	- PLL vs DLL
- **Sincronizzacione dei Sistemi**
	- Quale sono i tipi di sistemi?
		- Com'è un sistema GALS?
			- Vantaggi e svantaggi di questi sistema.
			- Cos'è la metastabilità?
			- Come si puoi evitare la metastabilità?
	- Come funzionano i sistemi auto temporizzati?
		- Come funziona il handshake di 2 fasi?
		- Come funziona il handshake di 4 fasi?





# Italiano

## Introduzione

La gestione del clock è fondamentale nei sistemi sincroni, poiché assicura che tutti i componenti del sistema operino in armonia temporale. Un clock ideale dovrebbe permettere la sincronizzazione perfetta di tutte le operazioni, ma nella pratica si affrontano diverse deviazioni che possono influire sulle prestazioni del sistema. Queste deviazioni, come il clock skew e il jitter, devono essere gestite adeguatamente per mantenere l'efficienza e la funzionalità del sistema.

#### Clock Ideale 
- Un *clock ideale* è un segnale periodico che attiva simultaneamente tutti i registri del sistema, garantendo che tutte le operazioni avvengano in sincronia perfetta. Questo segnale è noto come segnale sincrono, e la sua periodicità garantisce che le transizioni dei registri avvengano allo stesso tempo, senza disallineamenti o ritardi.


#### Segnali Sincroni e Mesocroni
Un segnale sincrono ha una frequenza e una fase costanti, il che permette una sincronizzazione precisa di tutti i componenti del sistema. In contrasto, un segnale mesocrono mantiene la stessa frequenza del segnale sincrono, ma con una fase diversa. Questo significa che, sebbene i componenti del sistema operino alla stessa velocità, potrebbero non essere perfettamente allineati nel tempo, introducendo il concetto di skew.

### Osservazione Importante
Non importa il ritardo assoluto tra il generatore del clock e i registri. È importante che i tempi di arrivo del clock siano il più possibile uguali tra loro. Nella figura abbiamo la fonte del clock 1 e poi le diverse cause di skew e jitter che analizzeremo separatamente. Tutti questi oggetti variano le costanti di tempo con cui si muove il clock e poi introducono uno schema per variazioni deterministiche e fluttuazioni per variazioni casuali.
![[Pasted image 20240217205356.png|500]]

## Clock Skew e Jitter
![[Pasted image 20240217205159.png|500]]


### Skew 
Il clock skew è il disallineamento temporale che si verifica quando il segnale di clock non arriva simultaneamente a tutti i componenti sincroni del sistema. Questo disallineamento può essere dovuto a varie cause, tra cui:
- **Distribuzione del clock**: I ritardi nel sistema di distribuzione del clock possono causare che il segnale arrivi a diversi componenti in momenti diversi.
- **Carichi sbilanciati**: Differenze nei carichi elettrici lungo il percorso di distribuzione del clock possono introdurre variazioni nel tempo di arrivo.
- **Interconnessioni e buffer**: Ritardi non bilanciati nelle interconnessioni e nei buffer del clock.
- **Progettazione asimmetrica della distribuzione del clock**: Differenze nei percorsi e nei tempi di propagazione del clock attraverso il circuito.
![[Pasted image 20240217205621.png|400]]


#### Effetti dello Skew 
Possono esistere 2 tipi di situazioni: quando il dato e il clock hanno lo stesso senso (skew positivo) e quando hanno senso opposto (skew negativo).
- **Skew positivo:** Aumenta il periodo del clock. I dati incontrano un clock in cui il disallineamento aumenta.
![[Pasted image 20240217210340.png]]
- **Skew negativo:** C'è un anticipo, il che significa un T equivalente minore.
![[Pasted image 20240217210352.png]]
**Circuito equivalente:**
![[Pasted image 20240217210402.png]]


#### Effetto sul Tempo di Setup del skew: 
- **Skew negativo**: Riduce il tempo effettivo disponibile per il setup, aumentando la difficoltà di rispettare questo requisito temporale.
- **Skew positivo**: Aumenta il tempo effettivo disponibile per il setup, il che può migliorare le prestazioni del sistema.
![[Pasted image 20240217210447.png]]
#### Effetto sul Tempo di Hold:
- **Skew positivo**: Rende più stringenti i vincoli del tempo di hold, poiché riduce il tempo effettivo di hold disponibile.
- **Skew negativo**: Allenta i vincoli del tempo di hold, poiché aumenta il tempo effettivo di hold disponibile.
#### Conclusione
Lo skew può influenzare significativamente la determinazione dei tempi di setup e hold in un sistema sincronizzato, influendo sulla stabilità e sulle prestazioni del circuito digitale. È fondamentale gestire adeguatamente lo skew per garantire una corretta sincronizzazione e rispettare i requisiti di temporizzazione del sistema.
![[Pasted image 20240217210813.png]]


#### Skew Relativo vs Assoluto
La differenza tra lo skew assoluto e lo skew relativo si riferisce a come viene misurato il disallineamento temporale nell'arrivo del segnale di clock a diversi componenti del sistema.

**Skew Assoluto**: 

- **Definizione**: È la differenza massima nel tempo di arrivo del segnale di clock tra il punto più anticipato e il punto più tardivo in tutto il sistema.
- **Misurazione**: Si misura come l'intervallo di tempo tra i momenti in cui il segnale di clock arriva ai diversi elementi sincroni più distanti in termini temporali.
- **Impatto**: Lo skew assoluto influisce sulla sincronizzazione globale del sistema, poiché rappresenta la massima discrepanza temporale nell'arrivo del clock a qualsiasi parte del circuito.

**Skew Relativo**:

- **Definizione**: È la differenza nel tempo di arrivo del segnale di clock tra punti specifici all'interno di una parte più piccola o locale del sistema, generalmente in regioni vicine tra loro.
- **Misurazione**: Si misura come l'intervallo di tempo tra i momenti in cui il segnale di clock arriva a due punti specifici all'interno di una regione determinata del circuito.
- **Impatto**: Lo skew relativo è cruciale per la sincronizzazione locale e può essere più facile da gestire rispetto allo skew assoluto. Assicurare che lo skew relativo sia minimo aiuta a mantenere la coerenza temporale in subregioni del sistema, anche se lo skew assoluto può essere maggiore.

**Esempio pratico**:

- **Skew assoluto**: In un circuito grande, se il clock arriva al registro A a 10 ns e al registro B a 15 ns, lo skew assoluto è di 5 ns.
- **Skew relativo**: Se all'interno di una subregione del circuito, il clock arriva al registro C a 10 ns e al registro D a 11 ns, lo skew relativo in quella subregione è di 1 ns, indipendentemente dal fatto che questi registri facciano parte dello stesso circuito dove lo skew assoluto è maggiore.

### Jitter 
Il jitter è una variazione nel tempo tra i cicli del clock che provoca inconsistenze nella frequenza del clock. A differenza dello skew, che è una deviazione spaziale, il jitter è una deviazione temporale. Si può classificare in due tipi principali:
- **Jitter ciclo a ciclo**: Variazione nella durata tra due periodi consecutivi del clock. Questo tipo di jitter può influire sulla sincronizzazione precisa dei componenti del sistema.
- **Jitter assoluto**: Massimo scostamento del periodo del clock rispetto al suo valore medio nominale. Questo valore è critico per determinare il margine di errore massimo nella temporizzazione del sistema.
- **Jitter per frequenze vicine ma non uguali**

#### Cause del Jitter 
1. *Variazioni nella frequenza del clock*: Piccole fluttuazioni nella frequenza nominale del clock possono provocare jitter.
2. *Modulazione e rumore casuale*: Interferenze e fluttuazioni nel segnale di clock possono introdurre variazioni temporali tra i fronti consecutivi.
3. *Jitter ciclo a ciclo*: Differenze nella durata dei periodi del clock tra cicli successivi.
4. *Jitter assoluto*: La massima deviazione della durata del periodo del clock rispetto al valore medio.

### Effetti del Jitter 
Il jitter può avere diversi effetti avversi sulle prestazioni del sistema:
- **Degradazione delle prestazioni**: Le variazioni nel tempo del clock possono provocare errori nella sincronizzazione dei dati, influenzando la precisione e l'efficienza del sistema.
- **Criticità del setup**: Simile allo skew, il jitter può rendere più difficile rispettare i requisiti di setup, poiché introduce incertezza nella temporizzazione.
#### Percorso logico in sistemi attivati da fronti
![[Pasted image 20240217210932.png]]
#### Accorciamento dei percorsi
![[Pasted image 20240218102421.png]]


## Gestione di Jitter e Skew 
1. *Equalizzazione dei ritardi
2. *Uso di tecniche di clock gating
3. *Distribuzione accurata di dati e clock
4. *Generazione e distribuzione di clock di alta qualità*: Utilizzare circuiti di generazione di clock come DLL (Delay-Locked Loop) e PLL (Phase-Locked Loop)
5. *Analisi statistica del jitter*: Eseguire analisi statistiche, come il metodo di Montecarlo, per stimare e gestire il jitter in modo efficace nel progetto del sistema.
6. *Attenzione particolare agli FPGA*: Prestare particolare attenzione alla gestione del jitter e dello skew nei dispositivi FPGA, poiché questi possono essere più sensibili a queste non idealità a causa della loro architettura e configurazione.
7. *Disaccoppiamento dell'alimentazione*: Utilizzare tecniche di disaccoppiamento per stabilizzare l'alimentazione del circuito e ridurre le fluttuazioni che causano jitter.
- È importante tenere presente che lo skew è intrinseco e non può essere eliminato, è un effetto causale dovuto all'attraversamento di una parte fisica con la sua propria capacità resistenza...
	- Per questa ragione, più che lo skew assoluto, mi interessa contenere uno skew relativo, cioè la differenza tra il disallineamento di n piste.
### Metodi di Analisi
Per valutare e gestire lo skew e il jitter, si utilizzano diversi metodi di analisi:
- **Place and route**: Questo processo aiuta a stimare e bilanciare i ritardi nei percorsi del clock, mitigando gli effetti dello skew.
- **Simulazioni Montecarlo**: Queste simulazioni permettono di prevedere le variazioni del jitter e di adattare il progetto del sistema per minimizzarne l'impatto.
- **Analisi termica e di alimentazione**: Valutare le variazioni termiche e di alimentazione per progettare strategie di mitigazione adeguate.
499

## Distribuzione del Clock 
La distribuzione del clock è cruciale per assicurare che tutti i componenti del sistema ricevano segnali di clock sincronizzati e per minimizzare sia lo skew che il jitter. Un progetto efficiente della distribuzione del clock può migliorare significativamente le prestazioni del sistema.
Ha l'obiettivo di minimizzare la componente deterministica del clock skew. Queste distribuzioni vengono effettuate dopo le interconnessioni con la porta di destinazione.
### Distribuzione del Clock ad Albero
   - Approccio per eguagliare i ritardi relativi: Distribuendo il clock in un progetto a forma di albero, si cerca di bilanciare i ritardi relativi tra i diversi rami dell'albero per minimizzare lo skew e garantire una sincronizzazione adeguata.
   - Regolazione delle dimensioni dei buffer e delle interconnessioni: Se i percorsi di distribuzione del clock non sono identici, si può regolare la dimensione dei buffer e delle interconnessioni per bilanciare i ritardi e ridurre lo skew.
   - Fondamentalmente, tutti lo stesso ritardo.
   - Occupa poca area.
#### Albero H
Si utilizza una struttura ad H per bilanciare i ritardi.
![[Pasted image 20240218103912.png]]
![[Pasted image 20240218104507.png]]
### Distribuzione del Clock a Griglia
   - Minimizzazione dello skew assoluto: La distribuzione del clock a griglia ha come obiettivo minimizzare lo skew assoluto inviando il segnale di clock da più direzioni. Questo aiuta a ridurre le variazioni nei tempi di arrivo del clock ai diversi punti del circuito.
   - Indipendenza dalla posizione dei registri: Implementando una distribuzione a griglia, si cerca di minimizzare l'impatto della posizione dei registri sui ritardi del clock, il che può migliorare la stabilità della sincronizzazione.
![[Pasted image 20240218104535.png]]
### Distribuzione del Clock negli FPGA
   - Attenzione particolare alla gestione del jitter e dello skew: A causa dell'architettura e della configurazione dei dispositivi FPGA, è importante prestare particolare attenzione alla distribuzione del clock per mitigare gli effetti del jitter e dello skew in questi dispositivi.
   - Uso dei PLL per regolare lo skew: Nei dispositivi FPGA, si possono utilizzare i PLL (Phase-Locked Loop) per regolare lo skew e migliorare la sincronizzazione del clock nel circuito.


## Generazione del Clock
Il clock è il cuore di qualsiasi sistema digitale, fornendo il segnale di sincronizzazione che coordina le operazioni di tutti i componenti del sistema. Senza un clock preciso, i componenti non potrebbero operare in modo armonioso, il che risulterebbe in errori nel processamento dei dati.
- **Frequenza**: La frequenza del clock determina la velocità con cui operano i circuiti digitali. Una maggiore frequenza permette di eseguire più operazioni in meno tempo, ma aumenta anche il consumo di energia e la generazione di calore.
- **Fase**: La fase del clock è cruciale per la sincronizzazione. Qualsiasi disallineamento nella fase può causare problemi di temporizzazione, noti come skew.

### Concetti Preliminari Importanti
#### Oscillatori al Quarzo

Un oscillatore al quarzo utilizza le proprietà piezoelettriche del quarzo per generare un segnale di clock stabile e preciso. Quando si applica una tensione elettrica al cristallo di quarzo, questo vibra a una frequenza specifica che dipende dal suo taglio e dalle sue dimensioni. Queste vibrazioni vengono convertite in un segnale elettrico periodico che viene utilizzato come clock.
- **Vantaggi**:
    - Alta stabilità e precisione.
    - Bassa deriva di frequenza nel tempo.
    - Buona immunità al rumore e alle variazioni di temperatura.
- **Limitazioni**:
    - Limitazione nella frequenza massima (centinaia di MHz).
    - Non possono essere regolati dinamicamente per cambiare la frequenza.
    - Generare clock ad alta frequenza (oltre centinaia di MHz) fuori dal chip può risultare in perdita di segnale a causa delle limitazioni fisiche e della dissipazione di energia nelle piste del PCB.

#### Moltiplicatori e Divisori di Frequenza

I moltiplicatori e i divisori di frequenza sono circuiti che regolano la frequenza del clock generato dall'oscillatore al quarzo per adattarsi alle esigenze del sistema digitale.

- **Moltiplicatori di Frequenza**: Aumentano la frequenza del clock. Utilizzati quando si necessita di una frequenza di operazione più alta rispetto a quella fornita dall'oscillatore al quarzo.
    - **PLL (Phase-Locked Loop)**: Utilizzato per moltiplicare la frequenza del clock di riferimento.
- **Divisori di Frequenza**: Riduciono la frequenza del clock. Utilizzati quando si necessita di una frequenza più bassa per certe parti del circuito.
    - **Divisori a Flip-Flop**: Implementati utilizzando flip-flop di tipo T in cascata.


### PLL 
![[Pasted image 20240218110031.png]]
Un PLL è un circuito che sincronizza la frequenza e la fase di un oscillatore controllato (VCO) con un segnale di riferimento. È ampiamente utilizzato nei sistemi digitali per generare clock ad alta frequenza a partire da un segnale di riferimento a bassa frequenza.
- **Phase Detector (PD)**: Rileva la differenza di fase tra il segnale di riferimento e il segnale di feedback del VCO.
- **Charge Pump (CP)**: Converte la differenza di fase rilevata in una corrente che regola la tensione del VCO.
- **Loop Filter (LF)**: Filtra il segnale della charge pump per smorzare la tensione di controllo del VCO e ridurre il jitter.
- **Voltage-Controlled Oscillator (VCO)**: Genera un segnale di frequenza controllata dalla tensione di ingresso.
- **Divisore di Frequenza**: Divide la frequenza del segnale del VCO per generare il segnale di feedback al phase detector. Se non presente, viene utilizzato per creare due clock con uno skew pari a zero, ma inoltre c'è questo blocco per moltiplicare.


![[Pasted image 20240218110045.png]]
- Se si lavora con piccoli segnali, può essere linearizzato in un intervallo della frequenza di free running e possiamo descrivere i blocchi con una funzione di trasferimento e il PLL si comporta in questo caso come un LP di secondo ordine 🡪 per piccole deviazioni dalla condizione di aggancio.
- Il PLL lavora essenzialmente sulle fasi dei segnali che entrano.
![[Pasted image 20240218110408.png]]
#### Phase Detector (PD)
Confronta la fase di due segnali di ingresso e genera un'uscita proporzionale al disallineamento tra di essi. Con questo tipo di circuito non riesco a sapere se il disallineamento è positivo o negativo. Questo può funzionare in certe circostanze, ma con prestazioni limitate, poiché in realtà si sta osservando un ritardo e può sempre essere interpretato come un anticipo. Tuttavia, lavorando con piccoli segnali, questi disallineamenti sono generalmente piccoli rispetto al valore nominale. Quando si lavora con disallineamenti grandi, si perde la linearità.
![[Pasted image 20240218111113.png]]
#### Phase-Frequency Detector (PFD):
![[Pasted image 20240218111158.png]]
Il Phase-Frequency Detector è un'estensione del PD che non solo rileva la differenza di fase tra i segnali di ingresso, ma può anche rilevare differenze nella frequenza. Questo permette al PFD di controllare sia la fase che la frequenza del VCO in modo più preciso, migliorando la stabilità e la velocità del processo di sincronizzazione.
Il Phase-Frequency Detector (PFD) viene implementato come una macchina a stati: 2 registri e una porta logica. L'uscita dei due Flip-Flop viene letta dalla porta logica in retroazione, e l'uscita della porta logica controlla il reset dei due registri. In questo modo, si può determinare il segno del disallineamento, poiché ci sono due segnali, 'up' e 'down', che controllano la carica della pompa di carica.
#### Charge Pump (Pompa di Carica):
Rileva l'errore di fase di corrente tra due segnali. 
Poiché la corrente della pompa di carica è costante, avremo che la fdt è una costante K del rilevatore di fase.
![[Pasted image 20240218111839.png]]
#### Loop Filter (Filtro di Anello):
![[Pasted image 20240218111933.png]]
Il loop filter è un componente cruciale in un PLL che si occupa di garantire la stabilità del sistema. Si tratta di un filtro passa-basso che genera una rampa di controllo per il VCO. Il loop filter è fondamentale per ridurre il jitter del "system clock" e mantenere la stabilità del sistema di controllo di fase.
#### Ring-Oscillator VCO (VCO ad Anello di Oscillatore):
Il VCO basato su anello di oscillatore è un tipo di oscillatore utilizzato nella generazione di segnali di clock nei circuiti integrati. Consiste in una serie di inverter in un anello di retroazione che generano un'oscillazione. Questo tipo di VCO è comune nelle librerie standard delle tecnologie di fabbricazione e viene utilizzato per confrontare le prestazioni di diverse tecnologie.
![[Pasted image 20240218111949.png]]
#### Frequency Divider (Divisore di Frequenza):
Il frequency divider è un componente utilizzato per dividere la frequenza di un segnale di clock. In un PLL, il frequency divider viene impiegato nella retroazione per moltiplicare o dividere la frequenza del clock di uscita rispetto al segnale di riferimento. Questo permette di regolare la frequenza del segnale di uscita in base ai requisiti del sistema.


### PLL come Base di Distribuzione del Clock  
La distribuzione del clock utilizzando PLL (Phase-Locked Loop) permette che molteplici sistemi digitali ricevano segnali di clock perfettamente sincronizzati in fase. Questo si ottiene utilizzando PLL come buffer a ritardo zero (zero delay buffers).
![[Pasted image 20240218112133.png]]
#### Funzionamento
1. **Phase Detector (PD)**: Confronta la fase del segnale di riferimento con il segnale di feedback e genera segnali di errore ("up" e "down").
2. **Charge Pump (CP)**: Converte i segnali di errore in una corrente che regola la tensione di ingresso del filtro di loop.
3. **Loop Filter (LF)**: Filtra il segnale della charge pump per stabilizzare la tensione di controllo del VCO.
4. **Voltage-Controlled Oscillator (VCO)**: Genera un segnale di clock la cui frequenza viene regolata in base alla tensione di controllo.
5. **Clock Driver**: Amplifica il segnale di clock per distribuirlo al sistema digitale.


### PLL come Base della Sincronizzazione 
La sincronizzazione basata su PLL viene utilizzata per assicurare che il segnale di clock in un chip sia perfettamente sincronizzato con il segnale di clock in un altro chip, anche quando i dati vengono trasferiti a una frequenza inferiore rispetto al clock di sistema. Questo è cruciale nei sistemi in cui i dati devono essere trasferiti in modo sincrono tra chip differenti.
![[Pasted image 20240218112213.png]]
#### Funzionamento
1. **PLL nel Chip 1**: Genera un clock di sistema a partire da un oscillatore al quarzo e un divisore di frequenza.
2. **Divisore di Frequenza**: Genera un clock di riferimento a partire dal clock di sistema per trasferire i dati.
3. **Trasferimento di Dati**: I dati vengono trasferiti dal Chip 1 al Chip 2 in modo sincrono con il clock di riferimento.
4. **PLL nel Chip 2**: Riceve il clock di riferimento e lo utilizza per sincronizzare il proprio clock interno, annullando gli effetti del ritardo del buffer di clock (de-skewing).



### DLL 
La generazione del clock utilizzando DLLs (Delay-Locked Loops) è un approccio alternativo all'uso dei PLLs (Phase-Locked Loops) per la generazione e la sincronizzazione dei segnali di clock nei circuiti integrati.
Un DLL è un circuito simile a un PLL, ma invece di regolare la frequenza di un VCO, regola il ritardo di una linea di ritardo controllata da tensione per sincronizzare la fase del segnale di uscita con il segnale di ingresso.
Un Delay-Locked Loop è un tipo di circuito di controllo di loop che si basa su una linea di ritardo controllata da tensione anziché un oscillatore controllato da tensione. In un DLL, si cerca di allineare perfettamente i segnali di riferimento e di uscita (deskewing) regolando il ritardo della linea di ritardo.
#### Differenze tra PLL e DLL
- **PLL**: Regola la frequenza per sincronizzare la fase e può moltiplicare la frequenza del segnale di riferimento.
- **DLL**: Regola direttamente la fase tramite una linea di ritardo e non può moltiplicare la frequenza del segnale di riferimento.
#### Componenti e Funzionamento del DLL
- **Phase Detector (PD)**: Rileva la differenza di fase tra il segnale di ingresso e il segnale di uscita.
- **Charge Pump (CP)**: Genera una corrente basata sulla differenza di fase.
- **Delay Line**: Una linea di ritardo controllata da tensione che regola il ritardo del segnale di uscita per sincronizzarlo con il segnale di ingresso.
#### Applicazioni del DLL nei Sistemi Digitali
- **Refaseo del Clock**: Regolazione fine della fase del clock per minimizzare lo skew.
- **Sincronizzazione dei Dati**: Sincronizzazione dei segnali di dati in interfacce ad alta velocità.
![[Pasted image 20240218112529.png]]
- Non ha un oscillatore controllato da tensione.
- In condizioni di sincronizzazione, i segnali di ingresso e uscita sono perfettamente allineati in termini di fase (deskewing).
- I DLL non permettono la moltiplicazione della frequenza del segnale di riferimento, a differenza dei PLL.
- I DLL sono sistemi incondizionatamente stabili e tendono ad avere un minor jitter rispetto ai PLL.


### DLL come Base di Distribuzione del Clock 
![[Pasted image 20240218113511.png]]



## Sincronizzazione dei Sistemi

### Introduzione
#### Sistemi Sincroni
I sistemi sincroni operano con un clock globale che coordina il funzionamento di tutti i componenti. Ogni elemento del sistema esegue le proprie operazioni in sincronia con questo clock, il che permette una coordinazione precisa e prevedibile delle attività. Questi sistemi sono comuni nella maggior parte dei circuiti integrati grazie alla loro semplicità e prevedibilità.
- **Definizione e Caratteristiche**: Un sistema sincrono utilizza un clock globale per sincronizzare tutte le sue operazioni. Questo assicura che tutte le parti del sistema lavorino insieme in modo coordinato.
- **Esempi di Applicazioni Comuni**: Microprocessori, memorie e altri circuiti integrati digitali.
#### Sistemi Asincroni
A differenza dei sistemi sincroni, i sistemi asincroni non dipendono da un clock globale. Al contrario, le operazioni si avviano e si completano in funzione di eventi o segnali specifici. Questo può offrire vantaggi in termini di flessibilità ed efficienza energetica, ma presenta anche sfide significative in termini di progettazione e sincronizzazione.
- **Definizione e Caratteristiche**: Un sistema asincrono opera senza un clock globale, basandosi su eventi esterni per avviare e completare operazioni.
- **Esempi di Eventi Asincroni**: Ingresso da una tastiera, segnali di sensori, ecc.


### Tipi di sistema
- **Veramente Asincrono**
- **Sistemi globalmente Asincroni-Localmente Sincroni**
	- **Definizione e Descrizione del Funzionamento**: I sistemi GALS consistono in vari sotto-sistemi sincroni che operano a diverse frequenze di clock, ma comunicano tra loro in modo asincrono. Ogni sotto-sistema ha il proprio clock locale.
	- **Vantaggi e Svantaggi**: 
		- *Vantaggi*: Maggiore flessibilità, efficienza energetica, riduzione dei problemi di skew.
		- *Svantaggi*: Complessità nella progettazione, necessità di meccanismi di sincronizzazione aggiuntivi.
	- **Esempi e Applicazioni**: Sistemi integrati in dispositivi mobili, dove diversi moduli (come CPU, GPU e moduli di comunicazione) operano a frequenze diverse.
- **Sistema autotemporizzato**
	- **Definizione e Funzionamento**: Un sistema auto-temporizzato completa le sue operazioni basandosi su segnali di handshaking e completamento, anziché dipendere da un clock globale.
	- **Vantaggi e Svantaggi**: 
		 - *Vantaggi*: Risparmio di potenza, riduzione dell'area del chip, maggiore tolleranza a variazioni nel processo e nella temperatura.
		- *Svantaggi*: Necessità di circuiteria aggiuntiva, complessità nella progettazione.
	- **Esempi e Applicazioni**: Circuiti specifici che richiedono alta efficienza energetica e tolleranza a variazioni, come certi moduli in sistemi integrati avanzati.

### Sistemi Globalmente Asincroni-Localmente Sincroni (GALS)
![[Pasted image 20240720102313.png]]
I sistemi GALS combinano il meglio di entrambi i mondi, utilizzando clock locali per sincronizzare operazioni all'interno di piccoli sotto-sistemi, mentre permettono a questi sotto-sistemi di operare asincronamente tra loro. Questo approccio può migliorare la flessibilità e l'efficienza energetica, riducendo al contempo i problemi di temporizzazione e skew.

#### Problema: Metastabilità
Il problema di queste sistema è la sua elevata probabilita di metastabilità.
La metastabilità è uno stato in cui un flip-flop può rimanere intrappolato in una condizione intermedia tra uno stato logico alto e uno basso. Questo stato indefinito può verificarsi quando il flip-flop riceve un segnale di ingresso asincrono o quando i tempi di configurazione e mantenimento non vengono rispettati adeguatamente. L'uscita dalla metastabilità è imprevedibile, sia in termini di tempo che di valore logico, il che può causare errori nel sistema.
![[Pasted image 20240206183721.png]]
##### Modelli di Metastabilità
- La possibilità di metastabilità quando abbiamo un segnale asincrono è 2 volte il tempo di salita diviso nel periodo
$$P_{\epsilon}=\frac{2t_e}{T}$$
Se il clock varia con la nostra frequenza: $N=P_{\epsilon}.f_{clk}$
Dove N è MTBF, che è una caratteristica della qualità del nostro sistema
$$MTBF=\frac{e^{\frac{t_{m,max}}{\tau}}}{f_{ck}.f_{signal}t_0}$$
![[Pasted image 20240720102715.png]]
Per comprendere e mitigare la metastabilità, si utilizzano vari modelli matematici e fisici. Un modello comune è il modello di un singolo polo per un flip-flop, che descrive come un flip-flop può entrare e uscire da uno stato metastabile.
$$v_q(t)=V_M+(v_a(0)-V_M).e^{\frac{t}{\tau}}$$
- **VM**: Tensione di metastabilità.
- **v(0)**: Valore iniziale della tensione.
- **τ**: Costante di tempo che varia con le condizioni del processo e ambientali (come la temperatura).
Esiste una fascia di valori proibiti intorno a $VM$, con un'ampiezza di $2v_ε$, dove il tempo per uscire dalla metastabilità (tm) supera un valore massimo (tm,max), risultando in un errore di sincronizzazione.
Imponendo $VM = VDD/2$ e $Vq(tm) = VDD$, il modello prevede un tempo infinito per l'uscita dalla metastabilità se l'ingresso vale esattamente VM.
![[Pasted image 20240720103256.png]]
#### Mitigazione della Metastabilità
Anche se non si può eliminare completamente il rischio di metastabilità, si possono prendere misure per ridurne la probabilità e mitigarne gli effetti:
- **Uso di Flip-Flops in Cascata**: Posizionare due flip-flops in cascata può ridurre la probabilità che la metastabilità influenzi l'operazione del sistema, a scapito di un aumento della latenza.
- **Aumento del Timing**: Regolare i tempi di configurazione e mantenimento per adattarsi al peggiore caso di tempo di uscita dalla metastabilità può aiutare a minimizzarne l'impatto.


### Sistemi Auto-temporizzati (Self-timed)

![[Captura de pantalla 2024-09-20 a las 9.18.28 a. m..png]]

I sistemi auto-temporizzati, o self-timed, operano senza un clock globale, utilizzando invece segnali di handshaking e di completamento per coordinare le operazioni. Questo permette che ogni componente del sistema funzioni al proprio ritmo, basato sulla disponibilità dei dati e sul completamento delle operazioni precedenti, il che può risultare in una maggiore efficienza energetica e un uso più efficace dell'area del chip.
- **Separazione tra Ordinamento Logico e Fisico**: I sistemi auto-temporizzati permettono una chiara distinzione tra la logica del circuito e l'ordinamento fisico dei suoi componenti.
- **Considerazione del Ritardo come Media**: Invece di progettare in funzione del peggiore caso di ritardo, questi sistemi considerano la media dei ritardi, il che può portare a un design più efficiente.
- **Risparmio di Potenza e Area**: Eliminando la necessità di un clock globale, si riduce il consumo di energia e l'area dedicata alla distribuzione del clock nel chip.
- **Circuiteria Aggiuntiva per Sincronismo**: Si richiede circuiteria aggiuntiva per gestire i segnali di sincronismo e handshaking.
#### Modulo di Ritardo
![[Captura de pantalla 2024-09-20 a las 9.18.12 a. m..png]]
Nei sistemi auto-temporizzati, i moduli di ritardo sono cruciali per assicurare che i segnali si propaghino correttamente e senza disallineamenti.
- **Portelogiche Fittizie**: Queste porte logiche artificiali hanno lo stesso ritardo critico della rete logica e si posizionano vicino alla rete per evitare disallineamenti dovuti a variazioni di temperatura o processo.
#### Esempio: Self-Timed Adder
![[Captura de pantalla 2024-09-20 a las 9.20.50 a. m..png]]
Un esempio di sistema auto-temporizzato è un sommatore auto-temporizzato, che opera in modo efficiente coordinando le operazioni tramite segnali di handshaking.
- **Generazione Differenziale del Carry**: Questo approccio riduce il tempo critico del carry modificando la catena di carry di Manchester.
- **Sensing di Corrente per Segnale di Completamento**: Utilizza la rilevazione di corrente per generare segnali di completamento, assicurando che le operazioni si completino prima di passare alla fase successiva.
- **Mindelay Generator**: Questo componente evita blocchi nel caso in cui la logica non commuti adeguatamente.




#### Protocolli Hand-Shaking 
##### Handshake a Due Fasi
![[Captura de pantalla 2024-09-20 a las 9.36.15 a. m..png]]
Il protocollo di handshake a due fasi è una tecnica di sincronizzazione utilizzata per coordinare la comunicazione tra un emittente e un ricevitore mediante segnali di richiesta (Req) e riconoscimento (Ack).
- **Configurazione Sender-Receiver**: L'emittente e il ricevitore scambiano segnali di Req e Ack per avviare e completare il trasferimento dei dati.
- **Descrizione del Diagramma Temporale**:
  - *Ciclo 1*: L'emittente invia un segnale di richiesta (Req).
  - *Ciclo 2*: Il ricevitore risponde con un segnale di riconoscimento (Ack), indicando che ha ricevuto e processato la richiesta.
##### Handshake a Quattro Fasi
Il protocollo di handshake a quattro fasi utilizza un ciclo di quattro passaggi per sincronizzare le operazioni, fornendo una gestione robusta e flessibile dei segnali di completamento.
- **Vantaggi**: Questo protocollo è più robusto e tollerante agli errori, fornendo una sincronizzazione più affidabile nei sistemi complessi.
- **Svantaggi**: Può essere più lento e consumare più risorse rispetto al protocollo a due fasi.
##### Esempio di FIFO Auto-temporizzato
![[Captura de pantalla 2024-09-20 a las 9.38.09 a. m..png]]
Un FIFO auto-temporizzato utilizza protocolli di handshake per gestire il trasferimento dei dati tra le fasi, assicurando che ogni fase sia completa prima di passare alla successiva.
- **Indicatori di Pipeline Vuoto e Pieno**:
  - *Pipeline Vuoto*: Tutti i bit sono 1 o 0.
  - *Pipeline Pieno*: I bit alternano tra 1 e 0.
Questi indicatori permettono una gestione efficiente del flusso di dati, assicurando che il sistema operi in modo ottimale e senza interruzioni.





### Observazione
#### Sincronizzazione di Segnali Asincroni 
##### Flip-Flops come Sincronizzatori
I flip-flops sono i blocchi di costruzione fondamentali per sincronizzare segnali asincroni. Vengono utilizzati per catturare e stabilizzare segnali che arrivano in momenti non sincronizzati con il clock del sistema.
- **Uso di Base**: Un flip-flop semplice può sincronizzare un segnale asincrono campionandolo sul bordo del clock del sistema.
- **Problemi Potenziali**: La violazione dei constraints temporali può portare alla metastabilità, dove il flip-flop non può risolvere la sua uscita in un tempo finito.
##### Sincronizzazione nei Sistemi GALS
Nei sistemi GALS, è essenziale utilizzare bistabili per la sincronizzazione di segnali tra sotto-sistemi che operano a diverse frequenze di clock. Questo approccio permette che ogni sotto-sistema mantenga la propria sincronizzazione locale mentre comunica in modo sicuro con altri sotto-sistemi.
- **Bistabili per Sincronizzazione**: I bistabili vengono usati per catturare e sincronizzare i segnali di ingresso provenienti da altri sotto-sistemi asincroni.
- **Considerazioni di Timing**: Si deve tener conto di un aumento nel ritardo tCQ, che è il tempo necessario per catturare e propagare un segnale attraverso il bistabile.
# Español
## Introducción

La gestión del clock es fundamental en los sistemas sincronos, ya que asegura que todos los componentes del sistema operen en armonía temporal. Un clock ideal debería permitir la sincronización perfecta de todas las operaciones, pero en la práctica, se enfrenta a diversas desviaciones que pueden afectar el rendimiento del sistema. Estas desviaciones, como el clock skew y el jitter, deben ser gestionadas adecuadamente para mantener la eficiencia y la funcionalidad del sistema
#### Clock Ideal
- Un *clock ideal* es un segnale periodico que activa simultáneamente todos los registros del sistema, asegurando que todas las operaciones se realicen en sincronía perfecta. Este señal se conoce como señal sincrona, y su periodicidad garantiza que las transiciones de los registros se realicen al mismo tiempo, sin desalineaciones ni retrasos.

#### Señales sincronas y mesocrono
Una señal sincrona tiene una frecuencia y fase constantes, lo que permite una sincronización precisa de todos los componentes del sistema. En contraste, una señal mesocrono mantiene la misma frecuencia que la señal sincrona, pero con una fase diferente. Esto significa que aunque los componentes del sistema operen a la misma velocidad, pueden no estar perfectamente alineados en el tiempo, lo que introduce el concepto de skew.

### Observacion importante
No importa el retraso absoluto entre el generador del reloj y los registros. Es importante que los tiempos de llegada del reloj sean lo más iguales posible entre sí. En la figura tenemos la fuente del reloj 1 y luego las diferentes causas de skew y jitter que ahora analizaremos por separado. Todos estos objetos varían las constantes de tiempo con las que se mueve el reloj y luego introducen un bosquejo para variaciones deterministas y fluctuaciones para variaciones aleatorias.
![[Pasted image 20240217205356.png|500]]

## Clock Skew y Jitter
![[Pasted image 20240217205159.png|500]]
### Skew
El clock skew es el desalineamiento temporal que ocurre cuando el señal de clock no llega simultáneamente a todos los componentes sincronos del sistema. Este desalineamiento puede deberse a varias causas, incluyendo:
- **Distribución del clock**: Los retardos en el sistema de distribución del clock pueden causar que la señal llegue a diferentes componentes en diferentes momentos.
- **Cargas desbalanceadas**: Diferencias en las cargas eléctricas a lo largo del camino de distribución del clock pueden introducir variaciones en el tiempo de llegada.
- **Interconexiones y buffers**: Retardos no balanceados en las interconexiones y buffers del clock.
- **Diseño asimétrico de la distribución del clock**: diferencias en las rutas y tiempos de propagación del clock a través del circuito.
![[Pasted image 20240217205621.png|400]]

#### Efectos del Skew
Pueden existir 2 tipos de situaciones, cuando el dato y el clok tienen el mismo sentido(skew positivo) y cuando tienen opuesto(negativo)
- **Skew positivo:** Aumenta el perdiodo del clock. Los datos encuentran un clock en el cual el desafe aumenta.
![[Pasted image 20240217210340.png]]
- **Skew negativo:** Hay un anticipo, lo que significa un T equivalente menor.
![[Pasted image 20240217210352.png]]
**Circuito equivalente:**
![[Pasted image 20240217210402.png]]
#### Efecto en el tiempo de setup:
- **Skew negativo**: Reduce el tiempo efectivo disponible para el setup, aumentando la dificultad de cumplir con este requisito temporal.
- **Skew positivo**: Aumenta el tiempo efectivo disponible para el setup, lo que puede mejorar las prestaciones del sistema.
![[Pasted image 20240217210447.png]]
##### Efecto en el tiempo de hold:
- **Skew positivo**: Hace más estrictas las restricciones del tiempo de hold, ya que reduce el tiempo efectivo de hold disponible.
- **Skew negativo**: Relaja las restricciones del tiempo de hold, ya que aumenta el tiempo efectivo de hold disponible.

#### Conclusion
El skew puede influir significativamente en la determinación de los tiempos de setup y hold en un sistema sincronizado, afectando la estabilidad y el rendimiento del circuito digital. Es fundamental gestionar adecuadamente el skew para garantizar una sincronización correcta y cumplir con los requisitos de temporización del sistema.
![[Pasted image 20240217210813.png]]


#### Skew relativo vs absoluto
La diferencia entre el skew absoluto y el skew relativo se refiere a cómo se mide la desalineación temporal en la llegada del señal de clock a diferentes componentes del sistema.

**Skew absoluto**: 

- **Definición**: Es la diferencia máxima en el tiempo de llegada del señal de clock entre el punto más temprano y el punto más tardío en todo el sistema.
- **Medición**: Se mide como el intervalo de tiempo entre los momentos en que el señal de clock llega a los diferentes elementos sincronos más alejados en términos temporales.
- **Impacto**: El skew absoluto afecta la sincronización global del sistema, ya que representa la máxima discrepancia temporal en la llegada del clock a cualquier parte del circuito.

**Skew relativo**:

- **Definición**: Es la diferencia en el tiempo de llegada del señal de clock entre puntos específicos dentro de una parte más pequeña o local del sistema, generalmente en regiones cercanas entre sí.
- **Medición**: Se mide como el intervalo de tiempo entre los momentos en que el señal de clock llega a dos puntos específicos dentro de una región determinada del circuito.
- **Impacto**: El skew relativo es crucial para la sincronización local y puede ser más fácil de gestionar que el skew absoluto. Asegurar que el skew relativo sea mínimo ayuda a mantener la coherencia temporal en subregiones del sistema, aunque el skew absoluto pueda ser mayor.

**Ejemplo práctico**:

- **Skew absoluto**: En un circuito grande, si el clock llega al registro A a las 10 ns y al registro B a las 15 ns, el skew absoluto es de 5 ns.
- **Skew relativo**: Si dentro de una subregión del circuito, el clock llega al registro C a las 10 ns y al registro D a las 11 ns, el skew relativo en esa subregión es de 1 ns, independientemente de que estos registros formen parte del mismo circuito donde el skew absoluto es mayor.



### Jitter

El jitter es una variación en el tiempo entre los ciclos del reloj que provoca inconsistencias en la frecuencia del clock. A diferencia del skew, que es una desviación espacial, el jitter es una desviación temporal. Se puede clasificar en dos tipos principales:

- **Jitter ciclo a ciclo**: Variación en la duración entre dos periodos consecutivos del clock. Este tipo de jitter puede afectar la sincronización precisa de los componentes del sistema.
- **Jitter absoluto**: Máximo desvío del periodo del clock respecto a su valor medio nominal. Este valor es crítico para determinar el margen de error máximo en la temporización del sistema.
- **Jitter por frecuencias cercanas pero no iguales**
 
#### Causas de Jitter
1. *Variaciones en la frecuencia del clock*: pequeñas fluctuaciones en la frecuencia nominal del clock pueden provocar jitter.
2. *Modulación y ruido aleatorio*: interferencias y fluctuaciones en la señal de clock pueden introducir variaciones temporales entre los flancos consecutivos.
3. *Jitter ciclo a ciclo*: diferencias en la duración de los periodos del clock entre ciclos sucesivos.
4. *Jitter absoluto*: la máxima desviación de la duración del periodo del clock respecto al valor medio.



### Efectos del jitter
El jitter puede tener varios efectos adversos en el rendimiento del sistema:
- **Degradación de las prestaciones**: Las variaciones en el tiempo del clock pueden provocar errores en la sincronización de datos, afectando la precisión y la eficiencia del sistema.
- **Criticidad del setup**: Similar al skew, el jitter puede hacer más difícil cumplir con los requisitos de setup, ya que introduce incertidumbre en la temporización.
#### Ruta logica en sistemas disparados por flancos

![[Pasted image 20240217210932.png]]
#### Acortamiento de caminos
![[Pasted image 20240218102421.png]]




## Gestion de jitter e skew
1. *Equalización de los retardos
2. *Uso de técnicas de clock gating
3. *Distribución cuidadosa de datos y clock
4. *Generación y distribución de clock de alta calidad:* Utilizar circuitos de generación de clock como DLL (Delay-Locked Loop) y PLL (Phase-Locked Loop)
5. *Análisis estadístico del jitter:* Realizar análisis estadísticos, como el método de Montecarlo, para estimar y gestionar el jitter de manera efectiva en el diseño del sistema.
6. *Enfoque en FPGA:* Prestar especial atención a la gestión del jitter y del skew en dispositivos FPGA, ya que estos pueden ser más sensibles a estas no idealidades debido a su arquitectura y configuración.
7. *Disaccoplamiento de alimentación*: Utilizar técnicas de desacoplamiento para estabilizar la alimentación del circuito y reducir las fluctuaciones que causan jitter.


- Hay que tener en cuenta algo muy importante: el skew es intrínseco y no puede ser eliminado, es un efecto causal causado por el cruce de una parte física con su propia capacidad resistencia... 
	- Por esa razón, más que el skew absoluto, estoy interesado en contener un skew relativo, es decir, la diferencia entre el desfase de n pistas.
### Métodos de análisis

Para evaluar y gestionar el skew y el jitter, se utilizan varios métodos de análisis:

- **Place and route**: Este proceso ayuda a estimar y balancear los retardos en las rutas del clock, mitigando los efectos del skew.
- **Simulaciones Montecarlo**: Estas simulaciones permiten prever las variaciones del jitter y ajustar el diseño del sistema para minimizar su impacto.
- **Análisis térmico y de alimentación**: Evaluar las variaciones térmicas y de alimentación para diseñar estrategias de mitigación adecuadas.

## Distribucion del clock
La distribución del clock es crucial para asegurar que todos los componentes del sistema reciban señales de clock sincronizadas y minimizar tanto el skew como el jitter. Un diseño eficiente de la distribución del clock puede mejorar significativamente el rendimiento del sistema.
Tiene el objetivo minimizar la componente deterministica del clock skew. Estas distribuciones se realizan despues de las interconessiones con el puerto de destino

### Distribución del clock en árbol
   - Enfoque en igualar los retardos relativos: Al distribuir el clock en un diseño en forma de árbol, se busca equilibrar los retardos relativos entre las diferentes ramas del árbol para minimizar el skew y garantizar una sincronización adecuada.
   - Ajuste del sizing de los buffers e interconexiones: Si las rutas de distribución del clock no son idénticas, se puede ajustar el tamaño de los buffers y las interconexiones para equilibrar los retardos y reducir el skew.
   - Basicamente, todos el mismo retardo.
   - Ocupa poca area
#### Arbol H
Se utiliza una estructura en H para balancear los retardos
![[Pasted image 20240218103912.png]]
![[Pasted image 20240218104507.png]]
###  Distribución del clock en grilla:
   - Minimización del skew absoluto: La distribución del clock en una grilla tiene como objetivo minimizar el skew absoluto al enviar la señal de clock desde múltiples direcciones. Esto ayuda a reducir las variaciones en los tiempos de llegada del clock a diferentes puntos del circuito.
   - Independencia de la posición de los registros: Al implementar una distribución en grilla, se busca minimizar el impacto de la posición de los registros en los retardos del clock, lo que puede mejorar la estabilidad de la sincronización.
![[Pasted image 20240218104535.png]]

### Distribución del clock en FPGA:
   - Atención especial a la gestión del jitter y del skew: Debido a la arquitectura y configuración de los dispositivos FPGA, es importante prestar especial atención a la distribución del clock para mitigar los efectos del jitter y del skew en estos dispositivos.
   - Uso de PLL para ajustar el skew: En dispositivos FPGA, se pueden utilizar PLL (Phase-Locked Loop) para ajustar el skew y mejorar la sincronización del clock en el circuito.







## Generacion del Clk
El clock es el corazón de cualquier sistema digital, proporcionando la señal de sincronización que coordina las operaciones de todos los componentes del sistema. Sin un clock preciso, los componentes no podrían operar de manera armoniosa, lo que resultaría en fallos en el procesamiento de datos.

- **Frecuencia**: La frecuencia del clock determina la velocidad a la que operan los circuitos digitales. Una mayor frecuencia permite realizar más operaciones en menos tiempo, pero también aumenta el consumo de energía y la generación de calor.
- **Fase**: La fase del clock es crucial para la sincronización. Cualquier desajuste en la fase puede causar problemas de timing, conocidos como skew

### Conceptos previos importantes
#### Osciladores de Cuarzo

Un oscilador de cuarzo utiliza las propiedades piezoeléctricas del cuarzo para generar una señal de clock estable y precisa. Cuando se aplica una tensión eléctrica al cristal de cuarzo, este vibra a una frecuencia específica que depende de su corte y dimensiones. Estas vibraciones se convierten en una señal eléctrica periódica que se utiliza como clock.
- **Ventajas**:
    - Alta estabilidad y precisión.
    - Baja deriva de frecuencia a lo largo del tiempo.
    - Buena inmunidad al ruido y a las variaciones de temperatura.
- **Limitaciones**:
    - Limitación en la frecuencia máxima (cientos de MHz).
    - No se pueden ajustar dinámicamente para cambiar la frecuencia.
    - Generar clocks de alta frecuencia (más de cientos de MHz) fuera del chip puede resultar en pérdida de señal debido a las limitaciones físicas y la disipación de energía en las pistas del PCB.

#### Multiplicadores y Divisores de Frecuencia

Los multiplicadores y divisores de frecuencia son circuitos que ajustan la frecuencia del clock generado por el oscilador de cuarzo para adaptarse a las necesidades del sistema digital.

- **Multiplicadores de Frecuencia**: Aumentan la frecuencia del clock. Utilizados cuando se necesita una frecuencia de operación más alta que la proporcionada por el oscilador de cuarzo.
    - **PLL (Phase-Locked Loop)**: Utilizado para multiplicar la frecuencia del clock de referencia.
- **Divisores de Frecuencia**: Reducen la frecuencia del clock. Utilizados cuando se necesita una frecuencia más baja para ciertas partes del circuito.
    - **Divisores de Flip-Flop**: Implementados usando flip-flops tipo T en cascada.
### PLL
![[Pasted image 20240218110031.png]]
Un PLL es un circuito que sincroniza la frecuencia y fase de un oscilador controlado (VCO) con una señal de referencia. Es ampliamente utilizado en sistemas digitales para generar clocks de alta frecuencia a partir de una señal de referencia de baja frecuencia.

- **Phase Detector (PD)**: Detecta la diferencia de fase entre la señal de referencia y la señal de feedback del VCO.
- **Charge Pump (CP)**: Convierte la diferencia de fase detectada en una corriente que ajusta la tensión del VCO.
- **Loop Filter (LF)**: Filtra la señal de la charge pump para suavizar la tensión de control del VCO y reducir el jitter.
- **Voltage-Controlled Oscillator (VCO)**: Genera una señal de frecuencia controlada por la tensión de entrada.
- **Divisor de Frecuencia**: Divide la frecuencia de la señal del VCO para generar la señal de feedback al phase detector. Si no está presente, se utilizan para crear dos relojes con un skew igual a 0, pero además hay este bloque para multiplicar.

![[Pasted image 20240218110045.png]]

- Si se trabaja con pequeñas señales, puede ser linealizado en un entorno de la frecuencia de free running y podemos describir los bloques con una función de transferencia y el PLL se comporta en este caso como un LP de segundo orden 🡪 para pequeñas desviaciones de la condición de enganche.
- El PLL trabaja esencialmente en las fases de las señales que entran.

![[Pasted image 20240218110408.png]]


#### PD detector de fase
Compara la fase de dos señales de entrada y genera una salida proporcional al desfase entre ellas. Con este tipo de circuito no logro saber si el desfase es positivo o negativo. Esto puede funcionar en ciertas circunstancias, pero con un rendimiento limitado, ya que en realidad se está observando un retraso y siempre se puede interpretar como un adelanto. Sin embargo, al trabajar con señales pequeñas, estos desfases suelen ser pequeños en comparación con el valor nominal. Cuando se trabaja con desfases grandes, se pierde la linealidad.
![[Pasted image 20240218111113.png]]


#### Phase-Frequency Detector (PFD):
![[Pasted image 20240218111158.png]]
El Phase-Frequency Detector es una extensión del PD que no solo detecta la diferencia de fase entre las señales de entrada, sino que también puede detectar diferencias en la frecuencia. Esto permite al PFD controlar tanto la fase como la frecuencia del VCO de manera más precisa, lo que resulta en una mejor estabilidad y rapidez en el proceso de sincronización.

El Phase-Frequency Detector (PFD) se implementa como una máquina de estados: 2 registros y una puerta lógica. La salida de los dos Flip-Flops es leída por la puerta lógica en retroalimentación, y la salida de la puerta lógica controla el reset de los dos registros. De esta manera, se puede determinar el signo del desfase, ya que hay dos señales, 'up' y 'down', que controlan la carga de la bomba de carga.





#### Charge Pump (Pompa di Carica):
Detectorde error de la phase de corriente entre 2 segnales .
Puesto que la corriente de la bomba de carga es constante tendremos que la fdt es una constante K del detector de fase.
![[Pasted image 20240218111839.png]]

#### Loop Filter (Filtro di Anello):
![[Pasted image 20240218111933.png]]
El loop filter es un componente crucial en un PLL que se encarga de garantizar la estabilidad del sistema. Se trata de un filtro pasa-bajo que genera una rampa de control para el VCO. El loop filter es fundamental para reducir el jitter del "system clock" y mantener la estabilidad del sistema de control de bucle de fase.

#### Ring-Oscillator VCO (VCO ad Anello di Oscillatore):
El VCO basado en anillo de oscilador es un tipo de oscilador utilizado en la generación de señales de reloj en circuitos integrados. Consiste en una serie de inversores en un bucle de retroalimentación que generan una oscilación. Este tipo de VCO es común en las bibliotecas estándar de tecnologías de fabricación y se utiliza para comparar las prestaciones de diferentes tecnologías.
![[Pasted image 20240218111949.png]]

#### Frequency Divider (Divisore di Frequenza):
El frequency divider es un componente que se utiliza para dividir la frecuencia de una señal de reloj. En un PLL, el frequency divider se emplea en la retroalimentación para multiplicar o dividir la frecuencia del reloj de salida en relación con la señal de referencia. Esto permite ajustar la frecuencia de la señal de salida según los requisitos del sistema.


### PLL como base de distribucion de clk
La distribución del clock utilizando PLL (Phase-Locked Loop) permite que múltiples sistemas digitales reciban señales de clock que están perfectamente sincronizadas en fase. Esto se logra utilizando PLLs como buffers con retardo nulo (zero delay buffers).
![[Pasted image 20240218112133.png]]
#### Funcionamiento

1. **Phase Detector (PD)**: Compara la fase de la señal de referencia con la señal de feedback y genera señales de error ("up" y "down").
2. **Charge Pump (CP)**: Convierte las señales de error en una corriente que ajusta la tensión de entrada del filtro de bucle.
3. **Loop Filter (LF)**: Filtra la señal de la charge pump para estabilizar la tensión de control del VCO.
4. **Voltage-Controlled Oscillator (VCO)**: Genera una señal de clock cuya frecuencia se ajusta en función de la tensión de control.
5. **Clock Driver**: Amplifica la señal de clock para distribuirla al sistema digital.
### PLL como base de la sincronizacion
La sincronización basada en PLL se utiliza para asegurar que la señal de clock en un chip sea perfectamente sincronizada con la señal de clock en otro chip, incluso cuando los datos se transfieren a una frecuencia inferior a la del system clock. Esto es crucial en sistemas donde los datos deben ser transferidos sincrónicamente entre diferentes chips.
![[Pasted image 20240218112213.png]]
#### Funcionamiento

1. **PLL en el Chip 1**: Genera un clock de sistema a partir de un oscilador de cuarzo y un divisor de frecuencia.
2. **Divisor de Frecuencia**: Genera un clock de referencia a partir del clock del sistema para transferir los datos.
3. **Transferencia de Datos**: Los datos se transfieren del Chip 1 al Chip 2 sincrónicamente con el clock de referencia.
4. **PLL en el Chip 2**: Recibe el clock de referencia y lo utiliza para sincronizar su propio clock interno, anulando los efectos del retardo del buffer de clock (de-skewing).

### DLL
La generación de reloj utilizando DLLs (Delay-Locked Loops) es un enfoque alternativo al uso de PLLs (Phase-Locked Loops) para la generación y sincronización de señales de reloj en circuitos integrados.

Un DLL es un circuito similar a un PLL, pero en lugar de ajustar la frecuencia de un VCO, ajusta el retardo de una línea de retardo controlada por tensión para sincronizar la fase de la señal de salida con la señal de entrada.

Un Delay-Locked Loop es un tipo de circuito de control de bucle que se basa en una línea de retardo controlada por voltaje en lugar de un oscilador controlado por voltaje. En un DLL, se busca alinear perfectamente las señales de referencia y de salida (deskewing) ajustando el retardo de la línea de retardo.
#### Diferencias entre PLL y DLL

- **PLL**: Ajusta la frecuencia para sincronizar la fase y puede multiplicar la frecuencia de la señal de referencia.
- **DLL**: Ajusta directamente la fase mediante una línea de retardo y no puede multiplicar la frecuencia de la señal de referencia.

#### Componentes y Funcionamiento del DLL

- **Phase Detector (PD)**: Detecta la diferencia de fase entre la señal de entrada y la señal de salida.
- **Charge Pump (CP)**: Genera una corriente basada en la diferencia de fase.
- **Delay Line**: Una línea de retardo controlada por tensión que ajusta el retardo de la señal de salida para sincronizarla con la señal de entrada.

#### Aplicaciones del DLL en Sistemas Digitales

- **Refaseo del Clock**: Ajuste fino de la fase del clock para minimizar el skew.
- **Sincronización de Datos**: Sincronización de señales de datos en interfaces de alta velocidad.
![[Pasted image 20240218112529.png]]
- No tiene un oscilador controlado por tension
- En condiciones de sincronización, las señales de entrada y salida están perfectamente alineadas en términos de fase (deskewing).
- Los DLLs no permiten la multiplicación de la frecuencia de la señal de referencia, a diferencia de los PLLs.
- Los DLLs son sistemas incondicionalmente estables y tienden a tener un menor jitter en comparación con los PLLs.

### DLL como base de distribucion del clk
![[Pasted image 20240218113511.png]]

## Sincronizacion de sitemas
La correcta sincronización es vital para asegurar que el sistema funcione de manera coherente y confiable, evitando errores de temporización y problemas de estabilidad.
### Tipos de Sistemas

#### Sistemas Sincronos
Los sistemas sincronos operan con un reloj global que coordina el funcionamiento de todos los componentes. Cada elemento del sistema realiza sus operaciones en sincronía con este reloj, lo que permite una coordinación precisa y predecible de las actividades. Estos sistemas son comunes en la mayoría de los circuitos integrados debido a su simplicidad y predictibilidad.

- **Definición y Características**: Un sistema sincrono utiliza un reloj global para sincronizar todas sus operaciones. Esto asegura que todas las partes del sistema trabajen juntas de manera coordinada.
- **Ejemplos de Aplicaciones Comunes**: Microprocesadores, memorias y otros circuitos integrados digitales.

#### Sistemas Asincronos

A diferencia de los sistemas sincronos, los sistemas asincroni no dependen de un reloj global. En su lugar, las operaciones se inician y completan en función de eventos o señales específicas. Esto puede ofrecer ventajas en términos de flexibilidad y eficiencia energética, pero también presenta desafíos significativos en términos de diseño y sincronización.

- **Definición y Características**: Un sistema asincrono opera sin un reloj global, basándose en eventos externos para iniciar y completar operaciones.
- **Ejemplos de Eventos Asincroni**: Entrada desde un teclado, señales de sensores, etc.

### Sincronización de Sistemas

#### Sistemas Globalmente Asincroni-Localmente Sincroni (GALS)
![[Pasted image 20240720102313.png]]

Los sistemas GALS combinan lo mejor de ambos mundos, utilizando relojes locales para sincronizar operaciones dentro de pequeños sub-sistemas, mientras permiten que estos sub-sistemas operen asincrónicamente entre sí. Este enfoque puede mejorar la flexibilidad y la eficiencia energética, a la vez que reduce los problemas de temporización y skew.

- **Definición y Descripción del Funcionamiento**: Los sistemas GALS consisten en varios sub-sistemas sincronos que operan a diferentes frecuencias de reloj, pero se comunican entre sí de manera asincrona. Cada sub-sistema tiene su propio reloj local.
- **Ventajas y Desventajas**: 
  - *Ventajas*: Mayor flexibilidad, eficiencia energética, reducción de problemas de skew.
  - *Desventajas*: Complejidad en el diseño, necesidad de mecanismos de sincronización adicionales.
- **Ejemplos y Aplicaciones**: Sistemas integrados en dispositivos móviles, donde diferentes módulos (como CPU, GPU y módulos de comunicación) operan a distintas frecuencias.

#### Sistema Autotemporizzato

Los sistemas autotemporizzati o self-timed operan sin un reloj global, utilizando señales de completamiento y handshaking para coordinar las operaciones. Este enfoque puede mejorar significativamente la eficiencia energética y reducir el área del chip dedicada a la gestión del reloj, pero requiere una circuitería adicional para manejar los mecanismos de sincronización.

- **Definición y Funcionamiento**: Un sistema autotemporizzato completa sus operaciones basándose en señales de handshaking y completamiento, en lugar de depender de un reloj global.
- **Ventajas y Desventajas**: 
  - *Ventajas*: Ahorro de potencia, reducción del área del chip, mayor tolerancia a variaciones en el proceso y temperatura.
  - *Desventajas*: Necesidad de circuitería adicional, complejidad en el diseño.
- **Ejemplos y Aplicaciones**: Circuitos específicos que requieren alta eficiencia energética y tolerancia a variaciones, como ciertos módulos en sistemas integrados avanzados.


### Problema de la Metastabilidad
La metastabilidad es un estado en el que un flip-flop puede quedar atrapado en una condición intermedia entre un estado lógico alto y uno bajo. Este estado indefinido puede ocurrir cuando el flip-flop recibe una señal de entrada asincrona o cuando los tiempos de configuración y retención no se cumplen adecuadamente. La salida de la metastabilidad es impredecible, tanto en términos de tiempo como de valor lógico, lo que puede causar fallos en el sistema.
![[Pasted image 20240206183721.png]]
#### Modelos de Metastabilidad
- La posibilidad de metaestabilidad cuando tenemos una señal asincronica es 2 veces el tiempo de subida dividida en el periodo
$$P_{\epsilon}=\frac{2t_e}{T}$$
Si el clock varia con nuestra frecuencias: $N=P_{\epsilon}.f_{clk}$
Donde N es MTBF, que es una caracteristica de la calidad de nuestro sistema
$$MTBF=\frac{e^{\frac{t_{m,max}}{\tau}}}{f_{ck}.f_{signal}t_0}$$
![[Pasted image 20240720102715.png]]
Para entender y mitigar la metastabilidad, se utilizan varios modelos matemáticos y físicos. Un modelo común es el modelo de un solo polo para un flip-flop, que describe cómo un flip-flop puede entrar y salir de un estado metastable.
$$v_q(t)=V_M+(v_a(0)-V_M).e^{\frac{t}{\tau}}$$
- **VM**: Tensión de metastabilidad.
- **v(0)**: Valor inicial de la tensión.
- **τ**: Constante de tiempo que varía con las condiciones del proceso y ambientales (como la temperatura).

Existe una franja de valores prohibidos alrededor de $VM$, con una amplitud de $2v_ε$, donde el tiempo para salir de la metastabilidad (tm) excede un valor máximo (tm,max), resultando en un error de sincronización.

Imponiendo $VM = VDD/2$ y $Vq(tm) = VDD$, el modelo predice un tiempo infinito para la salida de la metastabilidad si la entrada vale exactamente VM.

![[Pasted image 20240720103256.png]]
#### Mitigación de la Metastabilidad

Aunque no se puede eliminar completamente el riesgo de metastabilidad, se pueden tomar medidas para reducir su probabilidad y mitigar sus efectos:

- **Uso de Flip-Flops en Cascada**: Colocar dos flip-flops en cascada puede reducir la probabilidad de que la metastabilidad afecte la operación del sistema, a costa de un aumento en la latencia.
- **Aumento del Timing**: Ajustar los tiempos de configuración y retención para acomodar el peor caso de tiempo de salida de la metastabilidad puede ayudar a minimizar su impacto.

### Sincronización de Señales Asincroni

#### 5.1. Flip-Flops como Sincronizadores

Los flip-flops son los bloques de construcción básicos para sincronizar señales asincroni. Se utilizan para capturar y estabilizar señales que llegan en momentos no sincronizados con el reloj del sistema.

- **Uso Básico**: Un flip-flop simple puede sincronizar una señal asincrona al muestrearla en el borde del reloj del sistema.
- **Problemas Potenciales**: La violación de constraints temporales puede llevar a la metastabilidad, donde el flip-flop no puede resolver su salida en un tiempo finito.

#### 5.2. Sincronización en Sistemas GALS

En los sistemas GALS, es esencial utilizar bistabili para la sincronización de señales entre sub-sistemas que operan a diferentes frecuencias de reloj. Este enfoque permite que cada sub-sistema mantenga su propia sincronización local mientras se comunica de manera segura con otros sub-sistemas.

- **Bistabili para Sincronización**: Los bistabili se usan para capturar y sincronizar las señales de entrada que provienen de otros sub-sistemas asincronos.
- **Consideraciones de Timing**: Se debe tener en cuenta un aumento en el retardo tCQ, que es el tiempo que toma para que una señal sea capturada y propagada a través del bistabili.



### 6. Sistemas Auto-temporizzati (Self-timed)

#### 6.1. Principios Básicos

Los sistemas auto-temporizzati, o self-timed, operan sin un reloj global, utilizando en su lugar señales de handshaking y de completamiento para coordinar las operaciones. Esto permite que cada componente del sistema funcione a su propio ritmo, basado en la disponibilidad de datos y la finalización de las tareas anteriores, lo cual puede resultar en una mayor eficiencia energética y un uso más efectivo del área del chip.

- **Separación entre Ordenamiento Lógico y Físico**: Los sistemas auto-temporizzati permiten una clara distinción entre la lógica del circuito y el ordenamiento físico de sus componentes.
- **Consideración del Ritardo como Media**: En lugar de diseñar en función del peor caso de retardo, estos sistemas consideran la media de los retardos, lo cual puede llevar a un diseño más eficiente.
- **Ahorro de Potencia y Área**: Al eliminar la necesidad de un reloj global, se reduce el consumo de energía y el área dedicada a la distribución del reloj en el chip.
- **Circuiteria Adicional para Sincronismo**: Se requiere circuitería adicional para manejar las señales de sincronismo y handshaking.

#### 6.2. Módulo de Ritardo

En los sistemas auto-temporizzati, los módulos de ritardo son cruciales para asegurar que las señales se propaguen correctamente y sin desalineaciones.

- **Portelogiche Fittizie**: Estas puertas lógicas artificiales tienen el mismo retardo crítico que la red lógica y se posicionan cerca de la red para evitar desalineaciones debido a variaciones de temperatura o proceso.

#### 6.3. Ejemplo: Self-Timed Adder

Un ejemplo de sistema auto-temporizzato es un sumador auto-temporizado, que opera de manera eficiente coordinando las operaciones a través de señales de handshaking.

- **Generación Diferencial del Carry**: Este enfoque reduce el tiempo crítico del carry al modificar la cadena de carry de Manchester.
- **Sensing de Corrente para Señal de Completamento**: Utiliza la detección de corriente para generar señales de completamiento, asegurando que las operaciones se completen antes de pasar a la siguiente etapa.
- **Mindelay Generator**: Este componente evita bloqueos en caso de que la lógica no conmute adecuadamente.

### 7. Protocolos Hand-Shaking

#### 7.1. Handshake a Dos Fasi

El protocolo de handshake a dos fases es una técnica de sincronización utilizada para coordinar la comunicación entre un emisor y un receptor mediante señales de solicitud (Req) y reconocimiento (Ack).

- **Configuración Sender-Receiver**: El emisor y el receptor intercambian señales de Req y Ack para iniciar y completar la transferencia de datos.
- **Descripción del Diagrama Temporal**:
  - *Ciclo 1*: El emisor envía una señal de solicitud (Req).
  - *Ciclo 2*: El receptor responde con una señal de reconocimiento (Ack), indicando que ha recibido y procesado la solicitud.

#### 7.2. Handshake a Cuatro Fasi

El protocolo de handshake a cuatro fases utiliza un ciclo de cuatro pasos para sincronizar las operaciones, proporcionando una gestión robusta y flexible de los señales de completamento.

- **Ventajas**: Este protocolo es más robusto y tolerante a fallos, proporcionando una sincronización más fiable en sistemas complejos.
- **Desventajas**: Puede ser más lento y consumir más recursos en comparación con el protocolo de dos fases.

#### 7.3. Ejemplo de FIFO Auto-temporizzato

Un FIFO auto-temporizzato utiliza protocolos de handshake para gestionar la transferencia de datos entre etapas, asegurando que cada etapa esté completa antes de pasar a la siguiente.

- **Indicadores de Pipeline Vacío y Lleno**:
  - *Pipeline Vacío*: Todos los bits son 1 o 0.
  - *Pipeline Lleno*: Los bits alternan entre 1 y 0.

Estos indicadores permiten una gestión eficiente del flujo de datos, asegurando que el sistema opere de manera óptima y sin interrupciones.
