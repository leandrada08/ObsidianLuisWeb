---
cards-deck: Profesional::Universidad::UNISA::Primer Cuatrimestre::Digitali
---

# Italiano


## Sintesi del Progetto #tarjeta-anki 
La sintesi è il processo in cui si traduce la descrizione ad alto livello del progetto (generalmente in un linguaggio di descrizione hardware come Verilog o VHDL) in una rappresentazione a livello di gate o tecnologica. Durante la sintesi, il progetto viene mappato su elementi logici specifici disponibili nella tecnologia di destinazione (come porte logiche, blocchi di memoria, multiplexer, ecc.). Il risultato della sintesi è una netlist, che è una rappresentazione del progetto in termini di connessioni tra elementi logici.
La sintesi in Vivado trasforma il tuo codice RTL (Verilog o VHDL) in una netlist di porte logiche. Questo processo include diversi passaggi chiave:
1. Vivado legge e analizza i file HDL.
2. Il progetto viene ottimizzato per ridurre l'area o migliorare le prestazioni.
3. Il codice RTL viene convertito in primitive specifiche del FPGA.
4. Viene generata una netlist che descrive il progetto in termini di primitive FPGA.
### Analisi dei Risultati della Sintesi
- **Report di Utilizzo delle Risorse:** Fornisce dettagli sull'uso di LUT, FF, BRAM, ecc.
- **Report di Timing:** Mostra la frequenza massima raggiungibile e i percorsi critici.
- **Netlist Generata:** Esamina la netlist sintetizzata nella vista degli schemi.
#### Netlist Generate
- **Netlist Pre-Sintesi (RTL):** Rappresentazione logica del progetto, senza dettagli di implementazione.
- **Netlist Post-Sintesi:** Contiene dettagli delle primitive FPGA assegnate.
^1721659816687


### Osservazioni
- Si possono lanciare N sintesi diverse contemporaneamente senza perdere le precedenti.
- Dalla sintesi possiamo ottenere un'idea delle prestazioni.
	- In caso di non impostare il constraint di tempo non avremo risultati di tempo.
	- In base al [[4. Analisis Estatico de Temporizacion#Creacion de timing constrain]], il sintetizzatore fa una serie di analisi.
		- Di cui devo cercare di soddisfarli, perché se non soddisfiamo i constraint quando sintetizzati, non lo farà quando implementiamo.
- Prima di procedere all'implementazione vogliamo impostare i constraint per posizionare ubicazioni preferenziali (constraint di area), quindi devo fare la sintesi della netlist.
- Pertanto è importante che prima di proseguire realizziamo i *constraint di area e tempo*.




## Implementazione del Progetto #tarjeta-anki 
L'implementazione è il processo in cui si realizza il design fisico del circuito sul chip o dispositivo obiettivo. Durante l'implementazione, si assegna l'utilizzo delle risorse fisiche (come posizionamento delle porte, instradamento delle connessioni, assegnazione dei pin, ecc.). Il risultato dell'implementazione è un design fisico completo pronto per essere fabbricato.
L'implementazione in Vivado trasforma la netlist sintetizzata in una configurazione specifica del FPGA, che include il posizionamento dei componenti e l'instradamento dei segnali. Questo processo ha diversi passaggi chiave:
1. Assegna le celle logiche del progetto a posizioni specifiche nel FPGA.
2. Collega le celle logiche secondo la netlist utilizzando le risorse di instradamento del FPGA.
3. Migliora le prestazioni del progetto regolando il posizionamento e l'instradamento.
#### Analisi dei Risultati dell'Implementazione
- **Report di Utilizzo delle Risorse:** Mostra l'uso di LUT, FF, BRAM, ecc.
- **Report di Timing:** Dettaglia la frequenza massima raggiungibile, i percorsi critici e i margini di tempo.
- **Visualizzazione del Progetto:** Utilizza la vista del progetto in Vivado per vedere il posizionamento e l'instradamento del progetto.
#### Ottimizzazione e Regolazione
- **Uso dei Constraints (XDC):** Regola i vincoli per ottimizzare le prestazioni e l'uso delle risorse.
  - **Timing Constraints:** Definisci vincoli più precisi per regolare il comportamento temporale.
  - **Location Constraints:** Specifica posizioni esatte per componenti critici.
- **Regolazione del Timing:** Utilizza il report di timing per identificare e risolvere problemi di temporizzazione.
^1721659816691





## Generazione di Bitstream e Programmazione #tarjeta-anki 
#### Generazione di Bitstream
La generazione di bitstream converte il progetto implementato in un file binario che può essere caricato nel FPGA.
- **Ottimizzazione del Bitstream:**
  - **Configurazione dei Parametri:** Regola i parametri di generazione del bitstream per ottimizzare le prestazioni e il consumo di energia.
  - **Compressione del Bitstream:** Utilizza opzioni di compressione per ridurre le dimensioni del file bitstream e accelerare la programmazione del FPGA.
#### Verifica e Test su Hardware Reale
- **Verifica Funzionale:**
  - **Test di Input/Output:** Verifica che i segnali di input e output funzionino come previsto.
  - **Test delle Prestazioni:** Misura le prestazioni del progetto per garantire che soddisfi i requisiti specificati.
^1721659816695



## Simulazioni post-sintesi e post implementazione
### Introduzione
- **Simulazione Post-Sintesi:**
  - **Funzionale:** Ignora le informazioni di tempo e rappresenta solo la logica pura del progetto.
  - **Timing:** Include ritardi delle celle ma ignora i ritardi di instradamento.
- **Simulazione Post-Implementazione:**
  - **Funzionale:** Simile alla simulazione funzionale post-sintesi.
  - **Timing:** Considera sia i ritardi delle celle che quelli di instradamento.
- I file SDF vengono utilizzati per annotare le informazioni temporali nelle simulazioni di timing.
- In Vivado, il simulatore può aggiungere automaticamente il file SDF necessario per la simulazione di timing, differenziando così i risultati tra simulazioni funzionali e di timing.
- **Global Set/Reset (GSR):** Nelle simulazioni post-sintesi e post-implementazione, Vivado applica automaticamente un impulso GSR che resetta tutti i registri durante i primi 100 ns.



### Simulazione Post-Sintesi #tarjeta-anki 
#### Simulazione Funzionale
Verificare la funzionalità logica del progetto dopo la sintesi.
- **Configurazione:**
  - Seleziona la simulazione post-sintesi nel pannello di simulazione di Vivado.
  - Assicurati che i file di simulazione e il banco di prova siano correttamente configurati.
- **Esecuzione:**
  - Esegui la simulazione e analizza i risultati per assicurarti che il progetto sintetizzato funzioni come previsto.
#### Simulazione di Timing
Verificare il comportamento temporale del progetto, inclusi i ritardi delle celle.
- **File SDF:** Necessari per annotare le informazioni temporali nella simulazione.
  - **Configurazione:**
    - Assicurati che il file SDF sia generato e associato alla simulazione.
    - Configura la simulazione in Vivado per includere il file SDF.
  - **Esecuzione:**
    - Esegui la simulazione e analizza i risultati per verificare il timing.
#### Errori Principali nel Codice che Funzionano Pre-Sintesi ma Falliscono Post-Sintesi
1. **Blocchi di Non-Procedura:**
   - **Errore:** Uso errato di assegnazioni bloccanti (`=`) invece di non bloccanti (`<=`) in blocchi sequenziali.
   - **Impatto:** Può causare problemi di timing e comportamenti imprevisti.
   - **Soluzione:** Utilizzare sempre assegnazioni non bloccanti (`<=`) in blocchi `always` controllati da eventi di clock.
2. **Problemi di Timing:**
   - **Errore:** Non definire correttamente i vincoli di tempo (clock, input/output delays).
   - **Impatto:** I percorsi critici non vengono rispettati, causando fallimenti di temporizzazione.
   - **Soluzione:** Definire correttamente tutti i vincoli di tempo nei file XDC.
3. **Latch Non Intenzionali:**
   - **Errore:** Uso di if-else incompleto all'interno di blocchi `always`.
   - **Impatto:** Può creare latch non intenzionali che generano comportamenti errati.
   - **Soluzione:** Assicurarsi che tutti i rami di if-else siano completamente specificati o utilizzare `case` con `default`.
4. **Differenze nelle Simulazioni Funzionali e di Timing:**
   - **Errore:** Ignorare i ritardi nella simulazione funzionale, che diventano evidenti nella simulazione di timing.
   - **Impatto:** Le simulazioni funzionali possono passare, ma quelle di timing falliscono.
   - **Soluzione:** Utilizzare simulazioni di timing per rilevare e risolvere problemi relativi ai ritardi.
5. **Multiplexer Non Definiti Chiaramente:**
   - **Errore:** Uso errato di operatori ternari o logica di multiplexer.
   - **Impatto:** Può causare problemi di sintesi e comportamenti imprevisti nella simulazione post-sintesi.
   - **Soluzione:** Definire chiaramente la logica di multiplexer e verificarne il funzionamento nella simulazione pre-sintesi.



### Simulazione Post-Implementazione #tarjeta-anki 
#### Simulazione Funzionale
- **Scopo:** Verificare la funzionalità logica del progetto dopo l'implementazione.
- **Configurazione:**
  - Seleziona la simulazione post-implementazione nel pannello di simulazione di Vivado.
  - Assicurati che i file di simulazione e il banco di prova siano correttamente configurati.
- **Esecuzione:**
  - Esegui la simulazione e analizza i risultati per assicurarti che il progetto implementato funzioni come previsto.
#### Simulazione di Timing
- **Scopo:** Verificare il comportamento temporale del progetto implementato, inclusi i ritardi delle celle e di instradamento.
- **File SDF:** Necessari per annotare le informazioni temporali nella simulazione.
  - **Configurazione:**
    - Assicurati che il file SDF sia generato e associato alla simulazione.
    - Configura la simulazione in Vivado per includere il file SDF.
  - **Esecuzione:**
    - Esegui la simulazione e analizza i risultati per verificare il timing e i possibili problemi di temporizzazione.
^1721659816703



# Español
## Síntesis del Diseño
La síntesis es el proceso en el que se traduce la descripción de alto nivel del diseño (generalmente en un lenguaje de descripción de hardware como Verilog o VHDL) en una representación de nivel de compuerta o tecnológica. Durante la síntesis, el diseño se mapea a elementos lógicos específicos disponibles en la tecnología de destino (como compuertas lógicas, bloques de memoria, multiplexores, etc.). El resultado de la síntesis es una netlist, que es una representación del diseño en términos de conexiones entre elementos lógicos.

La síntesis en Vivado transforma tu código RTL (Verilog o VHDL) en un netlist de puertas lógicas. Este proceso incluye varios pasos clave:
1. Vivado lee y analiza los archivos HDL.
2. Se optimiza el diseño para reducir el área o mejorar el rendimiento.
3. El código RTL se convierte en primitivas específicas del FPGA.
4. Se genera un netlist que describe el diseño en términos de primitivas FPGA.

### Análisis de los Resultados de la Síntesis
- **Informe de Utilización de Recursos:** Proporciona detalles sobre el uso de LUTs, FFs, BRAMs, etc.
- **Informe de Timing:** Muestra la frecuencia máxima alcanzable y los caminos críticos.
- **Netlist Generado:** Examina el netlist sintetizado en la vista de esquemáticos.

#### Netlists Generados
- **Netlist Pre-Síntesis (RTL):** Representación lógica del diseño, sin detalles de implementación.
- **Netlist Post-Síntesis:** Contiene detalles de las primitivas FPGA asignadas.


### Observaciones

- Se pueden lanzar N sintesis diferentes al mismo tiempo sin perder las anteriores
- De la sintesis podemos conseguir una idea de la performance
	- En caso de no meter el constrain de tiempo no tendremos resultados de tiempo
	- En base al [[4. Analisis Estatico de Temporizacion#Creacion de timing constrain]], el sintetizador hace una serie de analisis
		- De los cuales tengo que buscar cumplirlos, ya que si no cumplimos los constrain cuando sintetizados, no lo hara cuando implementemos
- Antes de proceder a la implementacion queremos poner los constrain para colocar ubicaciones preferenciales(Constrain de area), por lo tanto debo hacer la sintesis e la netlist
- Entonces es importante que antes de proseguir realicemos los *constrain de are y tiempo*



## Implementación del Diseño
La implementación es el proceso en el que se realiza el diseño físico del circuito en el chip o dispositivo objetivo. Durante la implementación, se realiza la asignación de recursos físicos (como ubicación de compuertas, enrutamiento de conexiones, asignación de pines, etc.). El resultado de la implementación es un diseño físico completo listo para ser fabricado.

La implementación en Vivado transforma el netlist sintetizado en una configuración específica del FPGA, lo que incluye la colocación de componentes y el ruteo de señales. Este proceso tiene varios pasos clave:
1.  Asigna las celdas lógicas del diseño a ubicaciones específicas en el FPGA.
2. Conecta las celdas lógicas según el netlist utilizando los recursos de ruteo del FPGA.
3.  Mejora el rendimiento del diseño ajustando la colocación y el ruteo.

#### Análisis de los Resultados de Implementación
- **Informe de Utilización de Recursos:** Muestra el uso de LUTs, FFs, BRAMs, etc.
- **Informe de Timing:** Detalla la frecuencia máxima alcanzable, los caminos críticos y los márgenes de tiempo.
- **Visualización del Diseño:** Utiliza la vista de diseño en Vivado para ver la colocación y el ruteo del diseño.

#### Optimización y Ajuste
- **Uso de Constraints (XDC):** Ajusta las restricciones para optimizar el rendimiento y el uso de recursos.
  - **Timing Constraints:** Define restricciones más precisas para ajustar el comportamiento temporal.
  - **Location Constraints:** Especifica ubicaciones exactas para componentes críticos.
- **Ajustes de Timing:** Utiliza el informe de timing para identificar y solucionar problemas de temporización.





## Generación de Bitstream y Programación

#### Generación de Bitstream
La generación de bitstream convierte el diseño implementado en un archivo binario que se puede cargar en el FPGA.
- **Optimización del Bitstream:**
  - **Configuración de Parámetros:** Ajusta los parámetros de generación de bitstream para optimizar el rendimiento y el consumo de energía.
  - **Compresión de Bitstream:** Utiliza opciones de compresión para reducir el tamaño del archivo bitstream y acelerar la programación del FPGA.
#### Verificación y Prueba en Hardware Real
- **Verificación Funcional:**
  - **Pruebas de Entrada/Salida:** Verifica que las señales de entrada y salida funcionen como se espera.
  - **Pruebas de Performance:** Mide el rendimiento del diseño para asegurar que cumple con los requisitos especificados.



## Simulaciones post-sintesis y post implementacion

### Introduccion
- **Simulación Post-Síntesis:**
  - **Funcional:** Ignora la información de tiempo y solo representa la lógica pura del diseño.
  - **Timing:** Incluye retrasos de las celdas pero ignora los retrasos de ruteo.
  
- **Simulación Post-Implementación:**
  - **Funcional:** Similar a la simulación funcional post-síntesis.
  - **Timing:** Considera tanto los retrasos de las celdas como los de ruteo.


- Los archivos SDF se utilizan para anotar la información de tiempos en las simulaciones de timing.
- En Vivado, el simulador puede agregar automáticamente el archivo SDF necesario para la simulación de timing, diferenciando así los resultados entre simulaciones funcionales y de timing.

- **Global Set/Reset (GSR):** En las simulaciones de post-síntesis y post-implementación, Vivado aplica automáticamente un pulso GSR que resetea todos los registros durante los primeros 100 ns.


### Simulación Post-Síntesis

#### Simulación Funcional
Verificar la funcionalidad lógica del diseño después de la síntesis.
- **Configuración:**
  - Selecciona la simulación post-síntesis en el panel de simulación de Vivado.
  - Asegúrate de que los archivos de simulación y el banco de pruebas estén correctamente configurados.
- **Ejecución:**
  - Corre la simulación y analiza los resultados para asegurarte de que el diseño sintetizado funcione como se espera.

#### Simulación de Timing
Verificar el comportamiento temporal del diseño, incluyendo los retrasos de celdas.
- **Archivos SDF:** Necesarios para anotar la información de tiempos en la simulación.
  - **Configuración:**
    - Asegúrate de que el archivo SDF esté generado y asociado con la simulación.
    - Configura la simulación en Vivado para incluir el archivo SDF.
  - **Ejecución:**
    - Corre la simulación y analiza los resultados para verificar el timing.


#### Errores Principales en Código que Funcionan Pre-Síntesis pero Fallan Post-Síntesis
1. **Bloqueos de No-Procedimiento:**
   - **Error:** Uso incorrecto de asignaciones bloqueantes (`=`) en lugar de no bloqueantes (`<=`) en bloques secuenciales.
   - **Impacto:** Puede causar problemas de timing y comportamientos inesperados.
   - **Solución:** Usar siempre asignaciones no bloqueantes (`<=`) en bloques `always` controlados por eventos de reloj.

2. **Problemas de Timing:**
   - **Error:** No definir correctamente las restricciones de tiempo (clock, input/output delays).
   - **Impacto:** Los caminos críticos no se cumplen, causando fallas de temporización.
   - **Solución:** Definir correctamente todas las restricciones de tiempo en los archivos XDC.

3. **Latch No Intencionados:**
   - **Error:** Uso de if-else incompleto dentro de bloques `always`.
   - **Impacto:** Puede crear latches no intencionados que generan comportamientos incorrectos.
   - **Solución:** Asegurarse de que todas las ramas de if-else estén completamente especificadas o usar `case` con `default`.

4. **Diferencias en las Simulaciones Funcionales y de Timing:**
   - **Error:** Ignorar los delays en la simulación funcional, que se hacen evidentes en la simulación de timing.
   - **Impacto:** Las simulaciones funcionales pueden pasar, pero las de timing fallan.
   - **Solución:** Usar simulaciones de timing para detectar y resolver problemas relacionados con los delays.

5. **Multiplexores No Definidos Claramente:**
   - **Error:** Uso incorrecto de operadores ternarios o lógica de multiplexores.
   - **Impacto:** Puede causar problemas de síntesis y comportamientos inesperados en la simulación post-síntesis.
   - **Solución:** Definir claramente la lógica de multiplexores y verificar su funcionamiento en simulación pre-síntesis.


### Simulación Post-Implementación

#### Simulación Funcional
- **Propósito:** Verificar la funcionalidad lógica del diseño después de la implementación.
- **Configuración:**
  - Selecciona la simulación post-implementación en el panel de simulación de Vivado.
  - Asegúrate de que los archivos de simulación y el banco de pruebas estén correctamente configurados.
- **Ejecución:**
  - Corre la simulación y analiza los resultados para asegurarte de que el diseño implementado funcione como se espera.

#### Simulación de Timing
- **Propósito:** Verificar el comportamiento temporal del diseño implementado, incluyendo los retrasos de celdas y ruteo.
- **Archivos SDF:** Necesarios para anotar la información de tiempos en la simulación.
  - **Configuración:**
    - Asegúrate de que el archivo SDF esté generado y asociado con la simulación.
    - Configura la simulación en Vivado para incluir el archivo SDF.
  - **Ejecución:**
    - Corre la simulación y analiza los resultados para verificar el timing y los posibles problemas de temporización.




