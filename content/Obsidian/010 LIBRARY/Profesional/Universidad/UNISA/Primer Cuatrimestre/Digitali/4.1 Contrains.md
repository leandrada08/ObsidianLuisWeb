
# 4.1 Contrains
## Introducción

- **Introduzione**
	- Cosa sono i constraints?
		- Quale tipi di constrains ha?





# Italiano
## Introduzione ai Constraints 
**Constraints**, o vincoli, sono direttive fornite agli strumenti di sintesi e implementazione per guidare il processo di progettazione FPGA. Questi vincoli assicurano che il progetto soddisfi i requisiti funzionali e di prestazione specificati. I constraints sono utilizzati per controllare vari aspetti del progetto, inclusi il comportamento temporale, il posizionamento dei componenti e l'instradamento dei segnali.
**Scopi dei Constraints:**
- **Controllare il Timing:** Assicurare che tutti i segnali soddisfino i requisiti di tempo di setup e hold.
- **Ottimizzare le Prestazioni:** Migliorare la frequenza operativa del progetto ottimizzando i percorsi critici.
- **Garantire l'Integrità del Progetto:** Assicurare che il progetto funzioni correttamente in tutte le condizioni operative previste.
- **Facilitare il Debug:** Identificare e risolvere problemi di timing e posizionamento durante il processo di progettazione.


### Tipi di Constraints in Vivado 
#### Constraints di Tempo
I constraints di tempo definiscono i requisiti temporali del progetto, inclusi le frequenze di clock, i tempi di setup e hold e le eccezioni di timing.
- **create_clock:** Definisce la frequenza e le proprietà del clock.
- **set_input_delay:** Imposta i ritardi di ingresso per garantire il rispetto dei tempi di setup e hold.
- **set_output_delay:** Imposta i ritardi di uscita per garantire il rispetto dei tempi di setup e hold.
- **set_false_path:** Definisce percorsi che non devono essere considerati nell'analisi di timing.
- **set_multicycle_path:** Definisce percorsi che richiedono più cicli di clock per completare il trasferimento dei dati.
#### Constraints di Posizionamento
I constraints di posizionamento controllano la posizione fisica dei componenti nel FPGA. Questi constraints assicurano che i componenti critici siano posizionati in modo ottimale per soddisfare i requisiti di timing e minimizzare i problemi di instradamento.
- **set_property PACKAGE_PIN:** Assegna pin specifici nel FPGA.
- **create_pblock:** Crea blocchi fisici per raggruppare logiche correlate.
- **resize_pblock:** Regola le dimensioni dei blocchi fisici.
- **add_cells_to_pblock:** Aggiunge celle ai blocchi fisici.
- **set_property LOC:** Specifica la posizione dei componenti critici nel FPGA.



## Creazione di Timing Constraints

### Definizione di Clock
Il primo passo nella creazione di constraints di tempo è definire i clock che verranno utilizzati nel progetto. I clock sono essenziali per l'analisi del timing, poiché determinano i cicli di operazione del FPGA.

#### Comando `create_clock`
Il comando `create_clock` viene utilizzato per definire un clock in Vivado. Questo comando specifica il periodo del clock e altre proprietà rilevanti.

**Sintassi Base:**
```tcl
create_clock -period <period> -name <clock_name> [get_ports <port_name>]
```

**Parametri:**
- `-period <period>`: Specifica il periodo del clock in nanosecondi.
- `-name <clock_name>`: Assegna un nome al clock.
- `[get_ports <port_name>]`: Definisce il porto a cui si applica il clock.

**Esempio:**
```tcl
# Definizione di un clock con un periodo di 10 ns
create_clock -period 10.0 -name clk [get_ports clk]
```

#### Esempi Pratici
1. **Definizione di un Clock Base:**
    ```tcl
    create_clock -period 5.0 -name sys_clk [get_ports clk]
    ```
    Questo comando definisce un clock chiamato `sys_clk` con un periodo di 5 ns applicato al porto `clk`.

2. **Definizione di Clock Multipli:**
    ```tcl
    create_clock -period 10.0 -name clk1 [get_ports clk1]
    create_clock -period 20.0 -name clk2 [get_ports clk2]
    ```
    Questo comando definisce due clock, `clk1` con un periodo di 10 ns e `clk2` con un periodo di 20 ns.

### Constraints di Setup e Hold
#### Comando `set_input_delay`
Il comando `set_input_delay` viene utilizzato per definire i ritardi di ingresso. Questo comando assicura che i segnali di ingresso soddisfino i requisiti di tempo di setup e hold.

**Sintassi Base:**
```tcl
set_input_delay -clock <clock> -max <delay> [get_ports <port_name>]
set_input_delay -clock <clock> -min <delay> [get_ports <port_name>]
```

**Parametri:**
- `-clock <clock>`: Specifica il clock associato al segnale di ingresso.
- `-max <delay>`: Definisce il ritardo massimo del segnale di ingresso.
- `-min <delay>`: Definisce il ritardo minimo del segnale di ingresso.
- `[get_ports <port_name>]`: Definisce il porto a cui si applica il ritardo.

**Esempio:**
```tcl
# Definizione dei ritardi di ingresso per il porto input1
set_input_delay -clock clk -max 3.0 [get_ports input1]
set_input_delay -clock clk -min 1.0 [get_ports input1]
```

#### Comando `set_output_delay`
Il comando `set_output_delay` viene utilizzato per definire i ritardi di uscita. Questo comando assicura che i segnali di uscita soddisfino i requisiti di tempo di setup e hold alla destinazione.

**Sintassi Base:**
```tcl
set_output_delay -clock <clock> -max <delay> [get_ports <port_name>]
set_output_delay -clock <clock> -min <delay> [get_ports <port_name>]
```

**Parametri:**
- `-clock <clock>`: Specifica il clock associato al segnale di uscita.
- `-max <delay>`: Definisce il ritardo massimo del segnale di uscita.
- `-min <delay>`: Definisce il ritardo minimo del segnale di uscita.
- `[get_ports <port_name>]`: Definisce il porto a cui si applica il ritardo.

**Esempio:**
```tcl
# Definizione dei ritardi di uscita per il porto output1
set_output_delay -clock clk -max 4.0 [get_ports output1]
set_output_delay -clock clk -min 2.0 [get_ports output1]
```

### Definizione di Eccezioni di Timing

#### Comando `set_false_path`
Il comando `set_false_path` viene utilizzato per definire percorsi che non devono essere considerati nell'analisi di timing. Questi percorsi possono essere ignorati perché non sono critici per il funzionamento del progetto.

**Sintassi Base:**
```tcl
set_false_path -from [get_pins <start_pin>] -to [get_pins <end_pin>]
```

**Parametri:**
- `-from [get_pins <start_pin>]`: Definisce il pin di inizio del percorso falso.
- `-to [get_pins <end_pin>]`: Definisce il pin di destinazione del percorso falso.

**Esempio:**
```tcl
# Definizione di un percorso falso tra due pin
set_false_path -from [get_pins reg1/Q] -to [get_pins reg2/D]
```

#### Comando `set_multicycle_path`
Il comando `set_multicycle_path` viene utilizzato per definire percorsi che richiedono più cicli di clock per completare il trasferimento dei dati. Questo comando permette che l'analisi di timing consideri il numero di cicli di clock specificati.

**Sintassi Base:**
```tcl
set_multicycle_path -setup <cycles> -from [get_pins <start_pin>] -to [get_pins <end_pin>]
set_multicycle_path -hold <cycles> -from [get_pins <start_pin>] -to [get_pins <end_pin>]
```

**Parametri:**
- `-setup <cycles>`: Definisce il numero di cicli di clock per il tempo di setup.
- `-hold <cycles>`: Definisce il numero di cicli di clock per il tempo di hold.
- `-from [get_pins <start_pin>]`: Definisce il pin di inizio del percorso.
- `-to [get_pins <end_pin>]`: Definisce il pin di destinazione del percorso.

**Esempio:**
```tcl
# Definizione di un percorso multicycle con 2 cicli di setup e hold
set_multicycle_path -setup 2 -from [get_pins reg1/Q] -to [get_pins reg2/D]
set_multicycle_path -hold 1 -from [get_pins reg1/Q] -to [get_pins reg2/D]
```

## Creazione di Constraints di Posizionamento

### Fissaggio dei Pin

Fissare i pin

 è essenziale per assicurare che i segnali di ingresso e uscita siano assegnati ai pin fisici corretti del FPGA. Questo è particolarmente importante per assicurare la compatibilità con l'hardware fisico e per soddisfare i requisiti specifici di progettazione.

#### Comando `set_property PACKAGE_PIN`
Il comando `set_property PACKAGE_PIN` viene utilizzato per assegnare pin specifici ai segnali di ingresso e uscita.

**Sintassi Base:**
```tcl
set_property PACKAGE_PIN <pin> [get_ports <port_name>]
set_property IOSTANDARD <standard> [get_ports <port_name>]
```

**Parametri:**
- `<pin>`: Specifica il pin fisico nel FPGA.
- `<port_name>`: Definisce il nome del porto a cui si assegna il pin.
- `<standard>`: Specifica lo standard di I/O (per esempio, LVCMOS33).

**Esempio:**
```tcl
# Fissaggio del pin E3 per il porto del clock con lo standard LVCMOS33
set_property PACKAGE_PIN E3 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
```

### Definizione di Pblocks

I Pblocks (Physical Blocks) sono utilizzati per raggruppare e restringere la logica correlata all'interno di aree specifiche del FPGA. Questo può aiutare a ottimizzare l'instradamento e migliorare le prestazioni di timing.

#### Comando `create_pblock`
Il comando `create_pblock` viene utilizzato per creare un nuovo blocco fisico nel FPGA.

**Sintassi Base:**
```tcl
create_pblock <pblock_name>
```

**Parametri:**
- `<pblock_name>`: Definisce il nome del blocco fisico.

**Esempio:**
```tcl
# Creazione di un nuovo Pblock chiamato pblock_1
create_pblock pblock_1
```

#### Comando `resize_pblock`
Il comando `resize_pblock` viene utilizzato per regolare le dimensioni di un Pblock. Questo comando definisce l'intervallo di posizioni fisiche che copre il Pblock.

**Sintassi Base:**
```tcl
resize_pblock [get_pblocks <pblock_name>] -add {<range>}
```

**Parametri:**
- `<pblock_name>`: Definisce il nome del Pblock.
- `<range>`: Specifica l'intervallo di posizioni fisiche.

**Esempio:**
```tcl
# Ridimensionamento del Pblock pblock_1
resize_pblock [get_pblocks pblock_1] -add {SLICE_X12Y100:SLICE_X15Y105}
```

#### Comando `add_cells_to_pblock`
Il comando `add_cells_to_pblock` viene utilizzato per aggiungere celle specifiche a un Pblock.

**Sintassi Base:**
```tcl
add_cells_to_pblock [get_pblocks <pblock_name>] [get_cells <cell_name>]
```

**Parametri:**
- `<pblock_name>`: Definisce il nome del Pblock.
- `<cell_name>`: Specifica il nome della cella da aggiungere.

**Esempio:**
```tcl
# Aggiunta di celle al Pblock pblock_1
add_cells_to_pblock [get_pblocks pblock_1] [get_cells {u1/u2}]
```

### Posizionamento di Componenti Critici

Il posizionamento di componenti critici è essenziale per ottimizzare le prestazioni di timing e minimizzare i ritardi di instradamento.

#### Comando `set_property LOC`
Il comando `set_property LOC` viene utilizzato per fissare la posizione di componenti specifici nel FPGA.

**Sintassi Base:**
```tcl
set_property LOC <location> [get_cells <cell_name>]
```

**Parametri:**
- `<location>`: Specifica la posizione fisica nel FPGA.
- `<cell_name>`: Definisce il nome della cella da posizionare.

**Esempio:**
```tcl
# Fissaggio della posizione del registro in SLICE_X12Y100
set_property LOC SLICE_X12Y100 [get_cells {critical_path_register}]
set_property BEL A6LUT [get_cells {critical_path_register}]
```

## Regolazione e Ottimizzazione dei Constraints

### Regolazione Basata sui Risultati della Sintesi

Dopo la sintesi, rivedi i rapporti di utilizzo delle risorse e di timing per regolare i constraints e ottimizzare le prestazioni.

#### Analisi dei Risultati
1. **Rapporto di Utilizzo delle Risorse:** Verifica l'uso di LUT, FF, BRAM, DSP, ecc.
2. **Rapporto di Timing:** Rivedi i percorsi critici e i margini di setup e hold.

#### Esempi di Regolazione dei Constraints
- **Ottimizzazione dei Percorsi Critici:**
  ```tcl
  set_multicycle_path -setup 2 -from [get_pins reg1/Q] -to [get_pins reg2/D]
  ```

- **Ridefinizione dei Ritardi di Ingresso:**
  ```tcl
  set_input_delay -clock clk -max 2.5 [get_ports {input1}]
  set_input_delay -clock clk -min 0.5 [get_ports {input1}]
  ```

### Regolazione Basata sui Risultati dell'Implementazione

Dopo l'implementazione, utilizza i rapporti di timing per effettuare ulteriori regolazioni e assicurarti che tutti i percorsi critici soddisfino i requisiti di timing.

#### Analisi dei Risultati
1. **Rapporto di Timing Post-Implementazione:** Rivedi le violazioni di setup e hold e i margini di tempo.
2. **Rapporto di Utilizzo delle Risorse Post-Implementazione:** Verifica che le risorse siano distribuite in modo ottimale.

#### Esempi di Regolazione dei Constraints
- **Fissaggio di Componenti Critici:**
  ```tcl
  set_property LOC SLICE_X10Y100 [get_cells {critical_path_register}]
  ```

- **Assegnazione di Pblocks per Ottimizzare i Percorsi:**
  ```tcl
  create_pblock pblock_critical
  resize_pblock [get_pblocks pblock_critical] -add {SLICE_X10Y100:SLICE_X15Y105}
  add_cells_to_pblock [get_pblocks pblock_critical] [get_cells {critical_logic}]
  ```

### Esempi di Ottimizzazione

1. **Esempio di Regolazione di Multicycle Path:**
   - Originariamente, un percorso critico ha un margine di tempo negativo. Dopo aver analizzato il rapporto di timing, si decide che il percorso può beneficiare di un ciclo di clock aggiuntivo:
   ```tcl
   set_multicycle_path -setup 2 -from [get_pins {u1/clk}] -to [get_pins {u2/data}]
   ```

2. **Esempio di Regolazione dei Constraints di Ingresso/Uscita:**
   - Basato sulla revisione dei tempi di propagazione e dei margini di setup e hold, si regolano i ritardi di ingresso e uscita:
   ```tcl
   set_input_delay -clock clk -max 1.8 [get_ports {input_data}]
   set_input_delay -clock clk -min 0.7 [get_ports {input_data}]
   set_output_delay -clock clk -max 3.5 [get_ports {output_data}]
   set_output_delay -clock clk -min 2.0 [get_ports {output_data}]
   ```


# Español
## Introducción a los Constraints

**Constraints**, o restricciones, son directrices que se proporcionan a las herramientas de síntesis e implementación para guiar el proceso de diseño de FPGA. Estas restricciones aseguran que el diseño cumpla con los requisitos funcionales y de rendimiento especificados. Los constraints se utilizan para controlar diversos aspectos del diseño, incluyendo el comportamiento temporal, la colocación de componentes y la ruteo de señales.

**Propósitos de los Constraints:**
- **Controlar el Timing:** Asegurar que todas las señales cumplan con los requisitos de tiempo de setup y hold.
- **Optimizar el Rendimiento:** Mejorar la frecuencia operativa del diseño mediante la optimización de rutas críticas.
- **Garantizar la Integridad del Diseño:** Asegurar que el diseño funcione correctamente bajo todas las condiciones operativas esperadas.
- **Facilitar la Depuración:** Identificar y solucionar problemas de timing y ubicación durante el proceso de diseño.

### Tipos de Constraints en Vivado
#### Constraints de Tiempo
Los constraints de tiempo definen los requisitos temporales del diseño, incluyendo las frecuencias de reloj, los tiempos de setup y hold, y las excepciones de timing.

- **create_clock:** Define la frecuencia y las propiedades del reloj.
- **set_input_delay:** Establece los retrasos de entrada para asegurar el cumplimiento de los tiempos de setup y hold.
- **set_output_delay:** Establece los retrasos de salida para asegurar el cumplimiento de los tiempos de setup y hold.
- **set_false_path:** Define rutas que no deben ser consideradas en el análisis de timing.
- **set_multicycle_path:** Define rutas que requieren múltiples ciclos de reloj para completar la transferencia de datos.

#### Constraints de Lugar
Los constraints de lugar controlan la ubicación física de los componentes en el FPGA. Estos constraints aseguran que los componentes críticos estén posicionados de manera óptima para cumplir con los requisitos de timing y minimizar los problemas de ruteo.

- **set_property PACKAGE_PIN:** Fija pines específicos en el FPGA.
- **create_pblock:** Crea bloques físicos para agrupar lógica relacionada.
- **resize_pblock:** Ajusta el tamaño de los bloques físicos.
- **add_cells_to_pblock:** Añade celdas a los bloques físicos.
- **set_property LOC:** Especifica la ubicación de componentes críticos en el FPGA.











## Creacion de Timing Constrain

### Definición de Relojes
El primer paso en la creación de constraints de tiempo es definir los relojes que se utilizarán en el diseño. Los relojes son esenciales para el análisis de timing, ya que determinan los ciclos de operación del FPGA.

#### Comando `create_clock`
El comando `create_clock` se utiliza para definir un reloj en Vivado. Este comando especifica el periodo del reloj y otras propiedades relevantes.

**Sintaxis Básica:**
```tcl
create_clock -period <period> -name <clock_name> [get_ports <port_name>]
```

**Parámetros:**
- `-period <period>`: Especifica el periodo del reloj en nanosegundos.
- `-name <clock_name>`: Asigna un nombre al reloj.
- `[get_ports <port_name>]`: Define el puerto al que se aplica el reloj.

**Ejemplo:**
```tcl
# Definición de un reloj con un periodo de 10 ns
create_clock -period 10.0 -name clk [get_ports clk]
```

#### Ejemplos Prácticos
1. **Definición de un Reloj Básico:**
    ```tcl
    create_clock -period 5.0 -name sys_clk [get_ports clk]
    ```
    Este comando define un reloj llamado `sys_clk` con un periodo de 5 ns aplicado al puerto `clk`.

2. **Definición de Múltiples Relojes:**
    ```tcl
    create_clock -period 10.0 -name clk1 [get_ports clk1]
    create_clock -period 20.0 -name clk2 [get_ports clk2]
    ```
    Este comando define dos relojes, `clk1` con un periodo de 10 ns y `clk2` con un periodo de 20 ns.

### 3.2. Constraints de Setup y Hold

#### Comando `set_input_delay`
El comando `set_input_delay` se utiliza para definir los retrasos de entrada. Este comando asegura que las señales de entrada cumplan con los requisitos de tiempo de setup y hold.

**Sintaxis Básica:**
```tcl
set_input_delay -clock <clock> -max <delay> [get_ports <port_name>]
set_input_delay -clock <clock> -min <delay> [get_ports <port_name>]
```

**Parámetros:**
- `-clock <clock>`: Especifica el reloj asociado con la señal de entrada.
- `-max <delay>`: Define el retraso máximo de la señal de entrada.
- `-min <delay>`: Define el retraso mínimo de la señal de entrada.
- `[get_ports <port_name>]`: Define el puerto al que se aplica el retraso.

**Ejemplo:**
```tcl
# Definición de retrasos de entrada para el puerto input1
set_input_delay -clock clk -max 3.0 [get_ports input1]
set_input_delay -clock clk -min 1.0 [get_ports input1]
```

#### Comando `set_output_delay`
El comando `set_output_delay` se utiliza para definir los retrasos de salida. Este comando asegura que las señales de salida cumplan con los requisitos de tiempo de setup y hold en el destino.

**Sintaxis Básica:**
```tcl
set_output_delay -clock <clock> -max <delay> [get_ports <port_name>]
set_output_delay -clock <clock> -min <delay> [get_ports <port_name>]
```

**Parámetros:**
- `-clock <clock>`: Especifica el reloj asociado con la señal de salida.
- `-max <delay>`: Define el retraso máximo de la señal de salida.
- `-min <delay>`: Define el retraso mínimo de la señal de salida.
- `[get_ports <port_name>]`: Define el puerto al que se aplica el retraso.

**Ejemplo:**
```tcl
# Definición de retrasos de salida para el puerto output1
set_output_delay -clock clk -max 4.0 [get_ports output1]
set_output_delay -clock clk -min 2.0 [get_ports output1]
```

### 3.3. Definición de Excepciones de Timing

#### Comando `set_false_path`
El comando `set_false_path` se utiliza para definir rutas que no deben ser consideradas en el análisis de timing. Estas rutas pueden ser ignoradas porque no son críticas para el funcionamiento del diseño.

**Sintaxis Básica:**
```tcl
set_false_path -from [get_pins <start_pin>] -to [get_pins <end_pin>]
```

**Parámetros:**
- `-from [get_pins <start_pin>]`: Define el pin de inicio de la ruta falsa.
- `-to [get_pins <end_pin>]`: Define el pin de destino de la ruta falsa.

**Ejemplo:**
```tcl
# Definición de una ruta falsa entre dos pines
set_false_path -from [get_pins reg1/Q] -to [get_pins reg2/D]
```

#### Comando `set_multicycle_path`
El comando `set_multicycle_path` se utiliza para definir rutas que requieren múltiples ciclos de reloj para completar la transferencia de datos. Este comando permite que el análisis de timing considere el número de ciclos de reloj especificados.

**Sintaxis Básica:**
```tcl
set_multicycle_path -setup <cycles> -from [get_pins <start_pin>] -to [get_pins <end_pin>]
set_multicycle_path -hold <cycles> -from [get_pins <start_pin>] -to [get_pins <end_pin>]
```

**Parámetros:**
- `-setup <cycles>`: Define el número de ciclos de reloj para el tiempo de setup.
- `-hold <cycles>`: Define el número de ciclos de reloj para el tiempo de hold.
- `-from [get_pins <start_pin>]`: Define el pin de inicio de la ruta.
- `-to [get_pins <end_pin>]`: Define el pin de destino de la ruta.

**Ejemplo:**
```tcl
# Definición de una ruta multicycle con 2 ciclos de setup y hold
set_multicycle_path -setup 2 -from [get_pins reg1/Q] -to [get_pins reg2/D]
set_multicycle_path -hold 1 -from [get_pins reg1/Q] -to [get_pins reg2/D]
```

## Creación de Constraints de Lugar

### Fijación de Pines

Fijar los pines es esencial para asegurar que las señales de entrada y salida se asignen a los pines físicos correctos del FPGA. Esto es especialmente importante para asegurar la compatibilidad con el hardware físico y para cumplir con los requisitos de diseño específicos.

#### Comando `set_property PACKAGE_PIN`
El comando `set_property PACKAGE_PIN` se utiliza para asignar pines específicos a las señales de entrada y salida.

**Sintaxis Básica:**
```tcl
set_property PACKAGE_PIN <pin> [get_ports <port_name>]
set_property IOSTANDARD <standard> [get_ports <port_name>]
```

**Parámetros:**
- `<pin>`: Especifica el pin físico en el FPGA.
- `<port_name>`: Define el nombre del puerto al que se asigna el pin.
- `<standard>`: Especifica el estándar de I/O (por ejemplo, LVCMOS33).

**Ejemplo:**
```tcl
# Fijación del pin E3 para el puerto de reloj con el estándar LVCMOS33
set_property PACKAGE_PIN E3 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
```

### Definición de Pblocks

Los Pblocks (Physical Blocks) se utilizan para agrupar y restringir la lógica relacionada dentro de áreas específicas del FPGA. Esto puede ayudar a optimizar el ruteo y mejorar el rendimiento de timing.

#### Comando `create_pblock`
El comando `create_pblock` se utiliza para crear un nuevo bloque físico en el FPGA.

**Sintaxis Básica:**
```tcl
create_pblock <pblock_name>
```

**Parámetros:**
- `<pblock_name>`: Define el nombre del bloque físico.

**Ejemplo:**
```tcl
# Creación de un nuevo Pblock llamado pblock_1
create_pblock pblock_1
```

#### Comando `resize_pblock`
El comando `resize_pblock` se utiliza para ajustar el tamaño de un Pblock. Este comando define el rango de ubicaciones físicas que abarca el Pblock.

**Sintaxis Básica:**
```tcl
resize_pblock [get_pblocks <pblock_name>] -add {<range>}
```

**Parámetros:**
- `<pblock_name>`: Define el nombre del Pblock.
- `<range>`: Especifica el rango de ubicaciones físicas.

**Ejemplo:**
```tcl
# Redimensionamiento del Pblock pblock_1
resize_pblock [get_pblocks pblock_1] -add {SLICE_X12Y100:SLICE_X15Y105}
```

#### Comando `add_cells_to_pblock`
El comando `add_cells_to_pblock` se utiliza para añadir celdas específicas a un Pblock.

**Sintaxis Básica:**
```tcl
add_cells_to_pblock [get_pblocks <pblock_name>] [get_cells <cell_name>]
```

**Parámetros:**
- `<pblock_name>`: Define el nombre del Pblock.
- `<cell_name>`: Especifica el nombre de la celda a añadir.

**Ejemplo:**
```tcl
# Añadir celdas al Pblock pblock_1
add_cells_to_pblock [get_pblocks pblock_1] [get_cells {u1/u2}]
```

### Ubicación de Componentes Críticos

La ubicación de componentes críticos es esencial para optimizar el rendimiento de timing y minimizar los retrasos de ruteo.

#### Comando `set_property LOC`
El comando `set_property LOC` se utiliza para fijar la ubicación de componentes específicos en el FPGA.

**Sintaxis Básica:**
```tcl
set_property LOC <location> [get_cells <cell_name>]
```

**Parámetros:**
- `<location>`: Especifica la ubicación física en el FPGA.
- `<cell_name>`: Define el nombre de la celda a ubicar.

**Ejemplo:**
```tcl
# Fijación de la ubicación del registro en SLICE_X12Y100
set_property LOC SLICE_X12Y100 [get_cells {critical_path_register}]
set_property BEL A6LUT [get_cells {critical_path_register}]
```






## Ajuste y Optimización de Constraints

### Ajuste Basado en Resultados de Síntesis

Después de la síntesis, revisa los informes de utilización de recursos y de timing para ajustar los constraints y optimizar el rendimiento.

#### Análisis de Resultados
1. **Informe de Utilización de Recursos:** Verifica el uso de LUTs, FFs, BRAMs, DSPs, etc.
2. **Informe de Timing:** Revisa las rutas críticas y los márgenes de setup y hold.

#### Ejemplos de Ajuste de Constraints
- **Optimización de Rutas Críticas:**
  ```tcl
  set_multicycle_path -setup 2 -from [get_pins reg1/Q] -to [get_pins reg2/D]
  ```

- **Redefinición de Retrasos de Entrada:**
  ```tcl
  set_input_delay -clock clk -max 2.5 [get_ports {input1}]
  set_input_delay -clock clk -min 0.5 [get_ports {input1}]
  ```

### Ajuste Basado en Resultados de Implementación

Después de la implementación, utiliza los informes de timing para realizar ajustes adicionales y asegurar que todas las rutas críticas cumplan con los requisitos de timing.

#### Análisis de Resultados
1. **Informe de Timing Post-Implementación:** Revisa las violaciones de setup y hold y los márgenes de tiempo.
2. **Informe de Utilización de Recursos Post-Implementación:** Verifica que

 los recursos estén distribuidos de manera óptima.

#### Ejemplos de Ajuste de Constraints
- **Fijación de Componentes Críticos:**
  ```tcl
  set_property LOC SLICE_X10Y100 [get_cells {critical_path_register}]
  ```

- **Asignación de Pblocks para Optimizar Rutas:**
  ```tcl
  create_pblock pblock_critical
  resize_pblock [get_pblocks pblock_critical] -add {SLICE_X10Y100:SLICE_X15Y105}
  add_cells_to_pblock [get_pblocks pblock_critical] [get_cells {critical_logic}]
  ```

### Ejemplos de Optimización

1. **Ejemplo de Ajuste de Multicycle Path:**
   - Originalmente, una ruta crítica tiene un margen de tiempo negativo. Después de analizar el informe de timing, se decide que la ruta puede beneficiarse de un ciclo de reloj adicional:
   ```tcl
   set_multicycle_path -setup 2 -from [get_pins {u1/clk}] -to [get_pins {u2/data}]
   ```

2. **Ejemplo de Ajuste de Constraints de Entrada/Salida:**
   - Basado en la revisión de los tiempos de propagación y los márgenes de setup y hold, se ajustan los retrasos de entrada y salida:
   ```tcl
   set_input_delay -clock clk -max 1.8 [get_ports {input_data}]
   set_input_delay -clock clk -min 0.7 [get_ports {input_data}]
   set_output_delay -clock clk -max 3.5 [get_ports {output_data}]
   set_output_delay -clock clk -min 2.0 [get_ports {output_data}]
   ```







# Puertos para constrain
## La FPGA que usares
- UNISA:Xilinx Artix 7 Sumarry → CMOD 35t
- DDA: Xilinx Artic 35

## UNISA:Xilinx Artix 7 Sumarry

``` Verilog
## This file is a general .xdc for the CmodA7 rev. B
## To use it in a project:
## - uncomment the lines corresponding to used pins
## - rename the used ports (in each line, after get_ports) according to the top level signal names in the project

## 12 MHz Clock Signal
#set_property -dict { PACKAGE_PIN L17   IOSTANDARD LVCMOS33 } [get_ports { sysclk }]; #IO_L12P_T1_MRCC_14 Sch=gclk
#create_clock -add -name sys_clk_pin -period 83.33 -waveform {0 41.66} [get_ports {sysclk}];

## LEDs
#set_property -dict { PACKAGE_PIN A17   IOSTANDARD LVCMOS33 } [get_ports { led[0] }]; #IO_L12N_T1_MRCC_16 Sch=led[1]
#set_property -dict { PACKAGE_PIN C16   IOSTANDARD LVCMOS33 } [get_ports { led[1] }]; #IO_L13P_T2_MRCC_16 Sch=led[2]

## RGB LED
#set_property -dict { PACKAGE_PIN B17   IOSTANDARD LVCMOS33 } [get_ports { ledo_b }]; #IO_L14N_T2_SRCC_16 Sch=led0_b
#set_property -dict { PACKAGE_PIN B16   IOSTANDARD LVCMOS33 } [get_ports { ledo_g }]; #IO_L13N_T2_MRCC_16 Sch=led0_g
#set_property -dict { PACKAGE_PIN C17   IOSTANDARD LVCMOS33 } [get_ports { ledo_r }]; #IO_L14P_T2_SRCC_16 Sch=led0_r

## Buttons
#set_property -dict { PACKAGE_PIN A18   IOSTANDARD LVCMOS33 } [get_ports { btn[0] }]; #IO_L19N_T3_VREF_16 Sch=btn[0]
#set_property -dict { PACKAGE_PIN B18   IOSTANDARD LVCMOS33 } [get_ports { btn[1] }]; #IO_L19P_T3_16 Sch=btn[1]

## Pmod Header JA
#set_property -dict { PACKAGE_PIN G17   IOSTANDARD LVCMOS33 } [get_ports { ja[0] }]; #IO_L5N_T0_D07_14 Sch=ja[1]
#set_property -dict { PACKAGE_PIN G19   IOSTANDARD LVCMOS33 } [get_ports { ja[1] }]; #IO_L4N_T0_D05_14 Sch=ja[2]
#set_property -dict { PACKAGE_PIN H18   IOSTANDARD LVCMOS33 } [get_ports { ja[2] }]; #IO_L9P_T1_DQS_14 Sch=ja[3]
#set_property -dict { PACKAGE_PIN H17   IOSTANDARD LVCMOS33 } [get_ports { ja[3] }]; #IO_L5P_T0_D06_14 Sch=ja[4]
#set_property -dict { PACKAGE_PIN J18   IOSTANDARD LVCMOS33 } [get_ports { ja[4] }]; #IO_L4P_T0_D04_14 Sch=ja[7]
#set_property -dict { PACKAGE_PIN J19   IOSTANDARD LVCMOS33 } [get_ports { ja[5] }]; #IO_L6N_T0_D08_VREF_14 Sch=ja[9]
#set_property -dict { PACKAGE_PIN H19   IOSTANDARD LVCMOS33 } [get_ports { ja[6] }]; #IO_L8P_T1_D12_14 Sch=ja[10]
#set_property -dict { PACKAGE_PIN K18   IOSTANDARD LVCMOS33 } [get_ports { ja[7] }]; #IO_L8N_T1_D12_14 Sch=ja[6]

## Analog XADC Pins
## Only declare these if you want to use pins 15 and 16 as single ended analog inputs. pin 15 -> vaux4, pin16 -> vaux12
#set_property -dict { PACKAGE_PIN G2    IOSTANDARD LVCMOS33 } [get_ports { xa_n[0] }]; #IO_L1N_T0_AD4N_35 Sch=ain[15]
#set_property -dict { PACKAGE_PIN G3    IOSTANDARD LVCMOS33 } [get_ports { xa_p[0] }]; #IO_L1P_T0_AD4P_35 Sch=ain_p[15]
#set_property -dict { PACKAGE_PIN H2    IOSTANDARD LVCMOS33 } [get_ports { xa_n[1] }]; #IO_L2N_T0_AD12N_35 Sch=ain_n[16]
#set_property -dict { PACKAGE_PIN H3    IOSTANDARD LVCMOS33 } [get_ports { xa_p[1] }]; #IO_L2P_T0_AD12P_35 Sch=ain_p[16]

```


## DDA: Xilinx Artic 35
``` Verilog
set_property -dict {PACKAGE_PIN E3 IOSTANDARD LVCMOS18} [get_ports clk]
create_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports clk]

set_property PACKAGE_PIN U18 [get_ports {i_x3[7]}]
set_property PACKAGE_PIN U16 [get_ports {i_x3[6]}]
set_property PACKAGE_PIN V17 [get_ports {i_x3[5]}]
set_property PACKAGE_PIN T11 [get_ports {i_x3[4]}]
set_property PACKAGE_PIN U11 [get_ports {i_x3[3]}]
set_property PACKAGE_PIN U12 [get_ports {i_x3[2]}]
set_property PACKAGE_PIN V12 [get_ports {i_x3[1]}]
set_property PACKAGE_PIN V10 [get_ports {i_x3[0]}]
set_property PACKAGE_PIN V11 [get_ports {i_x2[7]}]
set_property PACKAGE_PIN U14 [get_ports {i_x2[6]}]
set_property PACKAGE_PIN V14 [get_ports {i_x2[5]}]
set_property PACKAGE_PIN T13 [get_ports {i_x2[4]}]
set_property PACKAGE_PIN U13 [get_ports {i_x2[3]}]
set_property PACKAGE_PIN T9 [get_ports {i_x2[2]}]
set_property PACKAGE_PIN T10 [get_ports {i_x2[1]}]
set_property PACKAGE_PIN R10 [get_ports {i_x2[0]}]
set_property PACKAGE_PIN R11 [get_ports {o_y3[7]}]
set_property PACKAGE_PIN K17 [get_ports {o_y3[6]}]
set_property PACKAGE_PIN K18 [get_ports {o_y3[5]}]
set_property PACKAGE_PIN L14 [get_ports {o_y3[4]}]
set_property PACKAGE_PIN M14 [get_ports {o_y3[3]}]
set_property PACKAGE_PIN L15 [get_ports {o_y3[2]}]
set_property PACKAGE_PIN L16 [get_ports {o_y3[1]}]
set_property PACKAGE_PIN L18 [get_ports {o_y3[0]}]
set_property PACKAGE_PIN M18 [get_ports {o_y2[7]}]
set_property PACKAGE_PIN R12 [get_ports {o_y2[6]}]
set_property PACKAGE_PIN R13 [get_ports {o_y2[5]}]
set_property PACKAGE_PIN L13 [get_ports {o_y2[4]}]
set_property PACKAGE_PIN M13 [get_ports {o_y2[3]}]
set_property PACKAGE_PIN R18 [get_ports {o_y2[2]}]
set_property PACKAGE_PIN T18 [get_ports {o_y2[1]}]
set_property PACKAGE_PIN N14 [get_ports {o_y2[0]}]
set_property PACKAGE_PIN P14 [get_ports {o_y1[7]}]
set_property PACKAGE_PIN N17 [get_ports {o_y1[6]}]
set_property PACKAGE_PIN P18 [get_ports {o_y1[5]}]
set_property PACKAGE_PIN M16 [get_ports {o_y1[4]}]
set_property PACKAGE_PIN M17 [get_ports {o_y1[3]}]
set_property PACKAGE_PIN N16 [get_ports {o_y1[2]}]
set_property PACKAGE_PIN P17 [get_ports {o_y1[1]}]
set_property PACKAGE_PIN R17 [get_ports {o_y1[0]}]
set_property PACKAGE_PIN P15 [get_ports {o_y0[7]}]
set_property PACKAGE_PIN R15 [get_ports {o_y0[6]}]
set_property PACKAGE_PIN T14 [get_ports {o_y0[5]}]
set_property PACKAGE_PIN T15 [get_ports {o_y0[4]}]
set_property PACKAGE_PIN R16 [get_ports {o_y0[3]}]
set_property PACKAGE_PIN T16 [get_ports {o_y0[2]}]
set_property PACKAGE_PIN V15 [get_ports {o_y0[1]}]
set_property PACKAGE_PIN V16 [get_ports {o_y0[0]}]
set_property PACKAGE_PIN U17 [get_ports rst_n]




set_property IOSTANDARD LVCMOS18 [get_ports rst_n]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y3[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y2[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y1[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {o_y0[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x1[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {i_x0[0]}]
```


