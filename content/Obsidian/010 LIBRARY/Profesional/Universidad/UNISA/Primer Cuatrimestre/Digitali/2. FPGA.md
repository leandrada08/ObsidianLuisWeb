---
cards-deck: Profesional::Universidad::UNISA::Primer Cuatrimestre::Digitali
---

# 2. FPGA
## Introducción

- **Dispositivi Hardware Programmabili**
	- Quale è la diferenza tra FPGA e ASIC?
		- Ventaggi e desventaggi di ogni uno
	- FPGA vs PLD?
- **FPGA**
	- Cos'è una FPGA?
	- Quale sono le diverse tecnologie con le quale si fabricano le FPGA?
		- Vantaggi e Svantaggi
	- Qual'è la arquitettura basica di una FPGA?
	- Che altri elementi possono essere presenti nella FPGA?
	- Quale sono i componenti logici della FPGA?
		- Descriva ognuno.
- **Altera FPGA**
	- Quale è la arquitettura delle FPGA di Altera?
	- Quale componenti, di solito, sono nelle FPGA di Altera?
	- Come sta fatta la logica configurabile dele FPGA di Altera?
		- È le interconexione?
		- È le memorie?
	- Cos'è e quale sono le modalità di funzionamento delle FPGA di Altera?
- **Xilinx**
	- Quale sono le diverse famiglie di FPGAs di Xilinx?
		- Quale è la differenza tra ognuna
	- Quale è la arquitettura delle FPGA di Xilinx?
	- Quale sono le componenti di questi tipi di FPGA?
	- Como sono le componente di logica, interconexione e memorie?
- **Routing**
	- Come sono le blocco di interconexione nelle FPGA?
		- Come si fa le interconexione in questi blocci?
	- Com'è la implemetazione fisica delle interconexione?
- **Ingressi-Uscite**
	- Quale sono le propieta delle celle di I/O delle FPGA?
	- Come si guida la sincronizacion in questi celle?
- **Eterogenita**
	- Quale sono le diverse tipi di hardware nella FPGA?
	- Quale sono le diverse tipi di Eterogeneità?

# Italiano
## Dispositivi hardware programmabili

### FPGA vs ASIC

- Gli ASIC sono più veloci e più economici quando prodotti in grandi quantità.
- Gli FPGA sono più costosi su larga scala, ma inizialmente sono molto più economici.
- Gli FPGA non sono così veloci come gli ASIC.

| Caratteristica                   | ASIC                                                       | FPGA                                        |
| -------------------------------- | ---------------------------------------------------------- | ------------------------------------------- |
| **Definizione**                  | Circuito integrato progettato per un'applicazione specifica | Circuito integrato programmabile via software |
| **Programmabilità**              | Non programmabile                                          | Programmabile                               |
| **Ciclo di pianificazione**      | Complesso e lungo                                          | Semplice e rapido                           |
| **Costi iniziali**               | Alti                                                       | Bassi                                       |
| **Costi per unità**              | Bassi (su larga scala)                                     | Alti (su larga scala)                       |
| **Spazio e potenza**             | Occupa poco spazio e dissipa poca potenza                  | Occupa più spazio e dissipa più potenza     |
| **Frequenza di funzionamento**   | Alta                                                       | Bassa                                       |
| **Modificabilità**               | Non modificabile                                           | Modificabile in qualsiasi momento           |

#### Applicazioni ASIC vs FPGA 
**ASIC:**
- Produzione di massa
- Applicazioni ad alte prestazioni
- Dispositivi mobili
- Reti


**FPGA:**
- Prototipazione
- Glue logic
- Sistemi commerciali a bassa performance
- Elaborazione parallela
- Applicazioni satellitari (basso volume)
- **Applicazioni per l'immagine:**
    - **Elaborazione dei segnali digitali:** Gli FPGA possono essere utilizzati per elaborare segnali digitali in tempo reale, come nelle applicazioni radar e sonar.
    - **Visione artificiale:** Gli FPGA possono essere utilizzati per elaborare immagini e video in tempo reale, come nelle applicazioni di riconoscimento facciale e rilevamento oggetti.
    - **Calcolo ad alte prestazioni:** Gli FPGA possono essere utilizzati per eseguire calcoli complessi in parallelo, come nelle applicazioni di analisi dei dati e apprendimento automatico.

#### Vantaggi e svantaggi

**Vantaggi degli ASIC:**
- Maggiore velocità
- Minore costo per unità (su larga scala)
- Minore consumo energetico
- Minore dimensione

**Vantaggi degli FPGA:**
- Minore costo iniziale
- Maggiore flessibilità
- Possibilità di riprogrammazione
- Tempo di sviluppo più rapido

**Svantaggi degli ASIC:**
- Alto costo iniziale
- Minore flessibilità
- Non riprogrammabile
- Tempo di sviluppo più lungo

**Svantaggi degli FPGA:**
- Minore velocità
- Maggiore costo per unità (su larga scala)
- Maggiore consumo energetico
- Maggiore dimensione

#### Implementazione

![[Pasted image 20240205200748.png]]

### Classificazione dei circuiti integrati digitali monolitici

![[Pasted image 20230323083304.png]]

- *Normalizzati* significa che il produttore ci fornisce le risorse che li integrano
- *Programmabile* significa che la loro architettura è programmabile
- *Architettura configurabile* significa che con un programma è possibile configurare la loro architettura

#### Normalizzati programmabili ad architettura configurabile

*Granularità fine:* Grande capacità di interconnessione delle risorse logiche, ha interconnessione tra risorse logiche semplici (porte)

*Granularità grossa:* Bassa capacità di interconnessione delle risorse logiche, ha interconnessione tra risorse logiche complesse (grandi blocchi)

![[Pasted image 20230323090216.png]]

Queste risorse di interconnessione collegano diversi blocchi logici configurabili, inoltre possiamo avere blocchi già interconnessi che non necessitano di essere configurati.

#### FPGA vs PLD

![[Pasted image 20230323090353.png|500]]
- FPGA maggiore densità di integrazione
- FPGA implementazione di sistemi più complessi
- La principale differenza è che nei PLD i blocchi sono concentrati mentre negli FPGA sono distribuiti su tutta l'area

## FPGA
### Introduzione FPGA
Un FPGA (Field-Programmable Gate Array) è un tipo di circuito integrato che può essere programmato dopo la fabbricazione per eseguire una varietà di funzioni logiche e di elaborazione dei segnali.
- Quando programmiamo un FPGA stiamo creando hardware, non software, questo è molto importante.
    - La programmazione degli FPGA, alias configurazione, serve per far sì che tutto ciò che è nell'FPGA possa essere configurato per emulare circuiti, quindi hardware.
    - Si può utilizzare l'FPGA per emulare nel processore o in una sua parte e questo processore può a sua volta eseguire un programma. Si può fare e si fa, ma in generale non è così.
- Nell'FPGA tutto viene eseguito in parallelo, a differenza di un microcontrollore dove tutto viene eseguito in serie.
- Definisco le funzionalità, non ho memoria né nulla di fisso, le definisco io.
- *La cosa più importante nel nostro FPGA sono le risorse di interconnessione, con questo si misura la potenza di un FPGA. Le risorse logiche sono importanti ma non tanto.*

Field Programmable Gate Array: ripropone uno schema matriciale di elementi logici programmabili e sono programmabili sul campo, cioè mentre li stiamo utilizzando. Questo termine contrasta con i PLA e PAL che necessitano di un programmatore speciale mentre questi FPGA sono programmabili sul campo. Non è nemmeno necessario il computer: posso realizzare i circuiti che configurano l'FPGA, collocarla in una memoria FLASH che accompagna sempre l'FPGA e fare in modo che all'accensione il contenuto del flash venga caricato automaticamente dall'FPGA.

#### Tipi di architettura
![[Pasted image 20231025101552.png|300]]
- Terrazza
    - Come nell'immagine.
    - Le risorse logiche sono distribuite seguendo terrazze (connessione con metalli differenti [[Layout]])
- Griglia
    - Tutti i blocchi logici sono allo stesso livello, con la stessa importanza
- Mare di porte
    - Sono distribuite su tutto il silicio e le interconnessioni si fanno sotto


### Tecnologia FPGA 
1. **FPGAs basate su SRAM (Static Random-Access Memory):** Questi FPGA utilizzano celle basate su SRAM per memorizzare la configurazione e la logica programmabile. I dispositivi di questa categoria possono essere riconfigurati dinamicamente e sono adatti per applicazioni dove la flessibilità e la riconfigurazione sono importanti. Sono ideali per la prototipazione, lo sviluppo rapido e le applicazioni di elaborazione dei segnali.
2. **FPGAs basate su Antifuse:** Invece di utilizzare SRAM, questi FPGA utilizzano antifuse che vengono programmate una sola volta per configurare la logica. Una volta programmati, i dispositivi sono non volatili e non possono essere riconfigurati. Sono adatti per applicazioni che richiedono alta sicurezza e resistenza alla riprogrammazione non autorizzata.
3. **FPGAs basate su Flash:** Questi FPGA utilizzano tecnologia flash per memorizzare la configurazione. Sono non volatili e possono avviarsi direttamente dalla memoria flash. Spesso vengono utilizzati in applicazioni dove la riprogrammazione è rara, come i sistemi embedded. Sebbene siano più lenti delle SRAM.
4. **FPGAs basate su tecnologie ibride:** Alcuni FPGA utilizzano una combinazione di tecnologie, come SRAM e antifuse, per offrire maggiore flessibilità e sicurezza. Questi dispositivi possono offrire la capacità di riconfigurazione dinamica e la capacità di memorizzare configurazioni permanenti.
![[Pasted image 20231025101333.png|500]]
#### Basate su SRAM
![[Pasted image 20231025102119.png|900]]
Quando si accende un FPGA basato su tecnologia SRAM, il file di configurazione (bitstream) viene caricato nell'FPGA, stabilendo le interconnessioni e la funzionalità delle celle SRAM. Gli ingressi vengono applicati ai pin di ingresso/uscita e i segnali si propagano attraverso la matrice di celle SRAM seguendo le rotte definite nel bitstream. Le celle SRAM agiscono secondo la logica programmata e possono eseguire operazioni logiche, memorizzare dati e altro ancora.
La riconfigurazione di un FPGA implica il caricamento di un nuovo bitstream, che permette di cambiare la sua funzionalità in tempo reale. Questo è particolarmente utile in applicazioni dove la funzionalità dell'hardware deve essere adattata o aggiornata nel tempo.
- Ora gli FPGA basati su SRAM utilizzano tabelle di ricerca (LUT) per implementare funzioni logiche.
- Il bitstream è un file binario che contiene informazioni su come configurare gli elementi dell'FPGA, come la programmazione delle LUT, le interconnessioni, gli ingressi e le uscite. Il bitstream viene caricato nell'FPGA ogni volta che viene accesa o riconfigurata.
384



### Architettura 

![[Pasted image 20240205202101.png]]
Si presenta come una matrice composta da:  
- *Programmable I/O cells (IOB):* celle di ingresso/uscita che devono anche essere configurate I/O Blocks. Possono essere configurate come ingresso o uscita per soddisfare un certo standard di tensione o per dare uscita differenziale o single-ended, per mettere un registro all'interno e poi fare una cattura di tipo sincrono o combinatorio. Il numero di modalità dipende dal tipo di FPGA.
- *Blocchi di configurazione logica (CLB):* elementi logici programmabili. Nuclei della struttura che implementeranno la funzionalità logica, sia combinatoria che sequenziale.
- *Matrice di switch (SM):* permette di programmare le connessioni interne.
#### Altri elementi
![[Pasted image 20240205202111.png]]
- *Risorse di sincronismo:*
    - Risorse che sincronizzano tutti i blocchi logici (clk, reset)
- *Altre risorse:*
    - Memoria
    - Blocco di elaborazione digitale dei segnali
    - Microprocessori
        - Per operazioni semplici e non occupare area in queste operazioni
*Risorse che non ha:*
- Convertitori DA e AD
387



### Componenti logici


#### LUT
##### Funzionamento
Un LUT è una tabella di ricerca utilizzata per implementare funzioni logiche programmabili o per la memorizzazione. Nel contesto di un FPGA, un LUT viene utilizzato per eseguire operazioni logiche in base agli ingressi e generare le uscite corrispondenti.
- Non tutte le LUT possono essere utilizzate come memoria, questo va verificato nella tabella del produttore.
![[Pasted image 20231025103032.png|500]]
1. **Ingressi del LUT:** Un LUT a due ingressi, come suggerisce il nome, ha due ingressi, spesso etichettati come "A" e "B". Questi ingressi possono avere valori logici di 0 o 1.
2. **Tabella di Ricerca:** Il cuore di un LUT è la sua tabella di ricerca. Questa tabella contiene una serie di ingressi e uscite e il suo scopo è definire una funzione logica specifica. Un LUT a due ingressi avrà quattro ingressi nella sua tabella di ricerca, poiché ci sono quattro combinazioni possibili dei valori di ingresso (00, 01, 10 e 11).
3. **Multiplexer (MUX):** La tabella di ricerca è collegata attraverso un multiplexer agli ingressi della cella logica. Il multiplexer si occupa di selezionare la riga corretta della tabella di ricerca in base ai segnali di ingresso.
4. **Uscita (Output):** L'uscita della cella logica è il risultato dell'operazione logica definita dalla tabella di ricerca e dai segnali di ingresso. Questa uscita può essere un segnale logico che viene indirizzato ad altri elementi dell'FPGA.
5. **Flessibilità di Programmazione:** La chiave dei LUT in un FPGA è la loro flessibilità di programmazione. I progettisti possono definire quale funzione logica verrà implementata nel LUT riempiendo la tabella di ricerca con i valori adeguati.
6. **Interconnessioni:** In un FPGA, i LUT sono interconnessi in modo tale che le uscite di un LUT possano essere collegate agli ingressi di altri LUT o elementi logici per costruire circuiti più complessi. Questa interconnessione programmabile è ciò che rende gli FPGA così versatili.
##### Ingressi
- La struttura di un LUT (Lookup Table) si modifica in funzione del numero di ingressi che deve gestire. Ogni ingresso aggiuntivo aumenta significativamente il numero di combinazioni possibili e, di conseguenza, la complessità del LUT.
- Aumentando il numero di ingressi, aumenta anche la versatilità di un LUT, poiché può implementare funzioni logiche più complesse e personalizzate.
###### Granularità
- Il numero di ingressi della tabella di ricerca si chiama *granularità* della tabella di ricerca. Se utilizzo una granularità più alta posso considerare funzioni più complesse, quindi con più variabili. La lookup table deve essere istanziata completamente anche se la funzione che necessito ha solo 2 ingressi. Tieni presente che la lookup table deve sempre essere utilizzata per intero: sia che usi 4, 3 o solo uno degli ingressi disponibili, deve essere completamente istanziata in ogni caso.
    - Problema: se faccio un FPGA pieno di lookup table con granularità 7, ma la maggior parte delle funzioni che uso hanno 4 ingressi, sto usando male il mio spazio.
    - Trade-off: quindi faccio 2 lookup table con granularità 4 e le combino, usando meglio le risorse disponibili. La disponibilità delle risorse è uno degli aspetti più importanti da considerare nella fase di progettazione.
##### Configurazione
- Le tabelle di ricerca nei LUT sono definite mediante il bitstream e configurate dinamicamente nella SRAM durante il processo di configurazione dell'FPGA.
- L'FPGA utilizza le informazioni del bitstream per stabilire la funzionalità dei LUT e degli altri elementi logici in base al progetto dell'utente.
- All'uscita della lookup table c'è sempre almeno un flip-flop, ma con un multiplexer posso prevedere che l'uscita sia combinatoria o sequenziale, oppure potrei optare per utilizzare solo il flip-flop.

![[Pasted image 20231025103435.png|500]]


##### Soluzione di Xilinx per evitare grandi LUT 
Per ovviare a questo, Xilinx prevede una lookup table diversa che si configura in modo più articolato:
- Invece di prevedere una granularità 4, le realizzo come assemblaggio di 2 lookup table con granularità 3, poi metto un multiplexer in uscita e poi le divido in due pezzi.
- Da granularità 4 a granularità 3 sto eliminando un ingresso, quindi riducendo a metà la complessità.
- Una la uso per una funzione e l'altra metà per una funzione diversa. Poi rendo accessibile l'uscita di ABC o metto un altro multiplexer e poi aggiungo anche D.
- Anche se realizzo 2 funzioni diverse, sono comunque due funzioni diverse degli stessi segnali e questo conviene quando ho ABC che serve per fare due funzioni diverse.
![[Pasted image 20231025103336.png]]
391


#### Catena di  carry 
- L'FPGA adotta una struttura sovrapposta.
- La logica di carry permette di interconnettere le diverse LCs attraverso gli slice e i CLB per propagare il carry ad alta velocità.
- Utilizzata in operazioni aritmetiche (addizionatori, sottrattori, comparatori, ecc.)
![[Pasted image 20240205204709.png|300]]
394


#### Block RAM 
- Dispositivi di memorizzazione di diverse dimensioni e porte.
- Sono blocchi dedicati all'interno dell'FPGA per inferire memorie RAM di grande dimensione (in modo più efficiente delle RAM distribuite). Alcuni usi comuni sono:
    - Memorizzazione di grandi lookup table (es. funzioni trigonometriche o matematiche).
    - Memorizzazione di dati provenienti da dispositivi esterni (es. ADC).
    - Memoria RAM di soft-cores.
    - FIFOs per il crossing di domini di clock.
- Normalmente sono raggruppati in colonne all'interno dell'FPGA, per poterli interconnettere in modo efficiente.
- Possono essere configurati per diverse funzionalità:
    - Single port RAM
    - Dual port RAM o FIFO
- Il produttore fornisce una GUI per generarli oppure un template in HDL da istanziare da parte del progettista.
398

![[Pasted image 20240205204743.png]]



#### DSP 
- Struttura che permette di eseguire operazioni aritmetiche e logiche.
- Blocchi destinati alle operazioni aritmetiche: addizionatori, comparatori, moltiplicatori, accumulatori.
- In Xilinx, un blocco DSP48 è costituito da due slice le cui operazioni possono essere interconnesse.
- Ogni DSP slice contiene:
    - Un pre-addizionatore da 25 bit
    - Un moltiplicatore da 25x18 bit (combinando due slice si arriva a 50x36 bit)
    - Un accumulatore da 48 bit (combinando due slice si arriva a 96 bit)
    - Un rilevatore di pattern (comparatore)
    - Operazioni logiche aggiuntive, logica di arrotondamento simmetrico, arrotondamento non simmetrico e saturazione, ecc.
    - Flip-flop con logica di bypass
![[Pasted image 20240205205022.png]]
- Per poterlo utilizzare alla massima velocità bisogna rispettare certi criteri forniti dal produttore.
- Se non li rispettiamo, possiamo comunque utilizzarlo ma a velocità inferiore. Verrà comunque segnalato un avviso di questo.
401


#### Gestori del clock 
- Il clock viene instradato attraverso percorsi speciali all'interno dell'FPGA per ridurre il "clock skew".
- Si formano alberi di clock.
- Un Clock Manager è un blocco dedicato che permette di ricevere un segnale di clock esterno e generare una serie di clock interni con caratteristiche diverse.
- Si basano su PLL (phase-locked loops) o DLL (digital delay-locked loops), a seconda delle esigenze di precisione, stabilità e sensibilità al rumore.
- Integrano divisori e moltiplicatori di clock e logica di monitoraggio per la correzione automatica dello skew nei diversi alberi.
    - Questi limitano le frequenze che possono essere generate in uscita dai gestori del clock.
- Questi gestori del clock ci aiutano anche a mantenere in fase i segnali di clock e a distribuirli in tutto il sistema.
- Esistono anche MMCM che, a differenza dei PLL, permettono di generare uno sfasamento del segnale.
404



## Altera FPGA 
![[Pasted image 20231025112426.png|800]]
**Dimensione dell'FPGA:** Hanno una disposizione a matrice con un numero specifico di colonne e file. In questo caso, si menziona un FPGA della serie EP1S10 con 40 colonne e 30 file. Ogni unità di base è un LAB (Logic Array Block) che contiene 10 LE (Lookup Elements), blocchi di I/O multi-standard, registri, clock e blocchi di RAM integrati nello stesso chip.
- Le LUT sono di granularità 4.
**Organizzazione Gerarchica:** Quando l'FPGA è grande e contiene molti LAB (e, quindi, molte LUT), non è possibile utilizzare un'architettura piana (flatten). Invece, è necessaria un'organizzazione gerarchica dei blocchi per gestire l'interconnessione e la comunicazione tra gli elementi logici.
### Componenti
**DSP (Elaborazione Digitale dei Segnali):** Gli FPGA Stratix includono DSP (Processori di Segnali Digitali) che vengono utilizzati per eseguire operazioni matematiche in virgola mobile, aiutando ad accelerare questo tipo di operazioni. Possono essere configurati in diverse modalità, inclusi moltiplicatori in virgola mobile da 9x9, 18x18 o 36x36.
**Elementi di Ingresso/Uscita:** Gli FPGA Stratix hanno blocchi di ingresso/uscita (I/O blocks). Questi blocchi possono supportare diversi standard di comunicazione, come LVDS, SSTL, ecc.
**Memoria:** Gli FPGA Stratix includono anche blocchi di memoria integrati. Questi blocchi di memoria utilizzano tecnologia SRAM.
### Interconnessioni
**Interconnessione:** Poiché gli FPGA Stratix sono dispositivi di grandi dimensioni, non è possibile avere un'interconnessione piana tra tutti i LE. Invece, utilizzano un'architettura gerarchica di interconnessione. Ciò significa che ci sono diversi livelli di interconnessione, dalle connessioni locali all'interno di un LAB alle interconnessioni globali che collegano diverse parti dell'FPGA. Questa gerarchia aiuta a ottimizzare le rotte di comunicazione ed evitare congestioni.
**Interconnessioni Locali:** Per facilitare la comunicazione efficiente tra i LE, gli FPGA Stratix utilizzano interconnessioni locali che permettono ai LE dello stesso LAB di comunicare direttamente. Ciò si ottiene attraverso collegamenti diretti (Direct Link) che permettono a un LE di pilotare fino a 30 LE vicini, migliorando la velocità di comunicazione.
![[Pasted image 20231025112559.png|500]]
### LE
1. **Catena di Carry (Carry Chain):** Si utilizza per gestire i riporti (carry) nelle operazioni aritmetiche. Le linee dedicate ai carry arrivano alla catena e poi si dirigono verso il bus.
2. **LUT con Granularità 4:** Ogni LE contiene una tabella di ricerca (LUT) con una granularità di 4. Ciò significa che la LUT ha 4 ingressi, utilizzabili per implementare funzioni logiche e aritmetiche.
3. **FSM (Macchina a Stati Finiti):** La FSM si occupa di gestire segnali di controllo, come carica, cancella, configurazione e reset. Si occupa anche della logica per la carica e il reset sincronizzato. Immediatamente dopo la FSM, c'è un flip-flop, simile a quello della LUT. Il flip-flop può essere controllato sia dalla logica di controllo che dai dati provenienti dalla LUT e può indirizzare i dati direttamente all'uscita.
4. **Segnali di Clock e Reset:** Nell'angolo in basso a sinistra, ci sono segnali relativi al clock che influenzano tutta la "fabric" (struttura dell'FPGA). Prima di configurare l'FPGA, viene eseguita un'operazione di reset globale nota come "GLOBAL SET AND RESET". Questo è necessario per garantire uno stato iniziale chiaro e coerente prima della configurazione.
5. **Multiplexer (MUX):** Si utilizzano vari multiplexer per indirizzare le uscite. Questi multiplexer sono un'implementazione hardware di strutture condizionali, permettendo di selezionare tra diverse opzioni di uscita. I multiplexer sono fondamentali per instradare e indirizzare i dati secondo necessità.
![[Pasted image 20231025113708.png|500]]



### Modalità di funzionamento Altera 
**Modalità di Funzionamento:** L'FPGA può operare in diverse modalità, inclusa la modalità normale e la modalità aritmetica dinamica. In modalità normale, si comporta più come un singolo LUT, mentre in modalità aritmetica viene utilizzato per implementare addizionatori, contatori, accumulatori e comparatori. Ciò si ottiene utilizzando una struttura di addizionatore a selezione di carry (carry select adder) e un'organizzazione gerarchica delle LUT.
#### Modalità normale
- In questa modalità, il LUT si comporta in modo simile ai LUT convenzionali visti in lezioni precedenti.
- Il LUT ha quattro possibili ingressi, etichettati come data1, data2, data3 e data4, che possono essere dati esterni o retroalimentazione di altri elementi logici nello stesso LAB (blocco di logica configurabile).
- Viene utilizzato per implementare varie funzioni logiche.
- Il segnale "Cin" viene utilizzato come semplice ingresso.
- Il segnale "Addnsub" viene usato per selezionare tra un'operazione di somma o sottrazione. In questa modalità, è un segnale esterno utilizzato come dato di ingresso nel LUT.
![[Pasted image 20231025112938.png]]
#### Modalità aritmetica dinamica
- In questa modalità, il LUT viene utilizzato per implementare operazioni aritmetiche, come addizionatori, contatori, accumulatori e comparatori.
- Utilizza quattro LUT di 2 ingressi ciascuno per formare un addizionatore di carry select.
- I primi due LUT eseguono somme in base ai segnali "carry_in0" e "carry_in1".
- Gli altri due LUT generano i carry corrispondenti in base a "carry_in0" e "carry_in1".
- Il "lab carry in" selezionerà il carry corretto da utilizzare (carry select).
- La funzione "addnsub" ha l'utilità di negare il segnale "data1" tramite un'operazione XOR, utile nelle operazioni aritmetiche.
410

![[Pasted image 20231025112940.png]]


## Xilinx 
### Famiglie
- *Artix*:
	- Minor consumo
	- Meno risorse
- *Kintex*:
	- Punto intermedio tra artix e virtex
- *Virtex*:
	- Molta area
	- Molto consumo
	- Molte risorse
- *Zynq*:
	- Incorpora microprocessori
![[Pasted image 20240205203654.png|300]]
### Architettura di base
![[Pasted image 20231025113159.png]]
1. **Configurable Logic Blocks (Blocchi di Logica Configurabile, CLB):** In Xilinx si utilizzano i CLB (Configurable Logic Blocks). Questi CLB sono le unità di base della FPGA e contengono vari componenti configurabili. Ogni CLB può avere diverse Look-Up Tables (LUTs) con una granularità di 5. Contengono anche logica di carry, multiplexer e flip-flop.
2. **Interconnessioni Locali:** Le FPGA Xilinx hanno interconnessioni locali che permettono ai CLB di comunicare direttamente tra di loro. I CLB adiacenti si connettono attraverso canali dedicati per accelerare la comunicazione.
3. **Blocchi I/O:** Le FPGA Xilinx hanno anche blocchi di input/output (blocchi I/O). Questi blocchi supportano una varietà di standard di comunicazione.
4. **LUTs e Multiplexer:** Ogni CLB contiene molteplici LUTs con una granularità di 5, il che significa che possono implementare funzioni logiche complesse. Inoltre, i CLB hanno multiplexer (MUX) che vengono utilizzati per instradare e indirizzare i segnali all'interno del blocco.
5. **Modalità Normale e Modalità Aritmetica Dinamica:** Come nelle FPGA Stratix, i CLB di Xilinx possono operare in modalità normale o in modalità aritmetica dinamica.
7. **Moltiplicatori in Punto Fisso (DSP):** Le FPGA Xilinx includono anche DSP (Digital Signal Processors) per operazioni in punto fisso, simile alle FPGA Stratix.
### CLB
![[Pasted image 20240205202422.png]]
- Ogni CLB ha un set slice
- Ogni slice ha celle logiche
- Queste celle logiche hanno un insieme di elementi logici come LUT, catena di carry, strutture che permettono di generare shift register e registri di uscita.
#### CLBs
##### XC300 CLB:
- Ogni CLB (Configurable Logic Block) contiene due flip-flop.
- La LUT ha una granularità di 5, il che significa che ha 2^5 = 32 posizioni possibili nella sua memoria.
- Sebbene abbia 7 ingressi, 5 di dati e 2 di retroazione dai registri, produce solo 2 uscite.
- Le uscite F e G hanno i loro flip-flop dedicati e possono anche combinarsi per produrre un'uscita Y.
- Per la funzione combinatoria, si possono usare 5 ingressi, che possono scambiarsi con Qx, Qy, B e C.
- La limitazione principale è che entrambe le LUT condividono gli stessi ingressi, il che può influenzare gli ingressi usati da F e G a causa della selezione tra Qx e Qy.
![[Pasted image 20231025114222.png|500]]
##### Xilinx 4000 CLB:
- Questo design estende il principio precedente.
- Ora ci sono tre LUT invece di due.
- Le prime due LUT operano su F e G con 4 ingressi, mentre la terza, chiamata H, opera sulle uscite delle prime LUT, oltre a ricevere un ingresso esterno di 4 bit.
- In totale, ci sono 6 ingressi disponibili (1 bit di F, 1 bit di G e 4 bit di H1).
- Puoi usare una singola LUT o dividerle per ottimizzare e ospitare più funzioni all'interno dello stesso CLB.
![[Pasted image 20231025114227.png|500]]
##### CLB Virtex 2 Slice (4 LC) CLB:
- Questi CLB fanno parte della famiglia Virtex 2 e sono organizzati in Slice.
- Ogni Slice contiene due blocchi specchiati chiamati LC (Configurable Logic Cells).
- La Slice contiene LUT con quattro ingressi ciascuna.
- Ogni LC ha un MUX F5 che aggiunge un quinto ingresso e viene indirizzato tramite un segnale Bx.
- Inoltre, esiste un MUX F6 che aggiunge un livello aggiuntivo, selezionato da By.
- Questi multiplexer permettono di implementare funzioni logiche e aritmetiche con 4, 5, 8 o anche 9 ingressi, a seconda della configurazione.
![[Pasted image 20231025114233.png|500]]
413


## Routing 
### Interconnessioni
- Le interconnessioni passano attraverso gli elementi logici e si realizzano tramite canali orizzontali e verticali nella FPGA.
- Nei punti di incrocio, si utilizza una strategia di instradamento che determina come si possono connettere i canali verticali e orizzontali. Questo può essere fatto utilizzando connessioni disgiunte o stile Wilton.
![[Pasted image 20231025114716.png|500]]
![[Pasted image 20231025114739.png|500]]
#### Connessioni Disgiunte:
- Nel metodo delle connessioni disgiunte, si connettono solo i cavi che hanno la stessa numerazione. Cioè, i cavi numerati come 0 si connettono solo ad altri cavi numerati come 0, e i cavi numerati come 1 si connettono solo ad altri cavi numerati come 1, e così via.
- Un segmento che entra in una switch box (scatola di commutazione) può connettersi solo ad altri segmenti all'interno dello stesso dominio numerico.
- Questo limita le connessioni ai cavi che hanno lo stesso numero.
![[Pasted image 20231025114755.png|300]]
#### Stile Wilton:
- Lo stile Wilton è simile alle connessioni disgiunte, ma con maggiore flessibilità. Nel metodo Wilton, un segmento può cambiare dominio numerico in almeno una direzione, il che aumenta la flessibilità di instradamento.
- Sebbene un segmento numerato come 0 normalmente si connetterebbe solo ad altri segmenti numerati come 0, con lo stile Wilton, è possibile assegnare il numero 0 a diverse connessioni in diverse situazioni.
- Per ottenere questo, si utilizza una logica di controllo dedicata a livello di FPGA per cambiare il numero delle interconnessioni. Cambiando il numero di un'interconnessione, è possibile connetterla a diversi cavi.
- Questa flessibilità aggiuntiva consente un maggiore grado di libertà nell'instradamento.
![[Pasted image 20231025114803.png|300]]
### Implementazione fisica:
- Ci sono due metodi comuni per l'implementazione fisica delle interconnessioni:
  - **Modo 1: Porta di Trasmissione:** Si utilizza per decidere se stabilire o meno l'interconnessione. In questo caso, si utilizzano tecnologie TTL (Transistor-Transistor Logic) per garantire che non ci siano cadute di tensione. Se si utilizzano molte porte TTL in serie, possono sorgere problemi di RC (resistenza-capacità) a causa del numero di porte.
  - **Modo 2: Buffer con TTL:** Si usano buffer unidirezionali (tristate) in entrambe le direzioni (sinistra a destra e destra a sinistra) per ripristinare il segnale quando si ha un gran numero di porte TTL in serie. I tristate permettono che il segnale sia trasmesso in una direzione e si fermi nell'altra.
- La scelta tra TTL e buffer dipende dalla lunghezza dell'interconnessione: si preferiscono i TTL per connessioni corte e i buffer con tristate per le connessioni più lunghe, il che evita problemi di degradazione del segnale.
416



## Ingressi e uscite 
- Le celle I/O necessitano della propria alimentazione elettrica poiché devono fornire una certa potenza ai segnali di ingresso o uscita.
- I blocchi IOB permettono di configurare ogni porta come ingresso o uscita.
- Inoltre permettono di connettere o meno Flip Flops per supportare ingressi/uscite sincroni o asincroni.
- Permettono di aggiungere resistori di pull up/down e mappare a diverse tensioni a seconda della tecnologia dei periferici da connettere.
![[Pasted image 20240205210022.png]]
**Modo Differenziale:**
- Nel modo differenziale, il segnale di uscita viene letto tra due pin, noti come coppia differenziale.
### Struttura delle Celle I/O
- Ogni cella I/O ha due percorsi, uno per l'ingresso e uno per l'uscita.
- Nel percorso di uscita, c'è un dispositivo a tre stati (tristate) che viene utilizzato per configurare il pin come ingresso o uscita. Quando il tristate è abilitato e configurato in alta impedenza, il lato sinistro della cella I/O si disconnette e il pin funziona come ingresso.
- I segnali di ingresso possono entrare direttamente come pin combinatori asincroni o possono essere memorizzati in uno o due flip-flop. Questo può causare problemi di asincronia e metastabilità del segnale (vedi angolo in basso a destra della cella I/O).
### Metastabilità e Flip-Flops
- L'asincronia nell'ingresso dei segnali può causare problemi di metastabilità. Quando un segnale arriva in un momento non prevedibile rispetto al funzionamento del flip-flop, può rimanere intrappolato in uno stato indeterminato. Per affrontare questo problema, si possono usare uno o due flip-flop nel percorso di ingresso. Se si utilizzano due flip-flop, il secondo può aiutare a sincronizzare il segnale di ingresso e, sebbene non garantisca di eliminare completamente la metastabilità, riduce la probabilità di problemi significativi.
### Configurazione delle Celle I/O
- Quando il tristate è abilitato in condizioni di bassa impedenza, il pin agisce come un'uscita e si può selezionare quale delle uscite indirizzare al pin di uscita.
- I pin che vengono utilizzati per l'ingresso/uscita dell'utente si chiamano "pin utente", mentre ci sono altri pin riservati per l'alimentazione, l'orologio e altri scopi.



## Eterogeneità
Nelle FPGA moderne, troviamo una miscela di elementi di logica programmabile ("soft logic fabric") e strutture di circuiti specifici ("hard circuit structure"). Ecco una spiegazione dell'eterogeneità nelle FPGA:
**Soft Logic Fabric:**
- Questi sono i blocchi di logica programmabile implementati in elementi di logica come SRAM o multiplexer.
- Questi blocchi sono versatili e possono essere configurati per svolgere varie funzioni logiche.
**Hard Circuit Structure:**
- Sono circuiti specifici progettati per funzioni particolari, come moltiplicatori, unità di elaborazione centrale (CPU), RAM, ecc.
- Sebbene alcune di queste funzioni possano essere emulate nella logica programmabile, vengono implementate come circuiti specifici nell'hardware, il che può aumentare le prestazioni e l'efficienza.
L'eterogeneità nelle FPGA si manifesta in due modi:
**1. Eterogeneità Soffice (Soft):**
- Include blocchi ausiliari che supportano la logica programmabile (ad esempio, flip-flop, logica di carry).
- Questi blocchi soffici fanno parte della logica programmabile, ma hanno uno scopo specifico e non sono così flessibili come altri blocchi programmabili.

**2. Eterogeneità Reale (Hard):**
- Questi sono blocchi completamente indipendenti che svolgono funzioni specifiche e non fanno parte della logica programmabile.
- Spesso, queste funzioni vengono implementate direttamente nell'hardware, come unità di elaborazione o moduli di memoria.

Un esempio di eterogeneità soffice sarebbe l'inclusione di un processore in una FPGA. Inizialmente, i processori esterni si collegavano alla logica programmabile attraverso un bus dedicato in FPGA come Altera Excalibur o Xilinx Virtex. Più tardi, le FPGA moderne hanno incluso processori "duri" (ad esempio, PowerPC in Xilinx) che fanno parte della stessa logica programmabile e sono connessi con altri moduli programmabili.

D'altra parte, i processori "soffici" (come NIOS in Altera o MicroBlaze in Xilinx) sono processori programmati nella logica programmabile della FPGA e sono più lenti rispetto ai processori "duri", ma sono completamente configurabili.

L'eterogeneità permette alle FPGA di combinare logica programmabile con hardware specifico per migliorare le prestazioni e l'efficienza in applicazioni specifiche. Ogni approccio ha i suoi vantaggi e svantaggi, e la scelta dipende dai requisiti dell'applicazione e dagli obiettivi di progettazione. Ad esempio, per applicazioni altamente specializzate, l'inclusione di blocchi hardware specifici può essere più vantaggiosa rispetto all'uso esclusivo della logica programmabile.
# Españól
## Dipositivos de hardware programable
### FPGA vs ASIC 
- Los ASICs son más rápidos y más baratos cuando se fabrican en grandes cantidades.
- Los FPGAs son más caros a gran escala, pero inicialmente son mucho más baratos.
- Los FPGAs no son tan rápidos como los ASICs.

| Característica                   | ASIC                                                       | FPGA                                        |
| -------------------------------- | ---------------------------------------------------------- | ------------------------------------------- |
| **Definición**                   | Circuito integrado diseñado para una aplicación específica | Circuito integrado programable por software |
| **Programabilidad**              | No programable                                             | Programable                                 |
| **Ciclo de planificación**       | Complejo y largo                                           | Simple y rápido                             |
| **Costos iniciales**             | Altos                                                      | Bajos                                       |
| **Costos por unidad**            | Bajos (a gran escala)                                      | Altos (a gran escala)                       |
| **Espacio y potencia**           | Ocupa poco espacio y disipa poca potencia                  | Ocupa más espacio y disipa más potencia     |
| **Frecuencia de funcionamiento** | Alta                                                       | Baja                                        |
| **Modificabilidad**              | No se puede modificar                                      | Se puede modificar en cualquier momento     |
#### Aplicaciones
**ASIC:**
- Producción en masa
- Aplicaciones de alto rendimiento
- Dispositivos móviles
- Redes

**FPGA:**
- Prototipado
- Glue logic
- Sistemas comerciales de baja performance
- Procesamiento en paralelo
- Aplicaciones de satélite (bajo volumen)
- **Aplicaciones de la imagen:**
    - **Procesamiento de señales digitales:** Los FPGAs se pueden usar para procesar señales digitales en tiempo real, como en aplicaciones de radar y sonar.
    - **Visión artificial:** Los FPGAs se pueden usar para procesar imágenes y videos en tiempo real, como en aplicaciones de reconocimiento facial y detección de objetos.
    - **Computación de alto rendimiento:** Los FPGAs se pueden usar para realizar cálculos complejos en paralelo, como en aplicaciones de análisis de datos y aprendizaje automático.
    

#### Ventajas y desventajas
**Ventajas de los ASICs:**
- Mayor velocidad
- Menor costo por unidad (a gran escala)
- Menor consumo de energía
- Menor tamaño

**Ventajas de los FPGAs:**
- Menor costo inicial
- Mayor flexibilidad
- Posibilidad de reprogramar
- Tiempo de desarrollo más rápido

**Desventajas de los ASICs:**
- Alto costo inicial
- Menor flexibilidad
- No se puede reprogramar
- Tiempo de desarrollo más largo

**Desventajas de los FPGAs:**
- Menor velocidad
- Mayor costo por unidad (a gran escala)
- Mayor consumo de energía
- Mayor tamaño

#### Implementacion
![[Pasted image 20240205200748.png]]

### Clasificacion de circuitos integrados digitales monoliticos
![[Pasted image 20230323083304.png]]
- *Normalizados* significa que el fabricante nos da los recursos que lo integran
- *Programable* significa que su arquitectura es programable
- *Arquitectura configurable* significa que con un programa puede configurar su arquitectura

#### Normalizados programables de arquitectura configurable
*Granularidad fina:* Mucha capacidad de interconexion de recursos logicos, tiene interconexion entre recursos logicos simples(compuertas)
*Granularidad gruesa:* Poca capacidad de interconexion de recursos logicos, tiene interconexion entre recursos logicos complejos(grandes bloques)
![[Pasted image 20230323090216.png]]
Estos recursos de interconexion conectan distintos bloques logicos configurables, tambien vemos que podemos tener bloques que ya estan interconectados y no hace falta que los configuremos
#### FPGA vs PLD
![[Pasted image 20230323090353.png|500]]
- FPGA mayor densidad de integracion
- FPGA implementacion sistemas mas complejos
- La principal diferencia es que en PLD estan concentramos los bloques mientras que en la FPGA estan distribuidas en toda el area
## FPGA
### Introduccion FPGA
Una FPGA (Field-Programmable Gate Array) es un tipo de circuito integrado que se puede programar después de su fabricación para realizar una variedad de funciones lógicas y de procesamiento de señales.
- Cuando programamos FPGA estamos haciendo hardware, no software, esto es muy importante
	- La programación de la FPGAs alias configuración sirve para que todo lo que está en la FPGAs pueda ser configurado para emular circuitos por lo tanto del hardware.
	- Se puede utilizar la FPGAs para emular en el procesador o una parte de él y este procesador puede a su vez ejecutar un programa y se puede hacer y se hace pero en general no es así.
- En FPGA todo se ejecuta en paralelo, a diferencia de micro que todo se ejecuta en serie
- Yo defino las funcionalidades, no tengo memoria ni nada fijo, yo las defino
- *Lo mas importante es nuestro FPGA son los recursos de interconexion, con esto se mide la potencia de un FPGA. Los recursos logicos tambien son imporantes pero no tanto*

Field Programmable Gate Array: repropone un esquema matricial de elementos lógicos programables y son programables sobre el terreno, es decir, mientras los estamos utilizando. Este término contrasta con los PLA y PAL que necesitan un programador de aparato especial mientras que estos FPGAs son programables en el campo. Ni siquiera es necesario el ordenador: puedo realizar los circuitos que configuran la FPGA colocarla en una memoria FLASH que acompaña siempre a la FPGAs y hacer que el encendido se lea el contenido del flash se carga automáticamente por la FPGAs.

#### Tipos de arquitectura
![[Pasted image 20231025101552.png|300]]
- Terraza
	- La de la imagen.
	- Los recursos logicos estan distribuido siguiendo terrazas(conexion de con distintos metales [[Layout]])
- Cuadricula
	- Todos los bloques logicos estan en un mismo nivel, en la misma importancia
- Mar de puertas
	-  Estan distribuidos en todo el silicio y las interconexciones se hacer por abajo

### FPGA Technology
1. **FPGAs basadas en SRAM (Static Random-Access Memory):** Estas FPGAs utilizan celdas basadas en SRAM para almacenar la configuración y la lógica programable. Los dispositivos de esta categoría se pueden reconfigurar dinámicamente y son adecuados para aplicaciones donde la flexibilidad y la reconfiguración son importantes. Son ideales para prototipado, desarrollo rápido y aplicaciones de procesamiento de señales.
2. **FPGAs basadas en Antifusibles:** En lugar de utilizar SRAM, estas FPGAs utilizan antifusibles que se programan una sola vez para configurar la lógica. Una vez programados, los dispositivos son no volátiles y no se pueden reconfigurar. Son adecuados para aplicaciones que requieren alta seguridad y resistencia a la reprogramación no autorizada.
3. **FPGAs basadas en Flash:** Estas FPGAs utilizan tecnología flash para almacenar la configuración. Son no volátiles y pueden arrancar directamente desde la memoria flash. A menudo se utilizan en aplicaciones donde la reprogramación es rara, como sistemas embebidos. Aunque son mas lentas que las SRAM
5. **FPGAs basadas en tecnologías híbridas:** Algunas FPGAs utilizan una combinación de tecnologías, como SRAM y antifusibles, para ofrecer una mayor flexibilidad y seguridad. Estos dispositivos pueden ofrecer la capacidad de reconfiguración dinámica y la capacidad de almacenar configuraciones permanentes.

![[Pasted image 20231025101333.png|500]]

#### Basada en SRAM
![[Pasted image 20231025102119.png|900]]
Cuando se enciende una FPGA basada en tecnología SRAM, el archivo de configuración (bitstream) se carga en la FPGA, estableciendo las interconexiones y la funcionalidad de las celdas SRAM. Las entradas se aplican a los pines de entrada/salida, y las señales se propagan a través de la matriz de celdas SRAM siguiendo las rutas definidas en el bitstream. Las celdas SRAM actúan según la lógica programada y pueden realizar operaciones lógicas, almacenar datos y más.
La reconfiguración de una FPGA implica la recarga de un nuevo bitstream, lo que permite cambiar su funcionalidad en tiempo real. Esto es especialmente útil en aplicaciones donde la funcionalidad del hardware debe adaptarse o actualizarse con el tiempo.
- Ahora las FPGA basadas en RAM utilizan tabla de busqueda(LUT) para implementar funciones logicas
- El bitstream es un archivo binario que contiene información sobre cómo deben configurarse los elementos de la FPGA, como la programación de los LUTs, las interconexiones, las entradas y las salidas. El bitstream se carga en la FPGA cada vez que se enciende o reconfigura.







### Arquitectura
![[Pasted image 20240205202101.png]]
Se presenta como una matriz hecha por:  
- *Programmable I/O cells(IOB):* células de entrada de salida que también deben configurarse I/O Blocks. Pueden ser configurados para ser o de entrada salida para cumplir con un cierto estándar de tensión o para dar salida diferencial o single ended, para poner un registro dentro y luego hacer una captura de tipo sincrónico o combinatoria. De cuántas maneras depende del tipo de FPGAs. 
- *Bloques de configuracion logica(CLB):* Elementos lógicos programables. Núcleos de la estructura y que van a implementar la funcionalidad lógica. Combinatoria y secuencial.
- *Matriz de switch(SM):* Permite programar las conexciones internas

#### Otros elementos
![[Pasted image 20240205202111.png]]
- *Recursos de sincronismos*
	- Recursos que sincronizan todos los bloques logicos(clk,reset)
- *Otros recursos:*
	- Memoria
	- Bloque de procesamiento digital de seniales
	- Microprocesadores
		- Para operaciones sencillas y no ocupar area en estas operaciones
*Recursos que no tiene:*
- Conversores DA y AD



### Componentes logicos
#### LUT
##### Funcionamiento
Un LUT es una tabla de búsqueda que se utiliza para implementar funciones lógicas programables o para almacenamiento. En el contexto de una FPGA, un LUT se utiliza para realizar operaciones lógicas en función de las entradas y generar las salidas correspondientes. 
- No todas las LUT pueden ser utilizadas como almacenamiento, esto hay que ver en la tabla del fabricante


![[Pasted image 20231025103032.png|500]]
1. **Entradas del LUT:** Un LUT de dos entradas, como su nombre lo indica, tiene dos entradas, a menudo etiquetadas como "A" y "B". Estas entradas pueden tener valores lógicos de 0 o 1.
2. **Tabla de Búsqueda:** El corazón de un LUT es su tabla de búsqueda. Esta tabla contiene una serie de entradas y salidas, y su propósito es definir una función lógica específica. Un LUT de dos entradas tendrá cuatro entradas en su tabla de búsqueda, ya que hay cuatro combinaciones posibles de los valores de entrada (00, 01, 10 y 11).
3. **Multiplexor (MUX):** La tabla de búsqueda está conectada a través de un multiplexor a las entradas de la celda lógica. El multiplexor se encarga de seleccionar la fila correcta de la tabla de búsqueda en función de las señales de entrada.
4. **Salida (Output):** La salida de la celda lógica es el resultado de la operación lógica definida por la tabla de búsqueda y las señales de entrada. Esta salida puede ser una señal lógica que se dirige a otros elementos de la FPGA.
5. **Flexibilidad de Programación:** La clave de los LUTs en una FPGA es su flexibilidad de programación. Los diseñadores pueden definir qué función lógica se implementará en el LUT rellenando la tabla de búsqueda con los valores adecuados.
6. **Interconexiones:** En una FPGA, los LUTs están interconectados de manera que las salidas de un LUT se pueden conectar a las entradas de otros LUTs o elementos lógicos para construir circuitos más complejos. Esta interconexión programable es lo que hace que las FPGA sean tan versátiles.

##### Entradas
- La estructura de un LUT (Lookup Table) se modifica en función de la cantidad de entradas que tiene que manejar. Cada entrada adicional aumenta significativamente el número de combinaciones posibles y, por lo tanto, la complejidad del LUT.
- A medida que aumenta el número de entradas, la versatilidad de un LUT también aumenta, ya que puede implementar funciones lógicas más complejas y personalizadas.
###### Granularidad
- El número de entradas de la tabla de aspecto se llama *granularidad* de la tabla de aspecto. Si utilizo una granularidad más alta puedo considerar funciones más complejas entonces con más variables. La look up table se debe instanciar por completo aunque la función que necesito solo tiene 2 entradas. Tenga en cuenta que el look up table siempre debe usarse en su totalidad: ya sea que use 4 3 o solo una de las disponibles, debe instantánearse completamente de todos modos. 
	- Problema: si yo hago una FPGA llena de look up table de granularidad 7, pero la mayor parte de las funciones que uso son de 4 entradas estoy usando mal mi espacio. 
	- Trade off: entonces hago 2 con granularidad 4 y las combino y así las uso todas tantas y mejor los recursos que tengo. La disponibilidad de recursos es uno de los aspectos más importantes a utilizar en la fase de diseño.

##### Configuracion
- Las tablas de búsqueda en los LUTs se definen mediante el bitstream y se configuran dinámicamente en la SRAM durante el proceso de configuración de la FPGA. 
- La FPGA utiliza la información del bitstream para establecer la funcionalidad de los LUTs y otros elementos lógicos en función del diseño del usuario. 
- En la salida de la tabla de look up siempre hay al menos 1 flip flop pero en realidad con un multiplexer puedo prever que la salida sea combinatoria o secuencial o bien podría optar por utilizar solo el FLIP FLOP
![[Pasted image 20231025103435.png|500]]

##### Solucion de Xilinx para evitar grandes LUT
Para obviar esto Xilinx prevé especialmente una look up table diferente que se configura de manera un poco más articulada: 
- En vez de prever granularidad 4 las realizo como ensamblaje de 2 look uo table con granularidad 3 y luego pongo un multiplexor en salida y luego divido en dos piezas. 
- De granularidad 4 a granularidad 3 estoy eliminando una entrada por lo tanto reduciendo a la mitad la complejidad.
- Una la uso para una función y para la otra mitad función diferente. Luego hago accesible la salida de abc o pongo otro multiplexor y luego también pongo d. 
- Aunque realizo 2 funciones diferentes son dos funciones diferentes de los mismos senales y esto conviene cuando tiene abc que sirve para hacer dos funciones diferentes
![[Pasted image 20231025103336.png]]







#### Cadena de acarreo
- La FPGA plantea una estructura superpuesta
- La lógica de carry permite interconectar las diferentes LCs a través de los slices y CLBs para propagar el carry con alta velocidad.
- Empleado en operaciones aritméticas (sumadores, restadores, comparadores, etc.)
![[Pasted image 20240205204709.png|300]]
#### Block RAM
- Dispositivos de almacenamiento de distinta cantidad de puertos
- Son bloques dedicados dentro de la FPGA para inferir memorias RAM de gran tamaño (de forma más eficiente que las RAM distribuidas). Algunos usos comunes son:
	- Almacenamiento de grandes Look-up tables (ej. funciones trigonométricas o matemáticas).
	- Almacenamiento de datos provenientes de dispositivos externos (ej. ADC).
	- Memoria RAM de soft-cores.
	- FIFOs de cruce de dominio de clocks.
- Normalmente vienen agrupadas en columnas dentro de la FPGA, para poder interconectarlas eficientemente.
- Pueden ser configuradas para diferentes funcionalidades:
	- Single port RAM
	- Dual port RAM o FIFO
- El fabricante provee una GUI para generalas o bien un template en HDL para ser instanciado por el diseñador.
![[Pasted image 20240205204743.png]]

#### DSP
- Estructura que te permite realizar operaciones aritmeticas y logicas.
- Bloques destinados a operaciones aritméticas: sumadores, comparadores, multiplicadores, acumuladores.
- En Xilinx, un bloque DSP48 se constituye de dos slices cuyas operaciones pueden interconectarse.
- Cada DSP slice contiene:
	- Un pre-sumador de 25 bits
	- Un multiplicador de 25x18 bits (combinando dos slices se puede llegar a 50x36 bits)
	- Un acumulador de 48 bits (combinando dos slices se puede llegar a 96 bits)
	- Un detector de patrón (comparador)
	- Operaciones lógicas adicionales, lógica de redondeo simétrico, redondeo no simétrico y saturación, etc.
	- Flip flops con lógica de bypass

![[Pasted image 20240205205022.png]]
- Para poder usarlo a la maxima velocidad hay que cumplir ciertos criterios dados por el fabricante
- Si no cumplimos, lo mismo podemos utilizarlo aunque a menos veloidad. Tambien nos saldra un aviso de esto

#### Manejadores de reloj
- El clock se routea por caminos especiales dentro de la FPGA para reducir el “clock skew”.
- Se forman árboles de clock.
- Un Clock Manager es un bloque dedicado que permiten recibir una señal de clock externa y generar una serie de clocks internos con diferentes características.
- Se basan en PLLs (pase-locked loops) o DLLs (digital delay-locked loops), de a cuerdo a requerimientos de precisión, estabilidad y sensibilidad al ruido.
- Integran divisores y multiplicadores de clock y lógica de monitoreo para corrección automática de skew en los diferentes árboles.
	- Estos limitan las frecuencias que se pueden generar a la salida de los manejadores de reloj
- Estos manejadores de reloj tambien nos ayuda a tener en fase las señales de reloj y distribuirlo por todo el sistema
- Tambien existen MMCM que a diferencia de PLL nos permite generar un corrimiento de fase de la señal

## Altera FPGA
![[Pasted image 20231025112426.png|800]]
**Tamaño de la FPGA:** Tienen una disposición en forma de matriz con un número específico de columnas y filas. En este caso, se menciona una FPGA de la serie EP1S10 con 40 columnas y 30 filas. Cada unidad básica es un LAB (Logic Array Block) que contiene 10 LE (Lookup Elements), bloques de E/S multieestándar, registros, reloj y bloques de RAM integrados en el mismo chip.
- La LUT son de granularidad 4
**Organización Jerárquica:** Cuando la FPGA es grande y contiene muchos LAB (y, por lo tanto, muchas LUT), no es posible utilizar una arquitectura plana (flattern). En cambio, se requiere una organización jerárquica de los bloques para gestionar la interconexión y la comunicación entre los elementos lógicos.
### Componentes
**DSP (Procesamiento Digital de Señales):** Las FPGA Stratix incluyen DSP (Procesadores de Señal Digital) que se utilizan para realizar operaciones matemáticas en punto flotante, esto ayuda a acelerar este tipo de operaciones. Pueden configurarse de diferentes maneras, incluyendo multiplicadores en punto flotante de 9x9, 18x18 o 36x36.
**Elementos de Entrada/Salida:** Las FPGA Stratix tienen bloques de entrada/salida (I/O blocks). Estos bloques pueden admitir diferentes estándares de comunicación, como LVDS, SSTL, etc.
**Memoria:** Las FPGA Stratix también incluyen bloques de memoria integrados. Estos bloques de memoria utilizan tecnología SRAM 

### Interconexiones
**Interconexión:** Dado que las FPGA Stratix son dispositivos de gran tamaño, no es posible tener una interconexión plana entre todos los LE. En lugar de eso, utilizan una arquitectura jerárquica de interconexión. Esto significa que hay varios niveles de interconexión, desde conexiones locales dentro de un LAB hasta interconexiones globales que conectan diferentes partes de la FPGA. Esta jerarquía ayuda a optimizar las rutas de comunicación y evitar congestiones.
**Interconexiones Locales:** Para facilitar la comunicación eficiente entre los LE, las FPGA Stratix utilizan interconexiones locales que permiten que los LE del mismo LAB se comuniquen directamente. Esto se logra a través de enlaces directos (Direct Link) que permiten a un LE pilotar hasta 30 LE cercanos, lo que mejora la velocidad de comunicación.
![[Pasted image 20231025112559.png|500]]

### LE


1. **Cadena de Carry (Carry Chain):** Se utiliza para gestionar los riporti (carries) en operaciones aritméticas. Las líneas dedicadas para los carries llegan a la cadena y luego se dirigen hacia el bus.

2. **LUT con Granularidad 4:** Cada LE contiene una tabla de búsqueda (LUT) con una granularidad de 4. Esto significa que la LUT tiene 4 entradas, que pueden utilizarse para implementar funciones lógicas y aritméticas.

3. **FSM (Máquina de Estados Finitos):** La FSM se encarga de gestionar señales de control, como carga, borrado, configuración y reinicio. También se encarga de la lógica para la carga y el borrado sincronizado. Inmediatamente después de la FSM, se encuentra un Flip-Flop, similar al de la LUT. El Flip-Flop puede ser controlado tanto por la lógica de control como por datos provenientes de la LUT y puede direccionar el dato directamente a la salida.

4. **Señales de Reloj y Reset:** En la esquina inferior izquierda, se encuentran señales relacionadas con el reloj que afectan a toda la "fabric" (estructura de la FPGA). Antes de configurar la FPGA, se realiza una operación de reset global conocida como "GLOBAL SET AND RESET." Esto es necesario para asegurar un estado inicial claro y consistente antes de la configuración.

5. **Multiplexores (MUX):** Se utilizan múltiples multiplexores para direccionar las salidas. Estos multiplexores son una implementación de hardware de estructuras condicionales, lo que significa que permiten seleccionar entre varias opciones de salida. Los multiplexores son fundamentales para enrutar y direccionar los datos según sea necesario.
![[Pasted image 20231025113708.png|500]]


### Modos de funcionamiento
**Modos de Funcionamiento:** La FPGA puede operar en diferentes modos, incluyendo el modo normal y el modo de aritmética dinámica. En el modo normal, se asemeja más a una LUT individual, mientras que en el modo de aritmética se utiliza para implementar sumadores, contadores, acumuladores y comparadores.Esto se logra utilizando una estructura de sumador de selección de acarreo (carry select adder) y una organización jerárquica de las LUT.

#### Modo normal
- En este modo, el LUT se comporta de manera similar a las LUT convencionales vistas en lecciones anteriores.
- El LUT tiene cuatro posibles entradas, etiquetadas como dato1, dato2, dato3 y dato4, que pueden ser datos externos o retroalimentación de otros elementos lógicos en el mismo LAB (bloque de lógica configurable).
- Se utiliza para implementar diversas funciones lógicas.
- La señal "Cin" se utiliza como una entrada simple.
- La señal "Addnsub" se usa para seleccionar entre una operación de suma o resta. En este modo, es una señal externa que se utiliza como dato de entrada en el LUT
![[Pasted image 20231025112938.png]]
#### Modo aritmedico dinamico
- En este modo, el LUT se utiliza para implementar operaciones aritméticas, como sumadores, contadores, acumuladores y comparadores.
- Utiliza cuatro LUT de 2 entradas cada uno para formar un sumador de carry select.
- Los dos primeros LUT realizan sumas con base en las señales "carry_in0" y "carry_in1".
- Los otros dos LUT generan los carries correspondientes basados en "carry_in0" y "carry_in1".
- El "lab carry in" seleccionará el carry correcto para utilizar (carry select).
- La función "addnsub" tiene la utilidad de negar la señal "data1" a través de una operación XOR, lo que es útil en operaciones aritméticas.
![[Pasted image 20231025112940.png]]





## Xilinx
### Familias
- *Artix*:
	- Menor consumo tiene
	- Menos recursos tiene
- *Kintex*:
	- Punto intermedio entre artix y virtex
- *Virtex*:
	- Muchas area
	- Mucho consumo
	- Muchos recursos
- *Zynq*:
	- Incorpora microprocesadores

![[Pasted image 20240205203654.png|300]]
### Arquitectura basica
![[Pasted image 20231025113159.png]]

1. **Configurable Logic Blocks (Bloques de Lógica Configurable, CLB):** En Xilinx se utilizan CLBs (Configurable Logic Blocks). Estos CLBs son las unidades básicas de la FPGA y contienen múltiples componentes configurables. Cada CLB puede tener varias Look-Up Tables (LUTs) con una granularidad de 5. Tambien contienen logica de carry, multiplexores y flip flops.
2. **Interconexiones Locales:** Las FPGA Xilinx tienen interconexiones locales que permiten a los CLBs comunicarse directamente entre sí. Los CLBs adyacentes se conectan a través de canales dedicados para acelerar la comunicación.
3. **I/O Blocks:** Las FPGA Xilinx también tienen bloques de entrada/salida (I/O blocks). Estos bloques admiten una variedad de estándares de comunicación.
4. **LUTs y Multiplexadores:** Cada CLB contiene múltiples LUTs con una granularidad de 5, lo que significa que pueden implementar funciones lógicas complejas. Además, los CLBs tienen multiplexadores (MUX) que se utilizan para enrutar y direccionar las señales dentro del bloque.
5. **Modo Normal y Modo Aritmético Dinámico:** Al igual que en las FPGA Stratix, los CLBs de Xilinx pueden operar en modo normal o en modo aritmético dinámico.
7. **Multiplicadores en Punto Flotante (DSP):** Las FPGA Xilinx también incluyen DSP (Procesadores de Señal Digital) para operaciones en punto flotante, similar a las FPGA Stratix.


### CLB
![[Pasted image 20240205202422.png]]
- Cada CLB tiene un conjunto slice 
- Cada slice tiene celdas logicas
- Estas celdas logicas tienen un conjunto de elementos logicos como LUT, cadena de acarreo, estructuras que te permiten generar shift register y registros de salida.

#### CLBs
##### XC300 CLB:
- Cada CLB (Configurable Logic Block) contiene dos flip-flops.
- La LUT tiene una granularidad de 5, lo que significa que tiene 2^5 = 32 ubicaciones posibles en su memoria.
- Aunque tiene 7 entradas, 5 de datos y 2 de retroalimentación desde los registros, solo produce 2 salidas.
- Las salidas F y G tienen sus propios flip-flops dedicados, y también pueden combinarse para producir una salida Y.
- Para la función combinacional, se pueden usar 5 entradas, que pueden intercambiarse con Qx, Qy, B y C.
- La limitación principal radica en que ambas LUT comparten las mismas entradas, lo que puede afectar las entradas utilizadas por F y G debido a la selección entre Qx y Qy.
![[Pasted image 20231025114222.png|500]]
##### Xilinx 4000 CLB:
- Este diseño extiende el principio anterior.
- Ahora, hay tres LUT en lugar de dos.
- Las dos primeras LUT operan en F y G con 4 entradas, mientras que la tercera, llamada H, opera en las salidas de las primeras LUT, además de recibir una entrada externa de 4 bits.
- En total, hay 6 entradas disponibles (1 bit de F, 1 bit de G, y 4 bits de H1).
- Puedes usar una única LUT o dividirlas para optimizar y alojar más funciones dentro del mismo CLB.
![[Pasted image 20231025114227.png|500]]
##### CLB Virtex 2 Slice (4 LC) CLB:
- Estos CLB son parte de la familia Virtex 2 y están organizados en Slice (fetos).
- Cada Slice contiene dos bloques espejados llamados LC (Configurable Logic Cells).
- La Slice contiene LUTs con cuatro entradas cada una.
- Cada LC tiene un MUX F5 que agrega un quinto ingreso y se direcciona mediante un señal Bx.
- Además, existe un MUX F6 que agrega un nivel adicional, seleccionado por By.
- Estos multiplexores permiten implementar funciones lógicas y aritméticas con 4, 5, 8, o incluso 9 entradas, dependiendo de la configuración.
![[Pasted image 20231025114233.png|500]]


## Ruteo

### Interconexiones
- Las interconexiones pasan a través de los elementos lógicos y se realizan mediante canales horizontales y verticales en la FPGA.
- En los puntos de cruce, se utiliza una estrategia de enrutamiento que determina cómo se pueden conectar los canales verticales y horizontales. Esto puede hacerse utilizando conexiones disjuntas o estilo Wilton.
![[Pasted image 20231025114716.png|500]]
![[Pasted image 20231025114739.png|500]]

#### Conexiones Disjuntas:
- En el método de conexiones disjuntas, se conectan solo los cables que tienen la misma numeración. Es decir, los cables numerados como 0 se conectan solo a otros cables numerados como 0, y los cables numerados como 1 se conectan solo a otros cables numerados como 1, y así sucesivamente.
- Un segmento que entra en una switch box (caja de conmutación) se puede conectar solo a otros segmentos dentro del mismo dominio numérico.
- Esto limita las conexiones a cables que tienen el mismo número.
![[Pasted image 20231025114755.png|300]]
#### Estilo Wilton:
- El estilo Wilton es similar a las conexiones disjuntas, pero con mayor flexibilidad. En el método Wilton, un segmento puede cambiar de dominio numérico en al menos una dirección, lo que aumenta la flexibilidad de enrutamiento.
- Aunque un segmento numerado como 0 normalmente se conectaría solo a otros segmentos numerados como 0, con el estilo Wilton, es posible asignar el número 0 a diferentes conexiones en diferentes situaciones.
- Para lograr esto, se utiliza una lógica de control dedicada a nivel de FPGA para cambiar el número de interconexiones. Al cambiar el número de una interconexión, es posible conectarla a diferentes cables.
- Esta flexibilidad adicional permite un mayor grado de libertad en el enrutamiento.
![[Pasted image 20231025114803.png|300]]
### Implementación física:
- Hay dos métodos comunes para la implementación física de las interconexiones:
  - **Modo 1: Puerta de Transmisión:** Se utiliza para decidir si se debe establecer o no la interconexión. En este caso, se utilizan tecnologías TTL (Transistor-Transistor Logic) para garantizar que no haya caídas de voltaje. Si se utilizan muchas puertas TTL en serie, pueden surgir problemas de RC (resistencia-capacitancia) debido al número de puertas.
  - **Modo 2: Buffer con TTL:** Se usan buffers unidireccionales (tristate) en ambas direcciones (izquierda a derecha y derecha a izquierda) para restaurar la señal cuando se tiene un gran número de puertas TTL en serie. Los tristates permiten que la señal sea transmitida en una dirección y se detenga en la otra.
- La elección entre TTL y buffers depende de la longitud de la interconexión: se prefieren los TTL para conexiones cortas y los buffers con tristate para las conexiones más largas, lo que evita problemas de degradación de señal.


## Entradas y salidas
- Las celdas I/O necesitan su propia alimentación eléctrica debido a que deben proporcionar una cierta potencia a las señales de entrada o salida.
- Los bloques IOB permiten configurar cada puerto como entrada o salida.
- Además permiten conectar o no Flip Flops para soportar entradas/salidas síncronas o asíncronas.
- Permiten agregar resistores de pull up/down y mapeo a distintas tensiones según la tecnología de los periféricos a conectar.
![[Pasted image 20240205210022.png]]


**Modo Diferencial:**
- En el modo diferencial, la señal de salida se lee entre dos pines, conocidos como un par diferencial.

### Estructura de las Celdas I/O
- Cada celda I/O tiene dos rutas, una para entrada y otra para salida.
- En la ruta de salida, hay un dispositivo de tres estados (tristate) que se utiliza para configurar el pin como entrada o salida. Cuando el tristate está habilitado y configurado en alta impedancia, el lado izquierdo de la celda I/O se desconecta, y el pin funciona como una entrada.
- Las señales de entrada pueden entrar directamente como pines combinatorios asíncronos o pueden ser almacenadas en uno o dos flip-flops. Esto puede causar problemas de asincronía y de metastabilidad del señal (ver esquina inferior derecha de la celda I/O).

### Metastabilidad y Flip-Flops
- La asincronía en la entrada de señales puede causar problemas de metastabilidad. Cuando una señal llega en un momento no predecible en relación con el funcionamiento del flip-flop, puede quedar atrapada en un estado indeterminado. Para abordar este problema, se pueden usar uno o dos flip-flops en la ruta de entrada. Si se utilizan dos flip-flops, el segundo puede ayudar a sincronizar la señal de entrada y, aunque no garantice eliminar completamente la metastabilidad, reduce la probabilidad de problemas significativos.

### Configuración de las Celdas I/O
- Cuando el tristate está habilitado en condiciones de baja impedancia, el pin actúa como una salida y se puede seleccionar cuál de las salidas direccionar al pin de salida.
- Los pines que se utilizan para la entrada/salida de usuario se llaman "pines de usuario", mientras que existen otros pines reservados para alimentación, reloj y otros propósitos.

## Heterogenidad
En las FPGAs modernas, encontramos una mezcla de elementos de lógica programable ("soft logic fabric") y estructuras de circuitos específicos ("hard circuit structure"). Aquí se explica la heterogeneidad en las FPGAs:

**Soft Logic Fabric:**
- Estos son los bloques de lógica programable implementados en elementos de lógica como SRAM o multiplexores.
- Estos bloques son versátiles y pueden configurarse para realizar diversas funciones lógicas.

**Hard Circuit Structure:**
- Son circuitos específicos diseñados para funciones particulares, como multiplicadores, unidades de procesamiento central (CPU), RAM, etc.
- Aunque algunas de estas funciones pueden emularse en la lógica programable, se implementan como circuitos específicos en hardware, lo que puede aumentar el rendimiento y la eficiencia.

La heterogeneidad en las FPGAs se manifiesta de dos maneras:

**1. Heterogeneidad Suave (Soft):**
- Incluye bloques auxiliares que soportan la lógica programable (por ejemplo, flip-flops, lógica de acarreo).
- Estos bloques suaves son parte de la lógica programable, pero tienen un propósito específico y no son tan flexibles como otros bloques programables.

**2. Heterogeneidad Real (Hard):**
- Estos son bloques completamente independientes que realizan funciones específicas y no son parte de la lógica programable.
- A menudo, estas funciones se implementan directamente en hardware, como unidades de procesamiento o módulos de memoria.

Un ejemplo de heterogeneidad suave sería la inclusión de un procesador en una FPGA. Inicialmente, los procesadores externos se conectaban a la lógica programable a través de un bus dedicado en FPGAs como Altera Excalibur o Xilinx Virtex. Más tarde, las FPGAs modernas incluyeron procesadores "duros" (por ejemplo, PowerPC en Xilinx) que forman parte de la propia lógica programable y están conectados con otros módulos programables.

Por otro lado, los procesadores "suaves" (como NIOS en Altera o MicroBlaze en Xilinx) son procesadores programados en la lógica programable de la FPGA y son más lentos en comparación con los procesadores "duros", pero son completamente configurables.

La heterogeneidad permite a las FPGAs combinar lógica programable con hardware específico para mejorar el rendimiento y la eficiencia en aplicaciones específicas. Cada enfoque tiene sus ventajas y desventajas, y la elección depende de los requisitos de la aplicación y las metas de diseño. Por ejemplo, para aplicaciones altamente especializadas, la inclusión de bloques de hardware específicos puede ser más beneficiosa que el uso exclusivo de lógica programable.


## La FPGA que usares
- UNISA:Xilinx Artix 7 Sumarry → CMOD 35t
- DDA: Xilinx Artic 35





# Observaciones importantes
- Software **PYNQ**
	- La FPGA necesita un procesador


## Referencias
### Notas relacionadas
- **Nota:**[[Dispositivos electrónicos]]
	- **Relacion-Reflexion:** Esto tambien vendria a ser parte de lo que nos deberian enseñar en la materia de dispositivos electronicos, ya que esto es un dispositivo electronico